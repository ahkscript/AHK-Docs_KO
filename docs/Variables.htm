<html>
<head>
<title>Variables and Expressions</title>
<meta http-equiv="Content-Type" content="text/html; charset=euc-kr">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<link href="static/theme.css" rel="stylesheet" type="text/css" />
<script src="static/content.js" type="text/javascript"></script>
</head>

<body>
<h1>변수와 표현식</h1>

<h2>목차</h2>
<ul>
  <li><a href="#Variables">변수</a></li>
  <li><a href="#Expressions">표현식</a></li>
  <li><a href="#Operators">표현식 안의 연산자</a></li>
  <li><a href="#BuiltIn">내장 변수</a></li>
  <li><a href="#env">환경 변수 대 보통 변수</a></li>
  <li><a href="#cap">변수의 가용성과 메모리</a></li>
</ul>
<h2 id="Intro"><a name="Variables"></a>변수</h2>
<p><strong>변수 유형</strong>: 오토핫키는 명시적으로 정의된 변수 유형이 없습니다. 그렇지만, 숫자만 들어 있는 변수는 (선택적으로 소수점이 있으면) 수학 연산이나 비교가 필요할 경우 자동으로 숫자로 이해합니다 (수행성능을 개선하기 위해, 숫자는 내부적으로 캐쉬를 해서 문자열과의 상호변환을 피합니다.)</p>
<p><strong>변수 영역과 선언</strong>: 함수에서 <a href="Functions.htm#Locals">지역 변수</a>를 제외하고, 모든 변수는 전역적입니다; 즉, 스크립트의 어디에서든 그 내용을 읽거나 변경할 수 있습니다. <a href="Functions.htm#Global">함수 페이지</a>에 적시한 때를 제외하고, 변수는 선언할 필요가 없습니다; 그냥 사용하면 존재합니다 (각 변수는 빈 상태로 시작합니다).</p>
<p id="Variable_names"><strong>변수 이름</strong>: 변수 이름은 대소문자를 구분하지 않습니다 (예를 들어, <em>CurrentDate</em>는 <em>currentdate</em>와 동일합니다). 변수 이름은 길이가 253 문자까지 허용되고 기호와 숫자 그리고 다음 구두점 표시도 허용됩니다: # _ @ $</p>
<p>스타일 관례 때문에, 일반적으로 변수는 기호와 숫자 그리고 밑줄 문자만 사용하는 편이 더 좋습니다 (예를 들어: <em>CursorPosition</em>, <em>Total_Items</em>, 그리고 <em>entry_is_valid</em>). 이 스타일을 사용하면 다른 언어에 친숙한 사람들이 오토핫키 스크립트를 더 쉽게 읽을 수 있습니다. 또한, &nbsp;오토핫키와 같은 관례를&nbsp; 다른 언어에 사용하면, 여러분 자신의 스크립트를 다시 읽기가 더 쉽다는 것을 아시게 될 것입니다.</p>
<p>
변수 이름을 전적으로 숫자로 구성할 수도 있지만, 이것은 일반적으로 <a href="Scripts.htm#cmd">들어오는 명령어 줄 매개변수</a>에만 사용됩니다. 그런 숫자 이름은 <a href="#Expressions">표현식</a>에 사용할 수 없습니다. 왜냐하면 변수가 아니라 숫자로 인식되기 때문입니다.</p>
<p>
단어 <em>AND</em>와 <em>OR</em> 그리고 <em>NOT</em>은 표현식에 <a href="#Operators">연산자</a>로 사용되기 때문에, 일반적으로 변수 이름으로 사용하면 안됩니다. 그런 이름을 표현식에 사용하면 적절하게 평가되지 않을 것입니다.</p>
<p><strong>변수 안에 변수를 저장하기</strong>: 문자열이나 숫자를 변수에 저장하려면, 전통적 할당과 표현식 할당의 두 가지 방법이 있습니다. 
전통적 방법은 <a href="commands/SetEnv.htm">등호 기호 연산자(=)</a>를 사용하여 <strong>겹따옴표 없는</strong> 기호 숫자열이나 퍼센트 사인에 둘러싸인 변수를 할당합니다. 예를 들어:</p>
<pre>MyNumber = 123
MyString = 이것은 문자열입니다.
CopyOfVar = %Var%  <em>; 변수의 내용을 열람하려면 등호(=) 연산자와 함께 퍼센트 사인이 필요합니다.</em></pre>
<p>대조적으로, 표현식 할당은 <a href="commands/SetExpression.htm">쌍점-등호 연산자 (:=)</a>를 사용하여, 숫자와 <strong>겹따옴표 붙인</strong> 문자열 그리고 기타 유형의 <a href="#Expressions">표현식</a>을 저장합니다. 다음 예제는 기능적으로 앞의 예제와 동일합니다:</p>
<pre>MyNumber := 123
MyString := &quot;이것은 기호 문자열입니다.&quot;
CopyOfVar := Var  <em>; 앞의 예와 다르게, 퍼센트 사인이  := 연산자에 사용되지 않습니다.</em></pre>
<p>더 명료하기 때문에 표현식 할당을 많은 사람들이 선호합니다. 그리고 표현식 할당이 지원하는 <a href="#Expressions">표현식 구문</a>이 다른 많은 언어의 표현식 구문과 거의 동일하기 때문입니다.</p>
<p>
위에서 눈치 채셨겠지만 변수의 내용을 지우는 데에도 두 가지 방법이 있습니다 (즉, 변수를 비우려면):</p>
<pre>MyVar =
MyVar := &quot;&quot;</pre>
<p>
위에서 빈 겹따옴표 쌍은  := 연산자에만 사용해야 하는데 = 연산자와 사용하면 변수 안에 두 개의 겹따옴표 문자가 기호 그대로 저장되어 버리기 때문입니다.</p>
<p><strong>변수의 내용 열람하기</strong>: 값을 저장하는 두 가지 방법과 마찬가지로, 값을 열람하는 방법도 역시 전통적 열람과 표현식 열람 두 가지의 방법이 있습니다. 전통적 열람은 각 변수 이름을 퍼센트 사인으로 둘러 싸기를 요구합니다. 예를 들어:</p>
<pre><a href="commands/MsgBox.htm">MsgBox</a> Var 변수의 값은 %Var% 입니다.
CopyOfVar = %Var%</pre>
<p>
대조적으로, 표현식 열람은 변수 이름 둘레에 퍼센트 기호를 생략하지만, 기호 문자열은 겹따옴표로 둘러야 합니다. 그래서, 다음은 앞 에제의 동등한 표현식입니다:</p>
<pre>MsgBox <strong>%</strong> &quot;The value in the variable named Var is &quot; . Var . &quot;.&quot;  <em>; 두 개의 문자열을 결합하는데 마침표가 사용되었습니다.</em>
CopyOfVar := Var</pre>
<p>위의 MsgBox 줄에서, 퍼센트 사인과 스페이스가 매개변수를 전통적 모드에서 표현식 모드로 바꾸는데 사용되었습니다. 이것은 꼭 필요한데 전통적 방법이 모든 명령어에 기본값으로 사용되기 때문입니다 (문서에 적시된 경우는 예외입니다). 그렇지만, 어떤 명령어의 매개변수들은 표현식을 받아 들인다고 문서에 적시되어 있습니다. 그런 경우 앞의 퍼센트 사인은 허용되지만 필수는 아닙니다. 예를 들어, 다음의 모든 예는 효과가 똑 같습니다. 왜냐하면 <a href="commands/Sleep.htm">Sleep</a>의 첫 번째 매개변수가 표현식을 허용하기 때문입니다:</p>
<pre>Sleep MillisecondsToWait
Sleep %MillisecondsToWait%
Sleep % MillisecondsToWait</pre>
<p>
<strong>변수 비교하기</strong>: 다양한 종류의 비교에 관한 중요한 고지 사항, 특히 언제 괄호를 사용해야 하는가에 관한 정보는 아래의 표현식 섹션을 읽어 보십시오.</p>

<h2 id="Expressions">표현식</h2>
<p>
표현식은 일련의 변수, 기호 문자열, 그리고/또는 기호 숫자에 하나 이상의 연산을 수행하는 데 사용됩니다.</p>
<p>
변수 이름은 표현식에서 퍼센트 사인으로 둘러싸지 않습니다 (<a href="misc/Arrays.htm#pseudo">의사-배열</a>과 기타 <a href="#ref">이중 참조</a>는 제외합니다). 결과적으로, 기호 문자열은 겹따옴표로 둘러싸서 변수와 구별해야 합니다. 예를 들어:</p>
<pre>if (CurrentSetting &gt; 100 or FoundColor &lt;&gt; &quot;Blue&quot;)
    MsgBox 설정이 너무 높거나 잘못된 색이 존재합니다.</pre>
<p>
위의 예제에서, &quot;Blue&quot;는 겹따옴표 안에 있는데 왜냐하면 기호 문자열이기 때문입니다. <em>실제로</em> 인용-문자를 기호 문자열 안에 포함하려면, 두 개의 겹따옴표를 연속으로 지정합니다. 다음 예와 같이 두 번 나타나야 합니다: <code>&quot;She said, <span class="red">&quot;&quot;</span>An apple a day.<span class="red">&quot;&quot;</span>&quot;</code>.</p>
<p>
<strong>중요</strong>: 표현식이 들어 있는 if-서술문은 예를 들어 <code>If FoundColor &lt;&gt; Blue</code>와 같은 <a href="commands/IfEqual.htm">전통적인 if-서술문</a>과 다릅니다. 단어 &quot;if&quot; 뒤의 문자를 여는-괄호로 만듭니다. 
이것은 보통 전체 표현식을 괄호로 둘러싸면 해결되지만, <code>if (x &gt; 0) and (y &gt; 0)</code>와 같이 해도 됩니다. 

게다가, 여는-괄호는 단어 &quot;if&quot; 다음의 첫 항목이 <a href="Functions.htm">함수 호출</a> 또는  &quot;not&quot; 또는 &quot;!&quot;와 같은 연산자일 경우 완전히 생략해도 됩니다.</p>
<p><strong>빈 문자열</strong>: 빈 문자열을 표현식에 지정하려면, 빈 겹따옴표 한 쌍을 사용합니다. 예를 들어, <code>if (MyVar &lt;&gt; &quot;&quot;)</code> 서술문은 <em>MyVar</em>가 비어 있지 않으면 참입니다. 그렇지만, <a href="commands/IfEqual.htm">전통적인-if</a>에서, 한 쌍의 빈 겹따옴표는 기호 그대로 간주합니다. 예를 들어 <code>if MyVar = &quot;&quot;</code>는 <em>MyVar</em>에 실제로 겹따옴표 쌍이 담겨 있을 경우에만 참입니다. 그래서, 변수가 비어있는지 전통적인-if로 점검하려면, 다음 예와 같이 오른쪽에 아무것도 없이 = 또는 &lt;&gt;를 사용하십시오: <code>if Var =</code>.</p>
<p>
관련해서 말씀 드리자면, <code>(x +* 3)</code>와 같이 무효한 식은 빈 문자열을 산출합니다.</p>
<p><strong>표현식의 결과를 저장하기</strong>: 결과를 변수에 저장하려면, <a href="commands/SetExpression.htm">:= 연산자</a>를 사용합니다. 예를 들어:</p>
<pre>NetPrice := Price * (1 - Discount/100)</pre>
<p id="Boolean"><strong>불리언 값</strong>: 
표현식을 참이나 거짓으로 평가할 필요가 있을 때 (IF-서술문처럼), 빈 또는 0인 결과는 거짓으로 간주되고 다른 모든 결과는 참으로 간주됩니다. 예를 들어, 서술문 <code>if ItemCount</code>는 ItemCount가 비어 있거나 0일 경우에만 거짓입니다. 비슷하게, 표현식 <code>if not ItemCount</code>는 그 반대 결과를 산출합니다.</p>
<p>
NOT/AND/OR/&gt;/=/&lt;와 같은 연산자는 자동으로 참 또는 거짓 값을 생산합니다: 참에는 1 그리고 거짓에는 0을 산출합니다. 예를 들어, 다음 표현식에서, 변수 <em>Done</em>은 두 조건중 하나라도 참일 경우 1이 할당됩니다.:</p>
<pre>Done := A_Index &gt; 5 or FoundIt</pre>
<p>
위에서 암시하듯이, 변수는 그냥 비우거나 0을 할당하면 거짓값을 담는데 사용할 수 있습니다. 이를 이용하여, 단축 서술문 <code>if Done</code>을 사용하면 변수 Done이 참인지 거짓인지 점검할 수 있습니다.</p>
<p><a name="True"></a><a name="False"></a>단어 <em>true</em>와 <em>false</em>는 내장 변수로서 각각 1과 0을 담고 있습니다.  다음 예제와 같이 스크립트를 좀 더 읽기 쉽게 만들 수 있습니다:</p>
<pre>CaseSensitive := false
ContinueSearch := true</pre>
<p><strong>정수와 부동 소수점 수</strong>: 표현식 안에서, 숫자는 안에 소수점이 있으면 부동 소수점 수로 간주됩니다; 그렇지 않으면 정수로 취급합니다. 대부분의 연산자에 대하여 -- 예를 들어 덧셈과 곱셈 -- 두 입력중 하나라도 부동 소수점 수이면, 그 결과도 역시 부동 소수점 수가 됩니다.</p>
<p>
표현식과 비-표현식 안에서 비슷하게 정수는 16진수나 십진수 형식으로 작성할 수 있습니다. 16진수는 모두 접두사 0x로 시작합니다. 예를 들어, <code>Sleep 0xFF</code>는 <code>Sleep 255</code>와 동등합니다. v1.0.46.11+에서, 과학적 표기법으로 작성된 부동 소수점 수를 인지합니다; 그러나 안에 소수점이 포함되어 있을 경우에만 인지합니다 (예, <code>1<strong>.</strong>0e4</code> 그리고 <code>-2<strong>.</strong>1E-4</code>).</p>
<p id="percent-space"><strong>강제로 표현식으로 만들기</strong>: 표현식은 매개변수에 사용할 수 있습니다. 직접적으로 지원하지 않더라도 (OutputVar 매개변수 제외) 표현식 앞에 퍼센트 사인과 스페이스 또는 퍼센트 사인과 탭을 두면 됩니다. <span class="ver">[v1.1.21+]</span>에서, 전통적인 IF 명령어를 제외하고 모든 명령어의  InputVar 매개변수에 이 접두사를 사용할 수 있습니다 (대신에 <a href="commands/IfExpression.htm">If (표현식)</a>을 사용하십시오). 

이 테크닉은 종종 <a href="misc/Arrays.htm">배열</a>에 접근하는 데 사용됩니다. 예를 들어:</p>
<pre><a href="commands/FileAppend.htm">FileAppend</a>, <strong>%</strong> MyArray[i], My File.txt
<a href="commands/FileAppend.htm">FileAppend</a>, <strong>%</strong> MyPseudoArray%i%, My File.txt
<a href="commands/MsgBox.htm">MsgBox</a> <strong>%</strong> &quot;The variable MyVar contains &quot; . MyVar . &quot;.&quot;
<a href="commands/Loop.htm">Loop</a> <strong>%</strong> Iterations + 1
<a href="commands/WinSet.htm">WinSet</a>, Transparent, <strong>%</strong> X + 100
<a href="commands/WinSet.htm">Control</a>, Choose, <strong>%</strong> CurrentSelection - 1</pre>
<h2 id="Operators">표현식 안의 연산자</h2>
<p>
곱셈(*)과 나눗셈(/)과 같이 우선순위가 같은 연산자는 왼쪽에서 오른쪽 순서로 평가됩니다. 대조적으로, 덧셈 (+)과 같이 우선 순위가 낮은 연산자는 곱셈(*)과 같이 더 높은 연산자 <em>다음에</em> 평가됩니다. 예를 들어, 3 + 2 * 2는 3 + (2 * 2)으로 평가됩니다. 괄호를 사용하면 다음 예와 같이 우선 순위를 오버라이드할 수 있습니다: (3 + 2) * 2</p>
<p>
아래에 적시한 때를 제외하고, 수학 연산과 관련된 빈 값 (빈 문자열)은 모두 <strong>0으로 간주되지 않습니다</strong>. 대신에, 에러로 취급합니다. 그 때문에 표현식의 일부가 빈 문자열로 평가됩니다. 예를 들어, 변수 X가 비어 있으면, 표현식 X+1은 1이 아니라 빈 값을 산출합니다.</p>

<h3>표현식 연산자 (우선순위가 높은 순서부터 나열합니다)</h3>
<table class="info">
  <tr id="ref">
    <td align="center" style="white-space:nowrap"><strong>%Var%</strong></td>
    <td><p>변수가 표현식 안에서 퍼센트 사인에 둘러 싸여 있으면 (예, %Var%), 그 변수에 <u>들어 있는 것은 어떤 것이든 </u> 또다른 변수의 이름이나 부분 이름으로 간주합니다 (그런 변수가 없다면, %Var%는 빈 문자열로 결정됩니다). 이런 일은 다음 예와 같이 <a href="misc/Arrays.htm#pseudo">의사-배열</a>을 참조하는 데 자주 사용됩니다:</p>
      <pre>Var := MyArray%A_Index% + 100</pre>
      <p>
	  하위 호환을 위해, &quot;표현식일 수 있음&quot;으로 문서화되어 있는 명령어 매개변수는 퍼센트 기호 안에 이름만 있는 변수에서 마치 퍼센트 사인이 없는 것처럼 취급합니다 (예, %Var%, 그러나 Array%i%는 아님). 괄호 안에 그 참조를 둘러싸면 이런 일을 피할 수 있습니다; 예, <code>Sleep (%Var%)</code>.</p>
      <p><span class="ver">[AHK_L 52+]:</span> 보통 변수 외에도, %Var%는 <a href="#env">환경 변수</a>, 클립보드, 또는 <a href="#BuiltIn">예약/읽기-전용 변수</a>로 결정될 수 있습니다. revision 52이전에서, 이런 경우 %Var%는 빈 문자열을 산출했었습니다.</p></td>
  </tr>
  <tr>
    <td align="center"><strong>x.y</strong></td>
    <td><span class="ver">[AHK_L 31+]:</span> <strong>객체 접근</strong>. <i>x</i> 객체에 메쏘드를 호출하거나 값을 설정하고 얻습니다. 여기에서 <i>y</i>는 기호 그대로의 값입니다. <a href="Objects.htm#Usage_Objects">객체 구문</a>을 참조하십시오.</td>
  </tr>
  <tr id="new">
    <td align="center"><strong>new</strong></td>
    <td><span class="ver">[v1.1.00+]:</span> 또다른 객체로부터 상속받아 새 객체를 생성합니다. 예를 들어, <code>x := new y</code>는 종종 <code>x := {base: y}</code>와 동등합니다. <code>new</code>는 다음에 <code>GlobalClass.NestedClass</code>의 형태로 변수나 간단한 클래스 이름이 따라와야 합니다. 그리고 선택적으로 <code>x := new y(z)</code>에서와 같이 매개변수가 따라 옵니다 (여기에서 <code>y</code>는 사용가능하지만, 함수 이름은 아닙니다). 
	자세한 것은 <a href="Objects.htm#Custom_Objects">맞춤 객체</a>를 참조하십시오.</td>
  </tr>
  <tr id="IncDec">
    <td align="center"><strong>++<br>
    --</strong></td>
    <td><strong>전위/후위 증감</strong>. 변수에서 1을 더하거나 뺍니다 (그러나 1.0.46 이전 버전이면, 이것은 오직 그 자체로 한 줄에 사용해야 합니다; 다른 연산자가 없어야 합니다). 연산자는 변수 이름의 앞이나 뒤에 나타납니다. 이름 <em>앞</em>에 나타나면, 연산이 즉시 수행되고 그 결과가 다음 연산에 사용됩니다. 예를 들어, <code>Var := ++X</code>는 X를 즉시 증가시킨 다음 그의 값을 <em>Var</em>에 할당합니다. 반대로, 증감 연산자가 변수 이름 <em>뒤에</em> 있으면 그 변수가 다음 연산에 사용되고 난 <em>후에</em> 연산이 수행됩니다. 예를 들어, <code>Var := X++</code>는 현재 X값을 <em>Var</em>에 할당하고 난 후에 X를 증가시킵니다. 하위 호환의 문제 때문에,   ++ 과 -- 증감 연산자는 빈 변수를 0으로 취급합니다. 그러나 한 줄에 홀로 있을 때만 그렇습니다; 예를 들어, <code>y:=1, ++x</code> 그리고 <code>MsgBox % ++x</code>는 둘 다 x 가 비어 있을 때 빈 결과를 산출합니다.</td>
  </tr>
  <tr id="pow">
    <td align="center"><strong>**</strong></td>
    <td><strong>Power</strong>. 밑수와 지수 모두 십진 소수점을 담을 수 있습니다. 지수가 음수이면, 그 결과는 부동 소수점 수로 포맷됩니다. 밑수와 지수 둘 모두 정수일지라도 그렇습니다.  **는 우선 순위가 단항 마이너스 보다 높기 때문에, <code>-2**2</code>는 <code>-(2**2)</code>로 평가되고 그래서  -4를 산출합니다. 그러므로, 기호 음수를 제곱하려면, <code>(-2)**2</code>와 같이 괄호로 둘러싸십시오. 주의: <code>(-2)**0.5</code>와 같이 음의 밑수가 분수 지수와 결합하는 것은 지원하지 않습니다; 빈 문자열이 산출될 것입니다. 그러나 <code>(-2)**2</code>와 <code>(-2)**2.0</code>는 둘 모두 지원합니다.</td>
  </tr>
  <tr id="unary">
    <td align="center"><strong>-<br>
    !<br>
    ~<br>
    &amp; *</strong></td>
    <td><p><strong>Unary minus (-)</strong>: 뺄셈 연산자와 같은 심볼을 사용하지만, 단항 마이너스는 오직 하나의 항목에만 적용됩니다. 또는 다음 두 예제에서 보여주는 바와 같이 부분-표현식에만 적용됩니다: <code><strong>-</strong>(3 / <strong>-</strong>x)</code>. 관련하여 덧붙인다면, 표현식 안에서 단항 플러스 사인(+)은 무시됩니다.</p>
      <p><strong>Logical-not (!)</strong>: 피연산자가 비어 있거나 0이면, 논리적-not을 적용한 결과는 1입니다. 참(&quot;true&quot;)이라는 뜻입니다. 그렇지 않으면 그 결과는 0입니다 (false). 예를 들어: <code>!x or !(y and z)</code>. 주의: 단어 NOT은 <strong>!</strong>와 동의어입니다. 단 <strong>!</strong>가 더 우선 순위가 높습니다. v1.0.46+에서, <code><strong>!!</strong>Var</code>와 같이 연속적인 단항 연산자가 허용됩니다. 왜냐하면 오른쪽에서 왼쪽 순서로 평가되기 때문입니다.</p>
      <p><strong>Bitwise-not (~)</strong>: 피연산자의 각 비트를 뒤집습니다. 피연산자가 부동소수점 값이면, 먼저 정수로 자르고 나서 계산합니다. 피연산자가 0부터 4294967295 (0xffffffff) 사이이면, <u>부호  없는</u> 32-비트 값으로 취급됩니다. 그렇지 않으면 <u>부호 있는</u> 64-비트 값으로 취급됩니다. 예를 들어, <code>~0xf0f</code>는 0xfffff0f0 (4294963440)으로 평가됩니다.</p>
      <p><a name="amp"></a><strong>Address (&amp;)</strong>: <code>&amp;MyVar</code>는 메모리에서 <em>MyVar</em>의 내용이 있는 주소를 열람합니다. 이 주소는 전형적으로 <a href="commands/DllCall.htm#struct">DllCall 구조</a>에 사용됩니다. <code>&amp;MyVar</code>는 또 그 변수에 대한 이진 숫자를 캐싱하는 것을 불능으로 만듭니다. 수학 계산이나 숫치 비교에 사용되기라도 하면 수행성능이 떨어질 수 있기 때문입니다. 캐싱은 그의 주소가 바뀔 때마다 (예, <a href="commands/VarSetCapacity.htm">VarSetCapacity()</a>를 통하여) 재활성화됩니다.</p>
      <p><strong>Dereference (*)</strong>: <code>*Expression</code>는 <code>Expression</code>이 숫치형 메모리 주소로 결정될 것이라고 간주합니다; 그 주소의 바이트를 0부터 255 사이의 숫자로 열람합니다 (주소가 0이면 언제나 0이 열람됩니다; 그러나 다른 무효한 주소는 모두 스크립트가 충돌할 수 있기 때문에 피해야 합니다). 그렇지만, <a href="commands/NumGet.htm">NumGet()</a>은 일반적으로 이진 숫자를 열람할 때 훨씬 더 수행성능이 좋습니다.</p></td>
  </tr>
  <tr>
    <td align="center"><strong>*<br>
    /<br>
    //
    </strong></td>
    <td><p><strong>곱셈 (*)</strong>: 입력이 모두 정수이면 그 결과도 정수입니다; 그렇지 않으면, 부동 소수점 수입니다.</p>
      <p><a name="divide"></a><strong>실수 나눗셈 (/)</strong>: <a href="commands/EnvDiv.htm">EnvDiv</a>와 다르게, 실수 나눗셈(true division)은 두 입력이 모두 정수라도 부동 소수점 수를 결과로 산출합니다. 예를 들어, <code>3/2</code>는 1이 아니라 1.5를 산출하고, <code>4/2</code>는 2가 아니라 2.0을 산출합니다.</p>
      <p><strong><a name="FloorDivide"></a>바닥 나눗셈 (//)</strong>: 이중-정사선 연산자는 두 입력이 모두 정수이면 성능이 높은 정수 나눗셈을 수행합니다. 예를 들어, <code>5//3</code>는 1이고 <code>5//-3</code>은 -1입니다. 입력 중 하나가 부동 소수점 형식이면, 부동 소수점 나눗셈이 수행되고 그 결과는 왼쪽으로 가장 가까운 정수로 잘라냅니다. 예를 들면, <code>5//3.0</code>은 1.0이고 <code>5.0//-3</code>은 -2.0입니다. 이 부동 소수점 나누셈이 결과가 정수임에도 불구하고, 부동 소수점 형식으로 저장됩니다. 그래서 그 값을 사용하는 것들은 모두 부동 소수점 수라고 인식합니다. 나머지 연산자(modulo)에 관한 것은 <a href="Functions.htm#Mod">mod()</a>를 참조합니다.</p>
    <p>
	<a href="commands/EnvMult.htm">*=</a> 연산자와 <a href="commands/EnvDiv.htm">/=</a> 연산자는 간략하게 한 변수 안의 값을 다른 값으로 곱하거나 나누는 방법입니다. 예를 들어, <code>Var*=2</code>는 <code>Var:=Var*2</code>와 같은 결과를 산출합니다 (그렇지만 전자가 수행성능이 더 좋습니다).</p>
    <p>0으로 나누면 빈 결과 (빈 문자열)이 산출됩니다.</p></td>
  </tr>
  <tr>
    <td align="center"><strong>+<br>
    -</strong></td>
    <td><p><strong>더하고(+)</strong> <strong>뺍니다 (-)</strong>. 관련해서 말씀 드리자면, <a href="commands/EnvAdd.htm"><strong>+=</strong></a> 그리고 <a href="commands/EnvSub.htm"><strong>-=</strong></a> 연산자는 간략하게 변수를 증가시키거나 감소시키는 방법입니다. 예를 들어, <code>Var+=2</code>는 <code>Var:=Var+2</code>와 같은 결과를 생산합니다 (그렇지만 전자가 더 수행성능이 좋습니다). 비슷하게, <a href="#IncDec">Var++, Var--, ++Var, 또는 --Var</a>을 사용하면 변수를 1씩 증가시키거나 감소시킬 수 있습니다.</p>
    </td>
  </tr>
  <tr id="bitwise">
    <td align="center"><strong>&lt;&lt;<br>
    &gt;&gt;</strong></td>
    <td><strong>왼쪽으로 비트 이동 (&lt;&lt;)</strong> 그리고 <strong>오른쪽으로 비트 이동 (&gt;&gt;)</strong>. 사용 방법: <code>Value1 &lt;&lt; Value2</code>. 부동 소수점 수 입력은 먼저 정수로 잘라내고 나서 계산됩니다. 
	
	왼쪽으로 이동 (<strong>&lt;&lt;</strong>)은 <em>Value1</em>을 &quot;<em>Value2</em>의 제곱&quot;. 만큼 곱하는 것과 동등합니다.
	
	오른쪽으로 이동은 (<strong>&gt;&gt;</strong>) <em>Value1</em>을 &quot;<em>Value2</em>의 제곱&quot; 만큼 나누고 그 결과를 왼쪽으로 가장 가까운 정수로 결정하는 것과 동등합니다; 
	예를 들어, <code>-3&gt;&gt;1</code>은 -2입니다.</td>
  </tr>
  <tr>
    <td align="center"><strong>&amp;<br>
      ^<br>
      |
    </strong></td>
    <td><strong>비트별-and (&amp;)</strong>, <strong>비트별-배타적-or (^)</strong>, 그리고 <strong>비트별-or (|)</strong>. 계통도에서, <strong>&amp;</strong>가 우선 순위가 제일 높고 <strong>|</strong>가 제일 낮습니다. 부동 소수점 수는 먼저 정수로 자른 다음에 계산합니다.</td>
  </tr>
  <tr id="concat">
    <td align="center"><strong>.</strong></td>
    <td><p><strong>결합</strong>. 점(dot) 연산자는 두 개의 항목을 하나의 문자열로 결합하는 데 사용됩니다 (점의 양쪽에 적어도 하나의 공간이 있어야 합니다). 
	
	점을 생략해도 같은 결과를 얻을 수 있습니다 (단 <code>x <strong>-</strong>y</code>와 같이 애매하거나, 오른쪽에 있는 항목 앞에 ++ 또는 --이 있는 경우는 제외합니다.). 
	
	점이 생략되면, 병합될 항목 사이에 적어도 공간 하나가 있어야 합니다.<br>
     예제 (표현식 방법): <code>Var := &quot;The color is &quot; <strong>.</strong> FoundColor</code><br>
      예제 (전통적 방법): <code>Var = The color is %FoundColor%</code></p>
        <p>하위-표현식도 역시 결합할 수 있습니다. 예를 들어: <code>Var := &quot;The net price is &quot; <strong>.</strong>  Price * (1 - Discount/100)</code>.</p>
        <p>점으로 (또는 기타 다른 연산자로) 시작하는 줄은 자동으로 윗 줄에 <a href="Scripts.htm#continuation">추가됩니다</a>.</p></td>
  </tr>
  <tr id="regex">
    <td align="center"><strong>~=</strong></td>
    <td><span class="ver">[AHK_L 31+]:</span> <a href="commands/RegExMatch.htm">RegExMatch</a>에 대한 약자입니다. 예를 들어, <code>"abc123" ~= "\d"</code>는 ErrorLevel을 0으로 설정하고 (첫 번째 숫자의 위치) 4를 산출합니다. v1.1.03 이전 버전에서, 이 연산자는 <em>등호</em> (=) 연산자와 우선순위가 같았고 완벽하게 문서화되어 있지 않았습니다.</td>
  </tr>
  <tr id="compare">
    <td align="center"><strong>&gt;&nbsp;&nbsp;&nbsp;&lt;<br>
    &gt;= &lt;=</strong></td>
    <td><strong>초과 (&gt;)</strong>, <strong>미만 (&lt;)</strong>, <strong>이상 (&gt;=)</strong>, 그리고 <strong>이하 (&lt;=)</strong>. 
	
	입력 중 하나라도 숫자가 아니면, 둘은 알파벳 순으로 비교됩니다 (&quot;55&quot;와 같이 겹따옴표가 붙은 문자열은 이 문맥에서 언제가 숫자가 아닌 것으로 간주됩니다). 비교는 대소문자를 구분하지 않습니다. <a href="commands/StringCaseSense.htm">StringCaseSense</a>가 켜져 있으면 대소문자를 구분해서 비교합니다. 다음도 참조하십시오: <a href="commands/Sort.htm">Sort</a></td>
  </tr>
  <tr id="equal">
    <td align="center"><strong>=<br>
      ==<br>
    &lt;&gt; !=</strong></td>
    <td><strong>등호 (=)</strong>, <strong>대소문자-구분-등호 (==)</strong>, 그리고 <strong>같지-않음 (&lt;&gt; 또는 !=)</strong>. 
	
	연산자 <strong>!=</strong>와 <strong>&lt;&gt;</strong>는 기능면에서 동일합니다.  <strong>==</strong> 연산자는 <strong>=</strong>와 동일하게 행위합니다. 입력 중 하나라도 숫자가 아닌 경우는 제외하는데, 그 경우 <strong>==</strong>는 언제나 대소문자를 구분하고 <strong>=</strong>는 언제나 대소문자를 구분하지 않습니다 (대소문자의 구분은 <a href="commands/StringCaseSense.htm">StringCaseSense</a>에 달려 있습니다). 대조적으로, <strong>&lt;&gt;</strong>와 <strong>!=</strong>는 <a href="commands/StringCaseSense.htm">StringCaseSense</a>에 순종합니다. 주의:  &quot;55&quot;와 같이 겹따옴표 붙은 기호 문자열은 언제나 이 문맥에서 숫자가 아닌 것으로 간주됩니다.</td>
  </tr>
  <tr>
    <td align="center"><strong>NOT</strong></td>
    <td><strong>논리적-NOT</strong>. 우선 순위가 낮은 점을 빼고는 <strong>!</strong> 연산자와 동일합니다 예를 들어, <code>not (x = 3 or y = 3)</code>는 <code><strong>!</strong>(x = 3 or y = 3)</code>와 같습니다.</td>
  </tr>
  <tr>
    <td align="center"><strong>AND<br>
    &amp;&amp;</strong></td>
    <td>둘 모두 <strong>논리적-AND</strong>입니다. 예를 들어: <code>x &gt; 3 and x &lt; 10</code>. 수행성능을 개선하기 위해, <a href="Functions.htm#ShortCircuit">단축-회로 평가</a>가 적용됩니다. 또한, AND/OR/&amp;&amp;/|| (또는 기타 다른 연산자)로 시작하는 줄은 자동으로 윗 줄에 <a href="Scripts.htm#continuation">추가됩니다</a>.</td>
  </tr>
  <tr>
    <td align="center"><strong>OR<br>
    ||</strong></td>
    <td>둘 모두 <strong>논리적-OR</strong>입니다. 예를 들어: <code>x &lt;= 3 or x &gt;= 10</code>.  수행성능을 개선하기 위해, <a href="Functions.htm#ShortCircuit">단축-회로 평가</a>가 적용됩니다.</td>
  </tr>
  <tr id="ternary">
    <td align="center"><strong>?:</strong></td>
    <td><strong>삼진 연산자</strong> <span class="ver">[v1.0.46+]</span>. 이 연산자는 <a href="commands/IfExpression.htm">if-else 서술문</a>을 간략하게 교체한 것입니다. 왼쪽의 조건을 평가해 보고 두 분기 중에서 어느 쪽을 최종 결과로 할지 결정합니다. 예를 들어, <code>var := x&gt;y ? 2 : 3</code>는 x가 y보다 크면 2를 <em>Var</em>에 저장하고; 그렇지 않으면 3을 저장합니다. 수행 성능을 개선하기 위하여, 오직 참인 분기만 평가됩니다 (<a href="Functions.htm#ShortCircuit">단축-회로 평가</a>를 참조하십시오).</td>
  </tr>
  <tr id="AssignOp">
    <td align="center"><strong>:=<br>
        +=<br>
        -=<br>
        *=<br>
        /=<br>
        //=<br>
        .=<br>
        |=<br>
        &amp;=<br>
        ^=<br>
        &gt;&gt;=<br>
        &lt;&lt;=</strong>
    </td>
    <td><p><strong>할당</strong>. 변수의 내용에 연산을 수행하고 그 결과를 다시 같은 변수에 저장합니다 (그러나 1.0.46 이전 버전에서는 한 줄 위에서 가장 왼쪽 연산자로만 사용할 수 있었습니다. 그리고 연산자를 앞쪽 다섯 개까지만 지원했습니다.). 가장 단순한 할당 연산자는 <a href="commands/SetExpression.htm">쌍점-등호 (:=)</a>입니다. 표현식의 결과를 변수에 저장합니다. 다른 연산자들이 어떤 일을 하는지 그 설명은 이 표에서 관련 엔트리를 참조하십시오. 예를 들어, <code>Var //= 2</code>는 <a href="#FloorDivide">바닥 나눗셈</a>을 수행하여 <em>Var</em>를 2로 나눈 다음, 그 결과를 다시 <em>Var</em>에 저장합니다. 비슷하게, <code>Var <strong>.=</strong> &quot;abc&quot;</code>는<code>Var := Var <strong>.</strong> &quot;abc&quot;</code>를 간략하게 작성한 것입니다.</p>
      <p>
	  대부분의 다른 연산자와 다르게, 할당은 오른쪽에서 왼쪽으로 평가됩니다. 결과적으로 <code>Var1 := Var2 := 0</code>와 같은 줄은 제일 먼저 0을 <em>Var2</em>에 할당한 다음 <em>Var2</em>를 <em>Var1</em>에 할당합니다.</p>
    <p>
	할당을 다른 연산자의 입력으로 사용하면, 그의 값은 변수 자체입니다. 예를 들어, 표현식 <code>(Var+=2) &gt; 50</code>는 <em>Var</em>에 새로-증가된 값이 50을 초과할 경우에만 참입니다. 
	이렇게 하면 할당을 <a href="Functions.htm#ByRef">ByRef</a>로 건넬 수 있는데, 즉, 그의 <a href="#amp">주소</a>로 건넬 수 있습니다; 
	예를 들어: <code>&amp;(x:=&quot;abc&quot;)</code>.</p>
    <p>
	할당 연산자의 우선순위는 구문 에러를 피하거나 보다 직관적인 행위를 제공하면 자동으로 높아집니다. 예를 들어: <code>not x:=y</code>는 <code>not (x:=y)</code>로 평가됩니다. 비슷하게, <code>++Var := X</code>는 <code>++(Var := X)</code>으로 평가됩니다; 그리고 <code>Z&gt;0 ? X:=2 : Y:=2</code>는 <code>Z&gt;0 ? (X:=2) : (Y:=2)</code>으로 평가됩니다.</p>
    <p>
	하위 호환의 문제 때문에 야기되는 <b>알려진 제한</b>이 있습니다 (미래의 버전에서는 해결될 수 있습니다): 
	<ol>
		<li> <strong>/=</strong>가 표현식에서 가장 왼쪽의 연산자이고  <a href="#comma">다중-서술문 표현식</a>의 일부가 아니면, <a href="#FloorDivide">바닥 나눗셈(floor division)</a>을 수행합니다. 입력 중 하나라도 부동 소수점 수가 아니어야 합니다 (다른 경우는 모두, <strong>/=</strong>는 <a href="#divide">실수 나눗셈(true division)</a>을 합니다.); 
		<li><a href="commands/EnvAdd.htm">날짜/시간 계산</a>을 <strong>+=</strong>과 <strong>-=</strong> 이 지원합니다. 그러나 오직 그 연산자가 한 줄의 가장 왼쪽에 홀로 있을 때만 지원합니다;
		<li>연산자 <strong>+=</strong>, <strong>-=</strong>, 그리고 *= 는 빈 변수를 0으로 취급합니다. 그러나 한 줄에 홀로 있을 경우에만 그렇습니다; 예를 들어, <code>y:=1, x+=1</code>와 <code>MsgBox % x-=3</code>는 둘 다 x가 비어 있을 때 빈 결과를 산출합니다.
	</ol>
</p></td>
  </tr>
  <tr id="comma">
    <td align="center"><strong>,</strong></td>
    <td><p><strong>쉼표 (다중-서술문)</strong> <span class="ver">[v1.0.46+]</span>. 쉼표를 사용하면 여러 하위 표현식을 한 줄에 작성할 수 있습니다. 다중 할당이나 함수 호출을 그룹짓는데 자주 사용됩니다. 예를 들어: <code>x:=1<strong>,</strong> y+=2<strong>,</strong> ++index, func()</code>. 그런 서술문들은 왼쪽에서 오른쪽으로 순서대로 실행됩니다. <b>주의</b>: 쉼표로 (또는 다른 연산자로) 시작하는 줄은 자동으로 윗 줄에 <a href="Scripts.htm#continuation">추가됩니다</a>. 다음도 참조하십시오: <a href="#CommaPerf">쉼표의 연산 성능</a>.</p>
      <p>v1.0.46.01+에서, 쉼표 다음에 곧바로 변수가 따라 오고 다음에 등호 사인이 오면, 그 등호 사인은 자동으로 <a href="commands/SetExpression.htm">할당 (:=)</a>으로 취급됩니다. 예를 들어, 다음은 모두 할당입니다: <code>x:=1, y=2, a=b=c</code>. 새 스크립트는 이 행위에 의존하면 안됩니다. 나중에 변경될 수도 있기 때문입니다. 규칙은 오직 평범한 변수에만 적용될 뿐 <a href="#ref">이중-참조(double-derefs)</a>에는 적용되지 않습니다. 그래서 다음은 오직 하나의 할당만 담겨 있습니다: <code>x:=1, %y%=2</code></p></td>
  </tr>
  <tr>
    <td align="center"><p><strong>mod()<br>
        round()<br>
    abs()</strong></p></td>
    <td>이것과 더불어 다른 내장 수학 함수는 <a href="Functions.htm#Math">여기에</a> 기술되어 있습니다.</td>
  </tr>
  <tr>
    <td align="center"><strong>func.()</strong></td>
    <td><p><span class="ver">[AHK_L 48+]:</span> 객체 <i>func</i>에서 빈 이름의 메쏘드를 호출하려고 시도합니다. 관례적으로, 객체의 "기본" 메쏘드가 호출됩니다. <i>func</i>에 객체가 없다면, 대신에 <a href="Objects.htm#Default_Base_Object">기본 베이스 객체</a>가 요청됩니다.</p>
    <p><span class="ver">[v1.0.95+]:</span> <i>func</i>에 함수 이름이 있다면, 그 함수가 호출됩니다.</p></td>
  </tr>
  <tr>
    <td align="center"><strong>F(<i>p</i>*)</strong></td>
    <td><span class="ver">[AHK_L 60+]:</span><a href="Functions.htm#Variadic">가변 함수</a>를 참조하십시오.</td>
  </tr>
  <tr>
    <td align="center"><strong>x[y]</strong></td>
    <td><span class="ver">[AHK_L 31+]:</span> <strong>객체 접근</strong>. 객체 <i>x</i>의 메쏘드를 호출하거나 설정하거나 얻습니다. 여기에서 <i>y</i>는 매개변수 리스트이거나 계산된 메쏘드 이름입니다. <a href="Objects.htm#Usage_Simple_Arrays">배열 구문</a>과 <a href="Objects.htm#Usage_Objects">객체 구문</a>을 참조합니다.</td>
  </tr>
</table>
<br>
<p><strong>수행 성능</strong>: <a name="CommaPerf" id="CommaPerf"></a> v1.0.48+에서, 쉼표 연산자는 보통 별도의 표현식을 작성하는 것보다 더 빠릅니다. 특히 한 변수를 또다른 변수에 할당할 때 그렇습니다 (예, <code>x:=y, a:=b</code>). 표현식이 모이고 모여 하나의 표현식으로 결합될 수록 수행성능이 향상됩니다; 예를 들어, 다섯개나 열 개의 단순한 표현식을 하나의 표현식으로 결합하면 5% 정도 더 빠릅니다.</p>

<h2 id="BuiltIn">내장 변수</h2>
<p>다음 변수들은 프로그램 안에 내장되어 있으며 스크립트로 참조할 수 있습니다. <a href="misc/Clipboard.htm">Clipboard</a>, <a href="misc/ErrorLevel.htm">ErrorLevel</a>, 그리고 <a href="#CommandLine">명령줄 매개변수</a>는 제외하고, 이런 변수들은 읽기 전용입니다; 즉, 스크립트가 그 내용을 직접적으로 바꿀 수 없습니다.</p>
<h3>목차</h3>
<ul>
  <li>특수 문자: <a href="#Space">A_Space</a>, <a href="#Tab">A_Tab</a></li>
  <li>스크립트 특성: <a href="#CommandLine">명령줄 매개변수</a>, <a href="#WorkingDir">A_WorkingDir</a>, <a href="#ScriptDir">A_ScriptDir</a>, <a href="#ScriptName">A_ScriptName</a>, <a href="#prop">(...기타 등등...)</a></li>
  <li>날짜와 시간: <a href="#YYYY">A_YYYY</a>, <a href="#MM">A_MM</a>, <a href="#DD">A_DD</a>, <a href="#Hour">A_Hour</a>, <a href="#Min">A_Min</a>, <a href="#Sec">A_Sec</a>, <a href="#date">(...기타 등등...)</a></li>
  <li>스크립트 설정: <a href="#IsSuspended">A_IsSuspended</a>, <a href="#BatchLines">A_BatchLines</a>, <a href="#TitleMatchMode">A_TitleMatchMode</a>, <a href="#settings">(...기타 등등...)</a></li>
  <li>User Idle Time: <a href="#TimeIdle">A_TimeIdle</a>, <a href="#TimeIdlePhysical">A_TimeIdlePhysical</a></li>
  <li>GUI 창과 메뉴 바: <a href="#Gui">A_Gui</a>, <a href="#GuiControl">A_GuiControl</a>, <a href="#GuiEvent">A_GuiEvent</a>, <a href="#EventInfo">A_EventInfo</a></li>
  <li>핫키, 핫스트링, 그리고 맞춤 메뉴 항목: <a href="#ThisHotkey">A_ThisHotkey</a>, <a href="#EndChar">A_EndChar</a>, <a href="#ThisMenuItem">A_ThisMenuItem</a>, <a href="#h">(...기타 등등...)</a></li>
  <li>운영 체제와 사용자 정보: <a href="#OSVersion">A_OSVersion</a>, <a href="#Screen">A_ScreenWidth</a>, <a href="#Screen">A_ScreenHeight</a>, <a href="#os">(...기타 등등...)</a></li>
  <li>기타: <a href="#Cursor">A_Cursor</a>, <a href="#Caret">A_CaretX</a>, <a href="#Caret">A_CaretY</a>, <a href="misc/Clipboard.htm">Clipboard</a>, <a href="misc/Clipboard.htm#ClipboardAll">ClipboardAll</a>, <a href="misc/ErrorLevel.htm">ErrorLevel</a></li>
  <li>회돌이: <a href="#Index">A_Index</a>, <a href="#loop">(...기타 등등...)</a></li>
</ul>
<h3>특수 문자</h3>
<table class="info">
  <tr id="Space">
    <td>A_Space</td>
    <td>이 변수는 스페이스 문자가 하나 담겨 있습니다. 자세한 것은 <a href="commands/AutoTrim.htm">AutoTrim</a>을 참조하십시오.</td>
  </tr>
  <tr id="Tab">
    <td>A_Tab</td>
    <td>이 변수는 탭 문자 하나가 담겨 있습니다. 자세한 것은 <a href="commands/AutoTrim.htm">AutoTrim</a> 을 참조하십시오.</td>
  </tr>
</table>
<h3 id="prop">스크립트 특성</h3>
<table class="info">
  <tr id="CommandLine">
    <td>1, 2, 3, 등등.</td>
    <td>이 변수들은 스크립트가 명령어줄 매개변수와 함께 기동할 때마다 자동으로 생성됩니다. 마치 보통의 변수 이름처럼 똑같이 참조하고 변경할 수 있습니다 (예: %1%). 변수 %0%에는 건네어진 매개변수의 개수가 담겨 있습니다 (아무것도 없으면 0입니다). 자세한 것은 <a href="Scripts.htm#cmd">명령어 줄 매개변수</a>를 참조하십시오.</td>
  </tr>
  <tr id="WorkingDir">
    <td>A_WorkingDir</td>
    <td>스크립트의 현재 작업 디렉토리로서, 기본값으로 여기에서 파일에 접근합니다. 마지막의 역사선은 루트 디렉토리가 아닌 한 포함되지 않습니다. 다음은 두 개의 예입니다: C:\ 그리고 C:\My Documents.
	<a href="commands/SetWorkingDir.htm">SetWorkingDir</a>를 사용하면 작업 디렉토리를 바꿀 수 있습니다.</td>
  </tr>
  <tr id="ScriptDir">
    <td>A_ScriptDir</td>
    <td>현재 스크립트가 위치한 디렉토리의 완전한 경로입니다. 마지막의 역사선은 생략합니다 (루트 디렉토리도 마찬가지로 생략합니다).</td>
  </tr>
  <tr id="ScriptName">
    <td>A_ScriptName</td>
    <td>현재 스크립트의 파일 이름입니다. 경로가 없습니다. 예, MyScript.ahk.</td>
  </tr>
  <tr id="ScriptFullPath">
    <td>A_ScriptFullPath</td>
    <td>위의 두 변수를 조합해 스크립트를 완전하게 지정합니다. 예, C:\My Documents\My Script.ahk</td>
  </tr>
  <tr id="ScriptHwnd">
    <td>A_ScriptHwnd<br><span class="ver">[v1.1.01+]</span></td>
    <td>스크립트의 숨은 메인 창의 유일한 ID (HWND/handle)입니다.</td>
  </tr>
  <tr id="LineNumber">
    <td>A_LineNumber</td>
    <td><p>스크립트 안에서 현재 실행중인 줄의 번호입니다 (또는 그의 <a href="commands/_Include.htm">#Include 파일 중 하나입니다</a>). 이 줄 번호는 <a href="commands/ListLines.htm">ListLines</a>이 보여주는 줄 번호와 일치합니다; 다음 예제와 같이 에러를 보고할 경우에 유용하게 사용할 수 있습니다: <code>MsgBox 로그 파일에 기록할 수 없었음 (줄 번호: %A_LineNumber%)</code>.</p>
    <p>
	<a href="Scripts.htm#ahk2exe">컴파일된 스크립트는</a> 자신의 모든 <a href="commands/_Include.htm">#Include 파일</a>들을 하나의 커다란 스크립트로 병합해 넣기 때문에, 비-컴파일 모드에서 실행할 때와 줄 번호가 다를 수 있습니다.</p></td>
  </tr>
  <tr id="LineFile">
    <td>A_LineFile</td>
    <td><a href="#LineNumber">A_LineNumber</a>가 속해 있는 파일의 전체 경로와 이름입니다. <a href="#ScriptFullPath">A_ScriptFullPath</a>와 동일합니다. 물론
	그 줄이 비-컴파일된 스크립트의 <a href="commands/_Include.htm">#Include 파일</a> 중 하나에 속해 있지 않아야 합니다.</td>
  </tr>
  <tr id="ThisFunc">
    <td>A_ThisFunc<br>
    <span class="ver">[v1.0.46.16+]</span></td>
    <td>현재 실행 중인 <a href="Functions.htm">사용자-정의 함수</a>의 이름입니다 (없으면 비어 있습니다); 예를 들어: MyFunction. 다음도 참조하십시오: <a href="Functions.htm#IsFunc">IsFunc()</a></td>
  </tr>
  <tr id="ThisLabel">
    <td>A_ThisLabel<br>
    <span class="ver">[v1.0.46.16+]</span></td>
    <td>현재 실행 중인 <a href="misc/Labels.htm">라벨</a> (서브루틴)의 이름입니다 (없으면 비어 있습니다); 예를 들어: MyLabel. 스크립트가 <a href="commands/Gosub.htm">Gosub</a>/<a href="commands/Return.htm">Return</a> 또는 <a href="commands/Goto.htm">Goto</a>를 실행할 때마다 갱신됩니다. 또 자동으로-호출되는 라벨에 대해서도 갱신됩니다. 여기에는 <a href="commands/SetTimer.htm">타이머</a>, <a href="commands/Gui.htm#DefaultWin">GUI 쓰레드</a>, <a href="commands/Menu.htm">메뉴 항목</a>, <a href="Hotkeys.htm">핫키</a>, <a href="Hotstrings.htm">핫스트링</a>, <a href="commands/OnClipboardChange.htm">OnClipboardChange</a> (라벨), 그리고 <a href="commands/OnExit.htm">OnExit</a>이 있습니다.
	 그렇지만, 실행이 위의 자동-호출 라벨로부터 또다른 라벨로 &quot;떨어지는&quot;경우 A_ThisLabel는 갱신되지 않습니다; 그런 일이 일어나면, A_ThisLabel은 이전의 값을 유지합니다. 다음도 참조하십시오: <a href="#ThisHotkey">A_ThisHotkey</a> 그리고 <a href="Functions.htm#IsLabel">IsLabel()</a></td>
  </tr>
  <tr id="AhkVersion">
    <td>A_AhkVersion</td>
    <td>1.0.22 이전 버전에서, 이 변수는 비어 있습니다. 그렇지 않으면, 스크립트를 실행하고 있는 오토핫키의 버전이 담깁니다. 예, 1.0.22. <a href="Scripts.htm#ahk2exe">컴파일된 스크립트</a>의 경우, 원래 컴파일에 사용된 버전이 보고됩니다. 버전 번호의 형식을 보고 스크립트는 A_AhkVersion이 다음 예와 같이 <code>&gt;</code> 또는 <code>&gt;=</code>로 최소한의 버전 번호보다 큰지 점검할 수 있습니다: <code>if A_AhkVersion &gt;= 1.0.25.07</code>.</td>
  </tr>
  <tr id="AhkPath">
    <td>A_AhkPath</td>
    <td><p>비-컴파일 스크립트라면: 현재 스크립트를 실제로 실행중인  EXE 파일의 이름과 전체 경로입니다. 예를 들어: C:\Program Files\AutoHotkey\AutoHotkey.exe</p>
    <p><a href="Scripts.htm#ahk2exe">컴파일된 스크립트</a>라면: 위와 같지만 예외는 AutoHotkey 디렉토리가 레지스트리 <em>HKEY_LOCAL_MACHINE\SOFTWARE\AutoHotkey\InstallDir</em> 엔트리를 통하여 발견된다는 것입니다. 그런 엔트리가 없다면, A_AhkPath는 비어 있습니다.</p></td>
  </tr>
  <tr id="IsUnicode">
    <td>A_IsUnicode</td>
    <td>문자열이 유니코드 (16-비트)이면 1이 ANSI (8-비트)이면 빈 문자열이 담깁니다 (<a href="#Boolean">거짓</a>으로 간주됨). 문자열의 형식은 스크립트를 실행하는 데 사용된 AutoHotkey.exe 버전에 따라 다릅니다. 컴파일된 스크립트라면, 컴파일에 사용된 실행파일에 따라 다릅니다.</td>
  </tr>
  <tr id="IsCompiled">
    <td>A_IsCompiled</td>
    <td>스크립트가 <a href="Scripts.htm#ahk2exe">컴파일 된 EXE</a>로 실행되면 1이 그렇지 않으면 빈 문자열이 담깁니다 (<a href="#Boolean">거짓</a>으로 간주).</td>
  </tr>
  <tr id="ExitReason">
    <td>A_ExitReason</td>
    <td>스크립트를 끝내게 된 가장 최근의 이유입니다. 이 변수는 스크립트에 <a href="commands/OnExit.htm">OnExit</a> 서브루틴이 있고 그 서브루틴이 현재 실행중이거나 종료 시도로 적어도 한 번 호출된 적이 없는 한, 비어 있습니다. 자세한 것은 <a href="commands/OnExit.htm">OnExit</a>을 참조하십시오.</td>
  </tr>
</table>
<h3 id="date">날짜와 시간</h3>
<table class="info">
  <tr id="YYYY">
    <td>A_YYYY</td>
    <td>현재의 4-자리 년도입니다 (예, 2004). A_Year와 동의어입니다. 주의: 여러분의 로케일과 언어에 대하여 적절하게 포맷된 날짜와 시간을 열람하려면, <code><a href="commands/FormatTime.htm">FormatTime</a>, OutputVar</code> (시간과 긴 날짜) 또는 <code><a href="commands/FormatTime.htm">FormatTime</a>, OutputVar,, LongDate</code> (긴-형식의 날짜를 열람)를 사용하십시오.</td>
  </tr>
  <tr id="MM">
    <td>A_MM</td>
    <td>현재의 2-자리 월입니다 (01-12). A_Mon와 동일합니다.</td>
  </tr>
  <tr id="DD">
    <td>A_DD</td>
    <td>현재 2-자리 월별 날짜입니다 (01-31). A_MDay와 동일합니다.</td>
  </tr>
  <tr id="MMMM">
    <td>A_MMMM</td>
    <td>현재 사용자 언어로 현재 달의 전체 이름입니다. 예, July</td>
  </tr>
  <tr id="MMM">
    <td>A_MMM</td>
    <td>현재 사용자 언어로 현재 달의 약자입니다. 예, Jul</td>
  </tr>
  <tr id="DDDD">
    <td>A_DDDD</td>
    <td>현재 사용자 언어로 현재 요일의 전체 이름입니다. 예, Sunday</td>
  </tr>
  <tr id="DDD">
    <td>A_DDD</td>
    <td>현재 사용자 언어로 현재 요일의 3-문자 약어입니다. 예, Sun</td>
  </tr>
  <tr id="WDay">
    <td>A_WDay</td>
    <td>현재 요일의 1-자리 수입니다 (1-7). 1은 모든 로케일에서 일요일입니다.</td>
  </tr>
  <tr id="YDay">
    <td>A_YDay</td>
    <td>연별 현재 날짜입니다 (1-366). 값은 0으로 채워지지 않습니다. 예를 들어, 0이 열람되지, 009가 열람되는 것은 아닙니다. 0으로 덧대어진 값을 열람하려면, 다음을 사용합니다: <code><a href="commands/FormatTime.htm">FormatTime</a>, OutputVar,, YDay0</code>.</td>
  </tr>
  <tr id="YWeek">
    <td>A_YWeek</td>
    <td>ISO 8601에 따른 현재 년도와 주 번호 (예. 200453). 년도와 주를 가르려면 <code><a href="commands/StringLeft.htm">StringLeft</a>, Year, A_YWeek, 4</code> 그리고 <code><a href="commands/StringLeft.htm">StringRight</a>, Week, A_YWeek, 2</code>를 사용합니다. 
	<p>
	A_YWeek의 정밀한 정의: 1월 1일을 담고 있는 주가 새 해에서 4일 이상을 가지면, 그것을 1 번 주로 간주합니다. 그렇지 않으면, 이전 년도의 마지막 주이고, 다음 주가 1 번 주입니다.</td>
  </tr>
  <tr id="Hour">
    <td>A_Hour</td>
    <td>24시간제로 현재의 2-자리 시 (00-23) (예를 들어, 17는 오후 5시). AM/PM 표시와 함께 12시간제로 열람하려면, 다음 예를 따르십시오: <code><a href="commands/FormatTime.htm">FormatTime</a>, OutputVar, , h:mm:ss tt</code></td>
  </tr>
  <tr id="Min">
    <td>A_Min</td>
    <td><p>현재 2-자리 분 (00-59).</p></td>
  </tr>
  <tr id="Sec">
    <td>A_Sec</td>
    <td>현재  2-자리 초 (00-59).</td>
  </tr>
  <tr id="MSec">
    <td>A_MSec</td>
    <td>현재 3-자리 밀리초 (000-999). 앞의 0을 제거하려면 다음 예제를 따르십시오: <code>Milliseconds := A_MSec + 0</code>.</td>
  </tr>
  <tr id="Now">
    <td>A_Now</td>
    <td><a href="commands/FileSetTime.htm#YYYYMMDD">YYYYMMDDHH24MISS</a> 형식으로 현재 로컬 시간 입니다. 주의: 날짜와 시간 연산은 <a href="commands/EnvAdd.htm">EnvAdd</a> 그리고 <a href="commands/EnvSub.htm">EnvSub</a>로 수행할 수 있습니다. 또, <a href="commands/FormatTime.htm">FormatTime</a>으로 날짜와 시간을 여러분의 로케일 또는 기호에 맞게 포맷할 수 있습니다.</td>
  </tr>
  <tr id="NowUTC">
    <td>A_NowUTC</td>
    <td>현재의 협정 세계시(Coordinated Universal Time (UTC))입니다. 형식은 <a href="commands/FileSetTime.htm#YYYYMMDD">YYYYMMDDHH24MISS</a>입니다. 
	UTC는 본질적으로 그리니치 표준시(Greenwich Mean Time (GMT))과 똑같습니다.</td>
  </tr>
  <tr id="TickCount">
    <td>A_TickCount</td>
    <td><p>컴퓨터가 리부팅된 이후로 경과한 밀리초의 개수. A_TickCount를 변수에 저장해 두고 나중에 가장 마지막 A_TickCount 값에서 빼어서 경과한 시간을 측정할 수 있습니다. 예를 들어:</p>
        <pre>StartTime := A_TickCount
Sleep, 1000
ElapsedTime := A_TickCount - StartTime
MsgBox,  %ElapsedTime% 밀리초가 경과하였습니다.</pre>
<p>
A_TickCount의 밀리초보다 더 정밀해야 한다면, <a href="commands/DllCall.htm#QPC">QueryPerformanceCounter()</a>를 사용합니다.</p>
</td>
  </tr>
</table>
<h3 id="settings">Script Settings</h3>
<table class="info">
  <tr id="IsSuspended">
    <td>A_IsSuspended</td>
    <td>스크립트가 <a href="commands/Suspend.htm">보류중이면(suspended)</a> 1이 그렇지 않으면 0이 담깁니다.</td>
  </tr>
  <tr id="IsPaused">
    <td>A_IsPaused<br>
    <span class="ver">[v1.0.48+]</span></td>
    <td>현재 쓰레드 바로 아래의 <a href="misc/Threads.htm">쓰레드</a>가 <a href="commands/Pause.htm">정지되어</a> 있으면 1이 담깁니다. 그렇지만 0이 담깁니다.</td>
  </tr>
  <tr id="IsCritical">
    <td>A_IsCritical<br>
    <span class="ver">[v1.0.48+]</span></td>
    <td><a href="misc/Threads.htm">현재 쓰레드</a>에 대하여 <a href="commands/Critical.htm">임계구역</a> 밖이면 0이 담깁니다. 그렇지 않으면 0보다 큰 정수값이 담깁니다. 
	
	즉, Critical에서 <a href="commands/Critical.htm#Interval">메시지-점검 빈도</a>를 사용중입니다. 
	
	<code>Critical 0</code>이면 임계 구역 점검을 끄기 때문에, 임계 구역의 현재 상태를 저장하고 나중에 <code>Old_IsCritical := A_IsCritical</code>를 한 다음에 <code>Critical %Old_IsCritical%</code>를 통하여 복구할 수 있습니다.</td>
  </tr>
  <tr id="BatchLines">
    <td>A_BatchLines</td>
    <td>(A_NumBatchLines와 동의어) <a href="commands/SetBatchLines.htm">SetBatchLines</a>에 의하여 설정된 현재 값입니다. 예제: 200 또는 10ms (포맷에 따라 다름).</td>
  </tr>
  <tr id="TitleMatchMode">
    <td>A_TitleMatchMode</td>
    <td><a href="commands/SetTitleMatchMode.htm">SetTitleMatchMode</a>가 설정한 현재 부합모드입니다: 1, 2, 3, 또는 RegEx.</td>
  </tr>
  <tr id="TitleMatchModeSpeed">
    <td>A_TitleMatchModeSpeed</td>
    <td><a href="commands/SetTitleMatchMode.htm">SetTitleMatchMode</a>가 설정한 현재 일치 속도입니다 (fast 또는 slow) .</td>
  </tr>
  <tr id="DetectHiddenWindows">
    <td>A_DetectHiddenWindows</td>
    <td><a href="commands/DetectHiddenWindows.htm">DetectHiddenWindows</a>가 설정한 현재 모드입니다 (On 또는 Off).</td>
  </tr>
  <tr id="DetectHiddenText">
    <td>A_DetectHiddenText</td>
    <td><a href="commands/DetectHiddenText.htm">DetectHiddenText</a>가 설정한 현재 모드입니다 (On 또는 Off).</td>
  </tr>
  <tr id="AutoTrim">
    <td>A_AutoTrim</td>
    <td><a href="commands/AutoTrim.htm">AutoTrim</a>이 설정한 현재 모드입니다 (On 또는 Off) .</td>
  </tr>
  <tr id="StringCaseSense">
    <td>A_StringCaseSense</td>
    <td><a href="commands/StringCaseSense.htm">StringCaseSense</a>가 설정한 현재 모드입니다 (On, Off, 또는 Locale) .</td>
  </tr>
  <tr id="FileEncoding">
    <td>A_FileEncoding</td>
    <td><span class="ver">[AHK_L 46+]</span> 다양한 명령어에 대하여 기본 인코딩이 담겨 있습니다; <a href="commands/FileEncoding.htm">FileEncoding</a>를 참조하십시오.</td>
  </tr>
  <tr id="FormatInteger">
    <td>A_FormatInteger</td>
    <td><a href="commands/SetFormat.htm">SetFormat</a>이 설정한 현재 정수 형식 (H 또는 D). <span class="ver">[AHK_L 42+]:</span> 이것은 소문자 h를 담을 수도 있습니다.</td>
  </tr>
  <tr id="FormatFloat">
    <td>A_FormatFloat</td>
    <td><a href="commands/SetFormat.htm">SetFormat</a>이 설정한 현재 부동 소수점 수 형식.</td>
  </tr>
  <tr id="KeyDelay">
    <td>A_KeyDelay</td>
    <td><a href="commands/SetKeyDelay.htm">SetKeyDelay</a>가 설정한 현재 지연 시간 (언제나 10진수를 사용합니다). 이 지연 시간은 전통적인 SendEvent 모드를 위한 것이며, <a href="commands/Send.htm#SendPlayDetail">SendPlay</a>를 위한 것이 아닙니다.</td>
  </tr>
  <tr id="WinDelay">
    <td>A_WinDelay</td>
    <td><a href="commands/SetWinDelay.htm">SetWinDelay</a>가 설정한 현재 지연 시간 (언제나 십진법을 사용합니다).</td>
  </tr>
  <tr id="ControlDelay">
    <td>A_ControlDelay</td>
    <td><a href="commands/SetControlDelay.htm">SetControlDelay</a>가 설정한 현재 지연 시간 (언제나 10진수를 사용합니다).</td>
  </tr>
  <tr id="MouseDelay">
    <td>A_MouseDelay</td>
    <td><a href="commands/SetMouseDelay.htm">SetMouseDelay</a>가 설정한 현재 지연 시간 (언제나 십지수를 사용합니다). 이 지연은 전통적인 SendEvent 모드를 위한 것이며, <a href="commands/Send.htm#SendPlayDetail">SendPlay</a>를 위한 것이 아닙니다.</td>
  </tr>
  <tr id="DefaultMouseSpeed">
    <td>A_DefaultMouseSpeed</td>
    <td><a href="commands/SetDefaultMouseSpeed.htm">SetDefaultMouseSpeed</a>가 설정한 현재 속도 (언제나 십진법을 사용합니다. 십육진법은 사용하지 않습니다).</td>
  </tr>
  <tr id="RegView">
    <td>A_RegView</td>
    <td><span class="ver">[v1.1.08+]:</span> <a href="commands/SetRegView.htm">SetRegView</a>가 설정한 현재 레지스트리 뷰입니다.</td>
  </tr>
  <tr id="IconHidden">
    <td>A_IconHidden</td>
    <td>트레이 아이콘이 현재 보이지 않으면 1 그렇지 않으면 0이 담깁니다. 아이콘은 <a href="commands/_NoTrayIcon.htm">#NoTrayIcon</a>이나 <a href="commands/Menu.htm">Menu</a> 명령어를 통하여 감출 수 있습니다.</td>
  </tr>
  <tr id="IconTip">
    <td>A_IconTip</td>
    <td>트레이 아이콘에 맞춤 툴팁이 <code><a href="commands/Menu.htm">Menu</a>, Tray, Tip</code>을 통하여 지정되어 있지 않은 한, 비어 있습니다 --  지정되어 있으면 툴팁 텍스트가 담깁니다.</td>
  </tr>
  <tr id="IconFile">
    <td>A_IconFile</td>
    <td>맞춤 트레이 아이콘이 <code><a href="commands/Menu.htm">Menu</a>, tray, icon</code>을 통하여 지정되어 있지 않은 한 비어 있습니다 --지정 되어 있을 경우 그 아이콘 파일의 전체 경로와 이름이 담깁니다. 
	<p>
	<strong>알려진 한게:</strong> 스크립트가 처음부터 상대적인 경로를 시스템 DLL에 건넸다면 이 경로는 올바르지 않을 수 있습니다; 예를 들어, <code>Menu, Tray, Icon, user32.dll, 2</code>.</td>
  </tr>
  <tr id="IconNumber">
    <td>A_IconNumber</td>
    <td>A_IconFile이 비어 있으면 비어 있습니다. 그렇지 않으면, A_IconFile의 아이콘 번호입니다 (전형적으로 1).</td>
  </tr>
</table>
<h3>User Idle Time</h3>
<table class="info">
  <tr id="TimeIdle">
    <td>A_TimeIdle</td>
    <td>키보드나 마우스 또는 기타 입력으로부터 시스템이 입력을 받은 이후로 경과한 시간의 밀리초 개수입니다. 사용자가 컴퓨터 앞에 있는지 판단하는데 유용합니다. 사용자로부터 받는 물리적 입력과 더불어  <strong>프로그램이나 스크립트</strong>가 만들어 내는 인위적인 입력은 (<a href="commands/Send.htm">Send</a> 또는 <a href="commands/MouseMove.htm">MouseMove</a> 명령어) 이 값을 다시 0으로 재설정합니다. 이 값은 10씩 증가하는 경향이 있기 때문에, 다른 값과 같은지 비교하면 안됩니다. 대신에, 다른 값보다 큰지 작은지로 비교하십시오. 예를 들어: <code>IfGreater, A_TimeIdle, 600000, MsgBox, 마지막 키보드나 마우스 활동이 적어도 10 분 전이었습니다</code>.</td>
  </tr>
  <tr id="TimeIdlePhysical">
    <td>A_TimeIdlePhysical</td>
    <td><p>위와 비슷하지만 상응하는 갈고리가 설치되어 있으면 인위적인 키눌림과 마우스 클릭을 무시합니다. (<a href="commands/_InstallKeybdHook.htm">keyboard</a> 또는 <a href="commands/_InstallMouseHook.htm">mouse</a>); 즉, 오직 물리적 이벤트에만 응답합니다. (마치 사용자가 존재하는 듯이 키보드나 마우스 클릭을 흉내내는 것을 방지합니다.) 갈고리가 설치되어 있지 않으면, 이 값은 A_TimeIdle과 동등합니다. 둘 중에 하나의 갈고리만 설치되어 있으면, 물리적 입력의 유형만  A_TimeIdlePhysical에 영향을 미칩니다 (다른/설치-안된 갈고리의 입력은, 물리적 입력과 인위적 입력에 모두 영향이 없습니다).</p></td>
  </tr>
</table>
<h3>GUI 창과 메뉴 바</h3>
<table class="info">
  <tr id="Gui">
    <td>A_Gui</td>
    <td><a href="misc/Threads.htm">현재 쓰레드</a>를 기동한 <a href="commands/Gui.htm">GUI</a>의 이름이나 번호입니다. 이 변수는 Gui 콘트롤, 메뉴 바 항목, 또는 GuiClose/GuiEscape와 같은 이벤트가 현재 쓰레드를 기동하지 않았다면 비어 있습니다.</td>
  </tr>
  <tr id="GuiControl">
    <td>A_GuiControl</td>
    <td><a href="misc/Threads.htm">현재 쓰레드</a>를 기동한 구이 콘트롤에 연관된 변수의 이름입니다. 구이 콘트롤에 <a href="commands/Gui.htm#Events">연관 변수</a>가 없으면, 대신에 A_GuiControl에는 해당 콘트롤의 텍스트/캡션의 앞쪽 63개의 문자가 담깁니다 (각 버튼에 변수 이름을 부여하지 않기 위해 자주 사용됩니다). A_GuiControl은 다음과 같은 경우 비어 있습니다: 
	<ol>
		<li>A_Gui가 비어 있다;
		<li>GUI 메뉴 바 항목이나  GuiClose/GuiEscape과 같은 이벤트가 현재 쓰레드를 기동시켰다;
		<li>콘트롤에 연관 변수가 없으며 캡션도 없다;
		<li>또는 현재 쓰레드를 기동시킨 최초의 콘트롤이 (아마도 <a href="commands/Gui.htm#Destroy">Gui Destroy</a> 때문에 더 이상 존재하지 않는다).
	</ol>
</td>
  </tr>
  <tr id="GuiWidth">
    <td>A_GuiWidth<br>
    A_GuiHeight</td>
    <td><a href="commands/Gui.htm#GuiSize">GuiSize 서브루틴</a>에서 참조할 때 GUI 창의 너비와 높이가 담깁니다. 창의 클라이언트 구역에 적용됩니다. 클라이언트 구역은 타이틀 바와 메뉴 바 그리고 테두리를 제외한 구역입니다. <span class="ver">[v1.1.11+]:</span> 이 값들은 <a href="commands/Gui.htm#DPIScale">DPI 스케일링</a>에 영향을 받습니다.</td>
  </tr>
  <tr id="GuiX">
    <td><a name="GuiY" id="GuiY"></a>A_GuiX<br>
    A_GuiY</td>
    <td><a href="commands/Gui.htm#GuiContextMenu">GuiContextMenu</a> 이벤트와 <a href="commands/Gui.htm#GuiDropFiles">GuiDropFiles</a> 이베트가 일어날 때 X 좌표와 Y 좌표를 담고 있습니다. 좌표는 창의 좌상 모서리에 상대적입니다. <span class="ver">[v1.1.11+]:</span> 이 값들은 <a href="commands/Gui.htm#DPIScale">DPI 스케일링</a>에 영향을 받습니다.</td>
  </tr>
  <tr>
    <td>A_GuiEvent<br><span class="small80">또는 A_GuiControlEvent</span></td>
    <td><p><a name="GuiControlEvent"></a><a name="GuiEvent"></a>
	
	<a href="misc/Threads.htm">현재 쓰레드</a>를 기동한 이벤트의 종류. 쓰레드가 <a href="commands/Gui.htm">GUI 행위</a>를 통하여 기동되지 않았다면, 이 변수는 비어 있습니다. 그렇지 않으면, 다음 문자열 중 하나가 담깁니다:</p>
      <p><strong>Normal</strong>: 이벤트가 왼클릭 또는 키눌림으로 기동되었습니다 (화살표 키, TAB 키, 스페이스바, 밑줄 단축키 등등.). 이 값은 또GuiClose 그리고 GuiEscape와 같은 특수한 이벤트 그리고 메뉴 바 항목에도 사용됩니다.</p>
      <p><strong>DoubleClick</strong>: 이벤트가 더블클릭으로 촉발되었습니다. 주의: 클릭-쌍 중에 첫 클릭은  먼저 <em>Normal</em> 이벤트를 받습니다. 다시 말해, 서브루틴은 두 번 기동됩니다: 한 번은 첫 클릭에 그리고 다시 두 번째 클릭에 기동됩니다.</p>
      <p><strong>RightClick</strong>: 오직 <a href="commands/Gui.htm#GuiContextMenu">GuiContextMenu</a>, <a href="commands/ListView.htm">ListViews</a>, 그리고 <a href="commands/TreeView.htm">TreeViews</a>에만 일어납니다.</p>
      <p><strong>문맥-감지 값:</strong> 자세한 것은 <a href="commands/Gui.htm#GuiContextMenu">GuiContextMenu</a>, <a href="commands/Gui.htm#GuiDropFiles">GuiDropFiles</a>, <a href="commands/GuiControls.htm#Slider">Slider</a>, <a href="commands/GuiControls.htm#MonthCal">MonthCal</a>, <a href="commands/ListView.htm">ListView</a>, 그리고 <a href="commands/TreeView.htm">TreeView</a>를 참조하십시오.</p>
    </td>
  </tr>
  <tr id="EventInfo">
    <td>A_EventInfo</td>
    <td><p>다음 이벤트들에 대한 추가 정보를 담고 있습니다:</p>
      <ul>
        <li><a href="commands/OnClipboardChange.htm">OnClipboardChange 라벨</a></li>
        <li><a href="Hotkeys.htm#Wheel">마우스 휠 핫키</a> (WheelDown/Up/Left/Right)</li>
        <li><a href="commands/RegisterCallback.htm">RegisterCallback()</a></li>
        <li><a href="commands/Gui.htm#label">GUI events</a>, 즉 <a href="commands/Gui.htm#GuiContextMenu">GuiContextMenu</a>, <a href="commands/Gui.htm#GuiDropFiles">GuiDropFiles</a>, <a href="commands/GuiControls.htm#ListBox">ListBox</a>, <a href="commands/ListView.htm">ListView</a>, <a href="commands/TreeView.htm">TreeView</a>, 그리고 <a href="commands/GuiControls.htm#StatusBar">StatusBar</a>. 이벤트에 대하여 더 이상 추가 정보가 없으면, A_EventInfo에는 0이 담깁니다.</li>
      </ul></td>
  </tr>
</table>
<p>주의: A_ThisHotkey와 같은 변수와 다르게, 각 <a href="misc/Threads.htm">쓰레드</a>마다 A_Gui, A_GuiControl, A_GuiX/Y, A_GuiEvent, 그리고 A_EventInfo에 대하여 자신의 값을 유지합니다. 그러므로, 쓰레드가 다른 쓰레드에 의해 인터럽트 되더라도, 실행을 재개하면 여전히 이 값들에서 자신의 원래/올바른 값을 볼 수 있습니다.</p>

<h3 id="h">핫키, 핫스트링, 그리고 맞춤 메뉴 항목</h3>
<table class="info">
  <tr id="ThisMenuItem">
    <td>A_ThisMenuItem</td>
    <td>가장 최근에 선택된 <a href="commands/Menu.htm">맞춤 메뉴 항목</a>의 이름입니다 (없으면 비어 있습니다).</td>
  </tr>
  <tr id="ThisMenu">
    <td>A_ThisMenu</td>
    <td>A_ThisMenuItem가 선택된 곳의 메뉴 이름입니다.</td>
  </tr>
  <tr id="ThisMenuItemPos">
    <td>A_ThisMenuItemPos</td>
    <td A_ThisMenu>안에서 A_ThisMenuItem의 <u>현재</u> 위치를 가리키는 번호입니다. 메뉴에서 첫 번째 항목은 1이고, 두 번째 항목은 2, 등등입니다. 메뉴 가름자 줄도 계산에 들어 갑니다. 이 변수는 A_ThisMenu메뉴 안에  A_ThisMenuItem이 비어 있거나 더 이상 존재하지 않으면 비어 있습니다. 또  A_ThisMenu 자체가 존재하지 않을 경우에도 비어 있습니다.</td>
  </tr>
  <tr id="ThisHotkey">
    <td>A_ThisHotkey</td>
    <td><p>가장 최근에 실행된 <a href="Hotkeys.htm">핫키</a> 또는 <a href="Hotstrings.htm">비-자동-교체 핫스트링</a>입니다 (없으면 비어 있습니다). 예, #z. 이 값은 <a href="misc/Threads.htm">현재 쓰레드</a>가 또다른 핫키로 인터럽트 되면 변합니다. 그래서 나중에 서브루틴에서 사용하기 위해 원래 값이 필요하다면 즉시 또다른 변수에 복사하십시오.</p>
      <p>핫키가 처음으로 - 스크립트에서 <a href="commands/Hotkey.htm">핫키 명령어</a>나 <a href="Hotkeys.htm">이중-쌍점 라벨</a>로 -- 만들어질 때, 그의 키 이름과 그의 수식 심볼의 순서가 그 핫키의 영구적인 이름이 됩니다. 그 이름을 핫키의 모든 <a href="commands/_IfWinActive.htm#variant">변형</a>들이 공유합니다.</p>
      <p>다음도 참조하십시오: <a href="#ThisLabel">A_ThisLabel</a></p></td>
  </tr>
  <tr id="PriorHotkey">
    <td>A_PriorHotkey</td>
    <td>위와 같지만 이전의 핫키는 제외합니다. 없으면 비어 있습니다.</td>
  </tr>
  <tr id="PriorKey">
    <td>A_PriorKey</td>
    <td><span class="ver">[v1.1.01+]:</span> 가장 최근의 키-누름이나 키-뗌보다 앞에 눌린 마지막 키의 이름입니다. 아니면 키 히스토리에서 적용가능한 키-누름을 발견할 수 없을 경우 비어 있습니다. 
	
	오토핫기 스크립트가 생성한 모든 입력은 배제됩니다. 이 변수를 사용하려면, <a href="commands/_InstallKeybdHook.htm">키보드 갈고리</a>나 <a href="commands/_InstallMouseHook.htm">마우스 갈고리</a>가 반드시 설치되어 있어야 하고 <a href="commands/KeyHistory.htm">키 히스토리</a>가 활성화되어 있어야 합니다.</td>
  </tr>
  <tr id="TimeSinceThisHotkey">
    <td>A_TimeSinceThisHotkey</td>
    <td> A_ThisHotkey가 눌린 이후로 경과한 밀리초의 개수입니다. A_ThisHotkey가 빌 때마다 -1이 됩니다.</td>
  </tr>
  <tr id="TimeSincePriorHotkey">
    <td>A_TimeSincePriorHotkey</td>
    <td>A_PriorHotkey가 눌린 이후로 경과한 밀리초의 개수입니다. A_PriorHotkey가 빌 때마다  -1이 됩니다.</td>
  </tr>
  <tr id="EndChar">
    <td>A_EndChar</td>
    <td>가장 최근의 <a href="Hotstrings.htm">비-자동-교체-핫스트링</a>을 촉발시키기 위해 사용자가 누른 <a href="Hotstrings.htm#EndChars">종료 문자(ending character)</a>입니다. 종료 문자를 ( * 옵션 때문에) 요구하지 않았다면, 이 값은 비어 있습니다.</td>
  </tr>
</table>
<h3 id="os">운영 체제와 사용자 정보</h3>
<table class="info">
  <tr>
    <td>ComSpec<br>
    <span class="ver">[v1.0.43.08+]</span></td>
    <td><a name="ComSpec" id="ComSpec"></a>ComSpec 환경 변수와 같은 문자열을 담고 있습니다(예, C:\Windows\system32\cmd.exe). 종종 <a href="commands/Run.htm">Run/RunWait</a>와 함께 사용됩니다. 주의: 이 변수에는  A_ prefix가 붙지 않습니다.</td>
  </tr>
  <tr id="Temp">
    <td>A_Temp<br>
    <span class="ver">[v1.0.43.09+]</span></td>
    <td>임시 파일을 보유하도록 지정된 폴더의 전체 경로와 이름 (예, C:\DOCUME~1\UserName\LOCALS~1\Temp). (순서대로) 다음 위치 중 하나에서 열람합니다: 1) <a href="#env">환경 변수</a> TMP, TEMP, 또는 USERPROFILE; 2) Windows 디렉토리.</td>
  </tr>
  <tr id="OSType">
    <td>A_OSType</td>
    <td>실행 중인 운영 체제의 종류입니다. AutoHotkey 1.1은 오직 NT-기반의 운영 체제만 지원하기 때문에, 이 값은 언제나 WIN32_NT입니다. 예전 버전은 Windows 95/98/ME에서 실행될 때  WIN32_WINDOWS를 돌려줍니다.</td>
  </tr>
  <tr id="OSVersion">
    <td>A_OSVersion</td>
    <td><p>다음 문자열 중 하나입니다: WIN_7 <span class="ver">[requires AHK_L 42+]</span>, WIN_8 <span class="ver">[requires v1.1.08+]</span>, WIN_8.1 <span class="ver">[requires v1.1.15+]</span>, WIN_VISTA, WIN_2003, WIN_XP, WIN_2000.</p>
    <p>
	호환성 설정을 오토핫키 실행파일이나 컴파일된 스크립트의 특성에 적용하면 운영체제가 다른 버전 번호를 돌려줍니다. 이것이 A_OSVersion에 반영됩니다.</p>
    <p><span class="ver">[v1.1.20+]:</span> OS 버전을 위에 언급한 리스트에서 찾을 수 없으면, 문자열이 "major.minor.build" 형태로 반환됩니다. 예를 들어 10 TP는 <code>6.4.9841</code>입니다.</p>
      <pre><em>; 이 예제는 폐기되었습니다. 이 운영체제는 더 이상 지원하지 않습니다.</em>
if A_OSVersion in WIN_NT4,WIN_95,WIN_98,WIN_ME  <em>; 주의: 쉼표 둘레에 스페이스가 없음에 주의합니다.</em>
{
    MsgBox 이 스크립트는 Windows 2000/XP 이상을 요구합니다.
    ExitApp
}</pre>
    </td>
  </tr>
  <tr id="Is64bitOS">
    <td>A_Is64bitOS</td>
    <td><span class="ver">[v1.1.08+]:</span> 운영체제가 64비트이면 1 (true) 또는 운영체제가 32비트이면 0 (false)을 담고 있습니다.</td>
  </tr>
  <tr id="PtrSize">
    <td>A_PtrSize</td>
    <td><span class="ver">[AHK_L 42+]:</span> 포인터의 크기를 바이트 단위로 담고 있습니다. 이것은 4 (32-bit) 또는 8 (64-bit)입니다. 어떤 유형의 실행파일을 (EXE) 스크립트가 실행하는가에 따라 다릅니다.</td>
  </tr>
  <tr id="Language">
    <td>A_Language</td>
    <td>시스템의 기본 언어입니다 <a href="misc/Languages.htm">다음 4-자리 코드</a>중 하나입니다.</td>
  </tr>
  <tr id="ComputerName">
    <td>A_ComputerName</td>
    <td>네트워크에 보여지는 컴퓨터 이름입니다.</td>
  </tr>
  <tr id="UserName">
    <td>A_UserName</td>
    <td>이 스크립트를 기동한 사용자의 로그온 이름입니다.</td>
  </tr>
  <tr id="WinDir">
    <td>A_WinDir</td>
    <td>윈도우즈 디렉토리입니다. 예를 들어: C:\Windows</td>
  </tr>
  <tr id="ProgramFiles">
    <td>A_ProgramFiles<br>
    또는 ProgramFiles</td>
    <td>프로그램 파일 디렉토리입니다 (예, C:\Program Files).  v1.0.43.08+에서, A_ prefix를 생략해도 가능합니다. 그러면 쉽게 <a href="commands/_NoEnv.htm">#NoEnv</a>이전하는 데 도움이 됩니다.</td>
  </tr>
  <tr id="AppData">
    <td>A_AppData<br>
    <span class="ver">[v1.0.43.09+]</span></td>
    <td>현재 사용자 어플리케이션의 특정한 데이터를 담고 있는 폴더의  전체 경로와 이름입니다. 예를 들어: C:\Documents and Settings\Username\Application Data</td>
  </tr>
  <tr id="AppDataCommon">
    <td>A_AppDataCommon<br>
    <span class="ver">[v1.0.43.09+]</span></td>
    <td>모든-사용자 어플리케이션의 특정한 데이터를 담고 있는 폴더의 전체 경로와 이름입니다.</td>
  </tr>
  <tr id="Desktop">
    <td>A_Desktop</td>
    <td>현재 사용자 데스크탑 파일을 담고 있는 폴더의 전체 경로와 이름입니다.</td>
  </tr>
  <tr id="DesktopCommon">
    <td>A_DesktopCommon</td>
    <td>모든-사용자 데스크탑 파일을 담고 있는 폴더의 전체 경로와 이름입니다.</td>
  </tr>
  <tr id="StartMenu">
    <td>A_StartMenu</td>
    <td>현재 사용자이 시작 메뉴 폴더의 전체 경로와 이름입니다.</td>
  </tr>
  <tr id="StartMenuCommon">
    <td>A_StartMenuCommon</td>
    <td>모든-사용자 시작 메뉴 폴더의 전체 경로와 이름입니다.</td>
  </tr>
  <tr id="Programs">
    <td>A_Programs</td>
    <td>현재 사용자 시작 메뉴에 있는 프로그램 폴더의 전체 경로와 이름입니다.</td>
  </tr>
  <tr id="ProgramsCommon">
    <td>A_ProgramsCommon</td>
    <td>모든 사용자 시작 메뉴에 있는 프로그램 폴더의 전체 경로와 이름입니다.</td>
  </tr>
  <tr id="Startup">
    <td>A_Startup</td>
    <td>현재 사용자 시작 메뉴에 있는 시작 폴더의 전체 경로와 이름입니다.</td>
  </tr>
  <tr id="StartupCommon">
    <td>A_StartupCommon</td>
    <td>모든-사용자 시작 메뉴에 있는 시작 폴더의 전체 경로와 이름입니다.</td>
  </tr>
  <tr id="MyDocuments">
    <td>A_MyDocuments</td>
    <td>현재 사용자의 &quot;나의 문서&quot; 폴더의 전체 경로와 이름입니다. 대부분의 비슷한 변수와 다르게, 이 폴더가 드라이브의 루트이면, 마지막 역사선을 포함하지 않습니다. 예를 들어, M:\가 아니라 M:이 됩니다.</td>
  </tr>
  <tr id="IsAdmin">
    <td>A_IsAdmin</td>
    <td><p>현재 사용자가 관리자 권한이 있으면, 이 변수는 1, 그렇지 않으면 0이 담깁니다.</p>
    <p><a name="RequireAdmin" id="RequireAdmin"></a>윈도우즈 비스타 이후에서 어떤 스크립트는 적절하게 기능을 발휘하기 위해 관리자 권한을 요구합니다 (예를 들어 프롯스나 창과 상호작용하는 스크립트는 관리자 권한으로 실행됩니다). 이렇게 하려면, 다음을 스크립트의 상단에 추가하십시오:</p>
    <pre>if not A_IsAdmin
{
   Run *RunAs &quot;%A_ScriptFullPath%&quot;  <em>; Requires v1.0.92.01+</em>
   ExitApp
}</pre></td>
  </tr>
  <tr id="Screen">
    <td><p>A_ScreenWidth<br>
    A_ScreenHeight</p></td>
    <td><p>기본 모니터의 너비와 높이, 픽셀 단위 (예, 1024 그리고 768).</p>
      <p>다중 모니터 시스템에서 다른 모니터의 크기를 알려면, <a href="commands/SysGet.htm">SysGet</a>를 사용합니다.</p>
      <p>대신에 (다중 모니터에 걸쳐 있더라도) 전체 데스크탑의 너비와 높이를 알려면, 다음 예제를 사용합니다:</p>
<pre>
<a href="commands/SysGet.htm">SysGet</a>, VirtualWidth, 78
<a href="commands/SysGet.htm">SysGet</a>, VirtualHeight, 79
</pre>
    <p>게다가, <a href="commands/SysGet.htm">SysGet</a>을 사용하면 모니의 작업 영역을 알 수 있습니다. 모니터의 전체 영역보다 더 작을 수 있습니다. 왜냐하면 태스크바와 기타 등록된 데스크탑 툴바가 배제되어 있기 때문입니다.</p></td>
  </tr>
  <tr id="ScreenDPI">
    <td>A_ScreenDPI <span class="ver">[v1.1.11+]</span></td>
    <td>화면 너비를 따라 논리적 인치당 픽셀의 개수입니다. 다중 모니터 시스템에서, 이 값은 모든 모니터에 대하여 같습니다. 대부분의 시스템에 이 값은 96입니다; 그렇지만 시스템의 텍스트 크기(DPI) 설정에 따라 다릅니다. 또 <a href="commands/Gui.htm#DPIScale">Gui -DPIScale</a>을 참조하십시오.</td>
  </tr>
  <tr id="IPAddress">
    <td>A_IPAddress1 through 4</td>
    <td>컴퓨터에서 네트워크 어댑터의 IP 주소의 앞쪽 4 자리입니다.</td>
  </tr>
</table>
<h3>기타</h3>
<table class="info">
  <tr id="Cursor">
    <td>A_Cursor</td>
    <td><p>현재 화면에 보여지는 마우스 커서의 유형입니다. 다음 단어 중 하나입니다: <br>AppStarting, Arrow, Cross, Help, IBeam, Icon, No, Size, SizeAll, SizeNESW, SizeNS, SizeNWSE, SizeWE, UpArrow, Wait, Unknown. 
	<p>
	Size-유형의 커서에 사용된 약자는 방위를 나타냅니다. 예, NESW = NorthEast+SouthWest. 
	손-모양의 커서는 (찍기와 잡기)는 Unknown으로 분류되어 있습니다.</p></td>
  </tr>
  <tr id="Caret">
    <td>A_CaretX<br>
    A_CaretY</td>
    <td><p>현재 캐럿(텍스트 삽입 위치)의 X와 Y 좌표입니다. 이 좌표는 활성 창에 상대적입니다. <a href="commands/CoordMode.htm">CoordMode</a>를 사용하여 전체 화면에 대하여 상대적으로 만들지 않는 한 말입니다. 활성 창이 없거나 캐럿 위치를 결정할 수 없으면, 이 변수는 비어 있습니다.</p>
      <p>다음 스크립트로 캐럿을 이동시켜서 그의 현재 위치가 자동-갱신 툴팁에 나타나는 것을 볼 수 있습니다. 어떤 창은 (예, MS Word) 실제 위치에 상관 없이 같은 캐럿 위치를 보고합니다.</p>
<pre>
#Persistent
SetTimer, WatchCaret, 100
return
WatchCaret:
  ToolTip, X%A_CaretX% Y%A_CaretY%, A_CaretX, A_CaretY - 20
return
</pre>
    </td>
  </tr>
  <tr>
    <td>Clipboard</td>
    <td>운영체제의 클립보드에 있는 내용입니다. 읽고 쓸 수 있습니다.  <a href="misc/Clipboard.htm">클립보드</a> 섹션을 참조하십시오.</td>
  </tr>
  <tr>
    <td>ClipboardAll</td>
    <td>클립보드의 전체 내용입니다 (포맷과 텍스트 같은). <a href="misc/Clipboard.htm#ClipboardAll">ClipboardAll</a>을 참조하십시오.</td>
  </tr>
  <tr>
    <td>ErrorLevel</td>
    <td><a href="misc/ErrorLevel.htm">ErrorLevel</a>을 참조하십시오.</td>
  </tr>
  <tr id="LastError">
    <td>A_LastError</td>
    <td>OS의 GetLastError() 함수의 결과 또는  COM 객체 요청의 최종 결과. 자세한 것은 <a href="commands/DllCall.htm#LastError">DllCall()</a> 그리고 <a href="commands/Run.htm#LastError">Run/RunWait</a>를 참조합니다.</td>
  </tr>
</table>
<h3 id="loop">회돌이</h3>
<table class="info">
  <tr id="Index">
    <td>A_Index</td>
    <td>현재 회돌이의 반복 횟수입니다 (64-비트 정수). 예를 들어, 스크립트가 회돌이의 몸체를 처음 실행하면, 이 변수는 숫자 1이 담깁니다. 더 자세한 것은 <a href="commands/Loop.htm">회돌이</a> 또는 <a href="commands/While.htm">While-회돌이</a>를 참조하십시오.</td>
  </tr>
  <tr>
    <td>A_LoopFileName, 등등.</td>
    <td>이 변수와 기타 관련 변수들은 <a href="commands/LoopFile.htm">파일-회돌이</a> 안에서만 유효합니다.</td>
  </tr>
  <tr>
    <td>A_LoopRegName, 등등.</td>
    <td>이 변수와 기타 관련 변수들은 <a href="commands/LoopReg.htm">레지스트리-회돌이</a> 안에서만 유효합니다.</td>
  </tr>
  <tr>
    <td>A_LoopReadLine</td>
    <td><a href="commands/LoopReadFile.htm">파일-읽기 회돌이</a>를 참조하십시오.</td>
  </tr>
  <tr>
    <td>A_LoopField</td>
    <td><a href="commands/LoopParse.htm">회돌이 파싱하기</a>를 참조하십시오.</td>
  </tr>
</table>

<h2 id="env">환경 변수 대. &quot;보통&quot; 변수</h2>
<p>
환경 변수는 운영 체제가 관리합니다. 명령어 프롬프트에서 SET을 타자하고 엔터를 치면 그 목록을 보실 수 있습니다.</p>
<p>스크립트는 <a href="commands/EnvSet.htm">EnvSet</a>으로 새 환경 변수를 만들거나 기존의 변수 내용을 바꿀 수 있습니다. 그렇지만, 그렇게 추가하고 변경하는 것은 사적입니다; 나머지 시스템에 보이지 않습니다. 한 가지 예외는 스크립트가 <a href="commands/Run.htm">Run</a>이나 <a href="commands/Run.htm">RunWait</a>를 사용하여 프로그램을 (또다른 스크립트) 기동시켰을 때입니다: 그런 프로그램은 부모 스크립트의 환경 변수 사본을 상속받습니다. 사적인 환경 변수도 당연히 포함됩니다.</p>
<p>v1.0.43.08+에서, 모든 새 스크립트는 <em>Path</em>와 같은 환경 변수를 다음과 같이 열람하기를 권장합니다:</p>
<pre><a href="commands/EnvGet.htm">EnvGet, OutputVar, Path</a>  <em>; For explanation, see <a href="commands/_NoEnv.htm">#NoEnv</a>.</em></pre>
<h2 id="cap">변수의 가용성과 메모리</h2>
<ul>
  <li>각 변수는 최대 64 MB 텍스트를 담을 수 있습니다 (이 제한은  <a href="commands/_MaxMem.htm">#MaxMem</a>을 증가시킬 수 있습니다).</li>
  <li>변수에 현재 내용보다 더 긴 새 문자열이 주어지면, 추가 시스템 메모리가 자동으로 할당됩니다.</li>
  <li>거대한 메모리가 점유한 메모리는 비워 버리면 해제됩니다. 예, <code>var := &quot;&quot;</code>.</li>
  <li>스크립트에 얼마나 많은 변수를 생성할 수 있는지는 제한이 없습니다. 적어도 수 백만개의 변수를 수행성능의 저하 없이 지원하도록 설계되어 있습니다.</li>
  <li>숫치 입력을 받는 명령어, 함수, 그리고 표현식은 일반적으로 부동 소수점 수에 대하여 15 자리수의 정밀도를 지원합니다. 정수에 대해서는, 64-비트 부호있는 값을 지원합니다. 그 범위는 -9223372036854775808 (-0x8000000000000000)부터 9223372036854775807 (0x7FFFFFFFFFFFFFFF)까지입니다. 이 범위를 벗어나는 정수 상수는 지원하지 않으며 일관성 없는 결과를 산출합니다. 대조적으로, 정수 산술 연산은 빙 돌아 범람해 버립니다 (예, 0x7FFFFFFFFFFFFFFF + 1 = -0x8000000000000000).</li>
</ul>
</body>
</html>
