<!DOCTYPE HTML>
<html lang="ko">
<head>
<title>Send/SendRaw/SendInput/SendPlay/SendEvent: Send keys &amp; clicks</title>
<meta name="description" content="Send keystrokes and mouse clicks to any window with this free macro program. SendInput is generally the fastest and most reliable method.">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<link href="../static/theme.css" rel="stylesheet" type="text/css" />
<script src="../static/content.js" type="text/javascript"></script>
<style type="text/css">
<!--
.red {color: #FF0000; font-weight: bold;}
-->
</style>
</head>
<body>

<h1>Send / SendRaw / SendInput / SendPlay / SendEvent: Send Keys &amp; Clicks</h1>

<p>키눌림과 마우스 클릭을 흉내내어 <a href="WinActivate.htm">활성</a> 창에 전송합니다.</p>

<pre class="Syntax">Send Keys
SendRaw Keys
SendInput Keys
SendPlay Keys
SendEvent Keys</pre>

<h3>매개변수</h3>
<dl>

  <dt>Keys</dt>
  <dd><p>전송할 키 연속열. 다른 명령어처럼, 첫 매개변수 앞의 쉼표는 선택적입니다.</p></dd>

</dl>

<p><strong><a name="SendRaw"></a>날 모드</strong>: <em>SendRaw</em> 명령어는 모든 문자들 문자 그대로 해석합니다. {Enter}를 ENTER 키눌림으로, ^c를 Control-C로, 등등 변환하지 않습니다. 그렇지만, 피신 연속열의 정상 규칙, 변수 참조 그리고 표현식은 여전히 적용됩니다. 왜냐하면 명령어가 실행되기 전에 이것들이 먼저 처리되기 때문입니다. SendInput, SendPlay, 또는 SendEvent에 날 모드를 사용하려면, 문자열에서 첫 항목에 <a href="#Raw">{Raw}</a>를 쓰십시오. 예를 들어: <code>SendInput {Raw}abc</code>.</p>
<p>
<strong>정상 모드</strong>: 날 모드가 아닐 때, 다음 문자들은 수식자로 취급됩니다 (이 수식 키들은 바로 다음 키에만 영향을 줍니다):</p>
<p>
<span class="red">!</span>: ALT 키눌림을 전송합니다. 예를 들어, <code>Send This is text!a</code>는 &quot;This is text&quot;를 전송한 다음 ALT+a를 누릅니다. <strong>주의</strong>: !A는 어떤 프로그램에서는 !a와 전혀 다른 효과를 냅니다. 이것은 !A가 ALT+SHIFT+A를 누르는 반면 !a는 ALT+a를 누르기 때문입니다. 잘 모르겠으면, 소문자를 사용하십시오.</p>
<p>
<span class="red">+</span>: SHIFT 키눌림을 전송합니다. 예를 들어, <code>Send +abC</code>는  &quot;AbC&quot;를 전송하고, <code>Send !+a</code>는 ALT+SHIFT+a를 누릅니다.</p>
<p>
<span class="red">^</span>: CONTROL 키눌림을 전송합니다. 예를 들어, <code>Send ^!a</code>는 CTRL+ALT+a를 누르고, <code>Send ^{Home}</code>는 CONTROL+HOME을 누릅니다. <strong>주의</strong>: ^A는 어떤 프로그램에서 ^a와 전혀 다른 효과를 냅니다. 왜냐하면 ^A는 CONTROL+SHIFT+A를 누르는 반면 ^a는 CONTROL+a를 누르기 때문입니다. 잘 모르겠으면, 소문자를 사용하십시오.</p>
<p>
<span class="red">#</span>: WIN 키눌림을 전송합니다. 그러므로 <code>Send #e</code>는 Windows 키를 누른 채로 기호 &quot;e&quot;를 누릅니다.</p>
<p><br>
<a name="SendInput"></a><a name="SendPlay"></a><strong>SendInput</strong>그리고 <strong>SendPlay</strong> <span class="ver">[v1.0.43+]:</span> SendInput 그리고 SendPlay는 Send와 같은 구문을 사용합니다. 그러나 일반적으로 더 빠르고 더 신뢰성이 있습니다. 게다가, 전송하는 동안에 물리적 키눌림과 마우스 클릭을 버퍼 처리해 줍니다. 그 덕분에 사용자의 키눌림이 흩어지지 않고 온전하게 전송됩니다. <a href="SendMode.htm">SendMode</a>을 사용하면 Send를 SendInput 또는 SendPlay과 똑같이 만들 수 있습니다. 각 모드에 관하여 더 자세한 정보는 아래의 <a href="#SendInputDetail">SendInput</a> 그리고 <a href="#SendPlayDetail">SendPlay</a>를 참조하십시오.</p>
<p>
<a name="SendEvent"></a><strong>SendEvent</strong> <span class="ver">[v1.0.43+]:</span> SendEvent는 1.0.43-이전의  <em>Send</em> 명령어와 같은 방법으로 키눌림을 전송합니다. 키눌림의 전송 비율은 <a href="SetKeyDelay.htm">SetKeyDelay</a>로 결정됩니다. 기본값으로, <em>Send</em>는 <em>SendEvent</em>와 동일하지만; <a href="SendMode.htm">SendMode</a>를 통하여 <a href="#SendInputDetail">SendInput</a>이나 <a href="#SendPlayDetail">SendPlay</a>와 같게 만들 수 있습니다 .</p>
<p>
<strong>Key Names</strong>: 다음 테이블은 전송이 가능한 특수 키들을 나열합니다. (각 키 이름은 활괄호로 둘러싸야 합니다):</p>
<table class="info">
  <tr>
    <th width="200">키 이름</th>
    <th>결과 키눌림</th>
  </tr>
  <tr>
    <td align="center">{F1} - {F24}</td>
    <td>기능 키. 예를 들어: {F12}는 F12 키.</td>
  </tr>
  <tr>
    <td align="center">{!}</td>
    <td>!</td>
  </tr>
  <tr>
    <td align="center">{#}</td>
    <td>#</td>
  </tr>
  <tr>
    <td align="center">{+}</td>
    <td>+</td>
  </tr>
  <tr>
    <td align="center">{^}</td>
    <td>^</td>
  </tr>
  <tr>
    <td align="center">{{}</td>
    <td>{</td>
  </tr>
  <tr>
    <td align="center">{}}</td>
    <td>}</td>
  </tr>
  <tr>
    <td align="center">{Enter}</td>
    <td>메인 키보드의 엔터키</td>
  </tr>
  <tr>
    <td align="center">{Escape} 또는 {Esc}</td>
    <td>ESCAPE</td>
  </tr>
  <tr>
    <td align="center">{Space}</td>
    <td>SPACE (스페이스가 전송할 문자열의 앞이나 뒤에 나타날 때 필요합니다 -- 가운데 있는 스페이스는 문자 그대로 스페이스입니다)</td>
  </tr>
  <tr>
    <td align="center">{Tab}</td>
    <td>탭키</td>
  </tr>
  <tr>
    <td align="center">{Backspace} 또는 {BS}</td>
    <td>백스페이스</td>
  </tr>
  <tr>
    <td align="center">{Delete} 또는 {Del}</td>
    <td>삭제</td>
  </tr>
  <tr>
    <td align="center">{Insert} 또는 {Ins}</td>
    <td>삽입</td>
  </tr>
  <tr>
    <td align="center">{Up}</td>
    <td>메인 위 화살표 키</td>
  </tr>
  <tr>
    <td align="center">{Down}</td>
    <td>메인 아래 화살표 키</td>
  </tr>
  <tr>
    <td align="center">{Left}</td>
    <td>메인 왼쪽 화살표 키</td>
  </tr>
  <tr>
    <td align="center">{Right}</td>
    <td>메인 오른쪽 화살표 키</td>
  </tr>
  <tr>
    <td align="center">{Home}</td>
    <td>메인 홈 키</td>
  </tr>
  <tr>
    <td align="center">{End}</td>
    <td>메인 엔드 키</td>
  </tr>
  <tr>
    <td align="center">{PgUp}</td>
    <td>메인 페이지 업 키</td>
  </tr>
  <tr>
    <td align="center">{PgDn}</td>
    <td>메인 페이지 다운 키</td>
  </tr>
  <tr>
    <th>&nbsp;</th>
    <th>&nbsp;</th>
  </tr>
  <tr>
    <td align="center">{CapsLock}</td>
    <td>CapsLock (Win 2k/XP이라면 <a href="SetNumScrollCapsLockState.htm">SetCapsLockState</a>을 사용하는 편이 더 신뢰성이 높습니다).


 {CapsLock}를 전송하려면 미리 <a href="SetStoreCapslockMode.htm">SetStoreCapslockMode Off</a>이 되어 있어야 합니다.</td>
  </tr>
  <tr>
    <td align="center">{ScrollLock}</td>
    <td>ScrollLock (다음도 참조: <a href="SetNumScrollCapsLockState.htm">SetScrollLockState</a>)</td>
  </tr>
  <tr>
    <td align="center">{NumLock}</td>
    <td>NumLock (다음도 참조: <a href="SetNumScrollCapsLockState.htm">SetNumLockState</a>)</td>
  </tr>
  <tr>
    <th>&nbsp;</th>
    <th>&nbsp;</th>
  </tr>
  <tr>
    <td align="center">{Control} 또는 {Ctrl}</td>
    <td>CONTROL (기술 정보: 좌우 구분 없는 가상 키를 보내지만 스캔 코드는 왼쪽을 전송함)</td>
  </tr>
  <tr>
    <td align="center">{LControl} 또는 {LCtrl}</td>
    <td>왼쪽 CONTROL 키 (기술 정보: 좌우 구분 없는 가상 키가 아니라 왼쪽 가상 키를 전송함)</td>
  </tr>
  <tr>
    <td align="center">{RControl} 또는 {RCtrl}</td>
    <td>오른쪽 CONTROL 키</td>
  </tr>
  <tr>
    <td align="center">{Control Down} 또는 {Ctrl Down}</td>
    <td>{Ctrl Up}이 전송될 때까지 CONTROL 키를 누릅니다. 대신에 왼쪽 또는 오른쪽 키를 누르고 있으려면, {RCtrl Down}과 {RCtrl Up}을 사용하십시오.</td>
  </tr>
  <tr>
    <th>&nbsp;</th>
    <th>&nbsp;</th>
  </tr>
  <tr>
    <td align="center">{Alt}</td>
    <td>ALT (기술 정보: 좌우 구분없는 가상 키를 전송하지만 스캔 코드는 왼쪽 스캔코드를 전송함)</td>
  </tr>
  <tr>
    <td align="center">{LAlt}</td>
    <td>왼쪽 ALT 키 (기술 정보: 좌우 구분없는 가상 키가 아니라 왼쪽 가상 키를 전송합니다)</td>
  </tr>
  <tr>
    <td align="center">{RAlt}</td>
    <td>오른쪽 ALT 키 (또는 키보드 레이아웃에 따라 AltGr)</td>
  </tr>
  <tr>
    <td align="center">{Alt Down}</td>
    <td>{Alt Up}이 전송될 때까지 ALT 키를 누릅니다. 대신에 왼쪽 또는 오른쪽 키를 누르고 있으려면 {RAlt Down}과 {RAlt Up}을 사용하십시오.</td>
  </tr>
  <tr>
    <th>&nbsp;</th>
    <th>&nbsp;</th>
  </tr>
  <tr>
    <td align="center">{Shift}</td>
    <td>SHIFT (기술 정보: 좌우 구분없는 가상 키를 전송하지만 스캔코드는 왼쪽 스캔코드를 전송함)</td>
  </tr>
  <tr>
    <td align="center">{LShift}</td>
    <td>왼쪽 SHIFT 키 (기술 정보: 좌우 구분 없는 가상 키가 아니라 왼쪽 가상 키를 전송함)</td>
  </tr>
  <tr>
    <td align="center">{RShift}</td>
    <td>오른쪽 SHIFT 키</td>
  </tr>
  <tr>
    <td align="center">{Shift Down}</td>
    <td>{Shift Up}이 전송될 때까지 SHIFT 키를 누릅니다. 대신에 왼쪽 또는 오른쪽 키를 누르고 있으려면 {RShift Down}과 {RShift Up}을 사용하십시오.</td>
  </tr>
  <tr>
    <th>&nbsp;</th>
    <th>&nbsp;</th>
  </tr>
  <tr>
    <td align="center">{LWin}</td>
    <td>왼쪽 Windows 키</td>
  </tr>
  <tr>
    <td align="center">{RWin}</td>
    <td>오른쪽 Windows 키</td>
  </tr>
  <tr>
    <td align="center">{LWin Down}</td>
    <td>{LWin Up}이 전송될 때까지 왼쪽 Windows 키를 누릅니다</td>
  </tr>
  <tr>
    <td align="center">{RWin Down}</td>
    <td>{RWin Up}이 전송될 때까지 오른쪽 Windows 키를 누릅니다</td>
  </tr>
  <tr>
    <th>&nbsp;</th>
    <th>&nbsp;</th>
  </tr>
  <tr>
    <td align="center">{AppsKey}</td>
    <td>Windows App 키 (오른쪽 클릭 또는 문맥 메뉴를 요청합니다)</td>
  </tr>
  <tr>
    <td align="center">{Sleep}</td>
    <td>컴퓨터 SLEEP 키.</td>
  </tr>
  <tr>
    <td align="center">{ASC nnnnn}</td>
    <td><p><a name="asc"></a>ALT+nnnnn 키패드 조합을 전송합니다. 이를 이용하여 키보드에 존재하지 않는 특수 문자들을 발생시킬 수 있습니다. ASCII 문자들을 발생시키려면, 1부터 255 사이의 숫자를 지정하십시오. (대부분의 언어에 표준인) ANSI 문자를 발생시키려면, 128부터 255 사이의 숫자를 지정하되, 앞에 0을 덧붙이십시오. 예, {Asc 0133}.</p>
    <p>유니코드 문자는 256부터 65535 사이의 숫자를 지정해 발생시킬 수 있습니다 (앞에 0을 붙이지 않음). 그렇지만, 이 방법은 모든 어플리케이션에서 지원되지는 않습니다. 대안은 아래 섹션을 참조하십시오.</p></td>
  </tr>
  <tr id="Unicode">
    <td align="center">{U+nnnn}</td>
    <td><p><a name="sendu"></a><span class="ver">[AHK_L 24+]:</span> 유니코드 문자를 전송합니다. <em>nnnn</em>은 앞에 0을 제외하고 문자의 십육진 값입니다. 유니코드 버전의 오토핫키에서는 자동으로 Send와 ControlSend이 유니코드 텍스트를 지원하기 때문에 이 방법이 필요하지 않습니다.</p>
    <p>문자가 가상 키보드에 짝지어지지 않는다면, <a href="http://msdn.microsoft.com/en-us/library/ms646310.aspx">SendInput()</a> 또는 <a href="http://msdn.microsoft.com/en-us/library/ms646276.aspx">WM_CHAR</a>을 이용해 그 문자를 전송할 수 있습니다. 현재의 Send 모드는 아무 효과가 없습니다.</p></td>
  </tr>
  <tr>
    <td align="center"><p>{vkXX}<br>
      {scYYY}<br>
    {vkXXscYYY}</p></td>
    <td><p><a name="vk"></a>가상 키 XX와 스캔 코드 YYY인 키눌림을 전송합니다. 예를 들어: <code>Send {vkFFsc159}</code>. sc 또는 vk 부분을 생략하면, 그 자리에 가장 적절한 값이 전송됩니다.</p>
      <p>XX와 YYY에 대한 값들은 십육진수이고 보통 메인 창이 <a href="KeyHistory.htm">View-&gt;Key history</a> 메뉴 항목을 통하여 알아낼 수 있습니다. 다음도 참조: <a href="../KeyList.htm#SpecialKeys">특수 키</a></p></td>
  </tr>
  <tr>
    <th>&nbsp;</th>
    <th>&nbsp;</th>
  </tr>
  <tr>
    <td align="center">{Numpad0} - {Numpad9}</td>
    <td>넘패드 숫자 키 (Numlock을 켜면 보임). 예를 들어: {Numpad5}는 숫자 5입니다.</td>
  </tr>
  <tr>
    <td align="center">{NumpadDot}</td>
    <td>넘패드 점 (Numlock을 켜면 보임).</td>
  </tr>
  <tr>
    <td align="center">{NumpadEnter}</td>
    <td>키패드의 엔터 키</td>
  </tr>
  <tr>
    <td align="center">{NumpadMult}</td>
    <td>넘패드 곱셈 키</td>
  </tr>
  <tr>
    <td align="center">{NumpadDiv}</td>
    <td>넘패드 나눗셈 키</td>
  </tr>
  <tr>
    <td align="center">{NumpadAdd}</td>
    <td>넘패드 덧셈 키</td>
  </tr>
  <tr>
    <td align="center">{NumpadSub}</td>
    <td>넘패드 뺄셈 키</td>
  </tr>
  <tr>
    <th>&nbsp;</th>
    <th>&nbsp;</th>
  </tr>
  <tr>
    <td align="center">{NumpadDel}</td>
    <td>키패드의 삭제 키 (이 키와 아래의 넘패드 키들은 Numlock이 꺼져 있을 때 사용됩니다)</td>
  </tr>
  <tr>
    <td align="center">{NumpadIns}</td>
    <td>키패드의 삽입 키</td>
  </tr>
  <tr>
    <td align="center">{NumpadClear}</td>
    <td>키패드의 소거 키 (보통 Numlock이 꺼져 있을 때 '5' 키).</td>
  </tr>
  <tr>
    <td align="center">{NumpadUp}</td>
    <td>키패드의 위 화살표 키</td>
  </tr>
  <tr>
    <td align="center">{NumpadDown}</td>
    <td>키패드의 아래 화살표 키</td>
  </tr>
  <tr>
    <td align="center">{NumpadLeft}</td>
    <td>키패드의 왼쪽 화살표 키</td>
  </tr>
  <tr>
    <td align="center">{NumpadRight}</td>
    <td>키패드의 오른쪽 화살표 키</td>
  </tr>
  <tr>
    <td align="center">{NumpadHome}</td>
    <td>키패드의 홈 키</td>
  </tr>
  <tr>
    <td align="center">{NumpadEnd}</td>
    <td>키패드의 엔드 키</td>
  </tr>
  <tr>
    <td align="center">{NumpadPgUp}</td>
    <td>키패드의 페이지-업 키</td>
  </tr>
  <tr>
    <td align="center">{NumpadPgDn}</td>
    <td>키패드의 페이지-다운 키</td>
  </tr>
  <tr>
    <th>&nbsp;</th>
    <th>&nbsp;</th>
  </tr>
  <tr>
    <td align="center">{Browser_Back}</td>
    <td>브라우저의 &quot;back&quot; 버튼</td>
  </tr>
  <tr>
    <td align="center">{Browser_Forward}</td>
    <td>브라우저의 &quot;forward&quot; 버튼</td>
  </tr>
  <tr>
    <td align="center">{Browser_Refresh}</td>
    <td>브라우저의 &quot;refresh&quot; 버튼</td>
  </tr>
  <tr>
    <td align="center">{Browser_Stop}</td>
    <td>브라우저의 &quot;stop&quot; 버튼</td>
  </tr>
  <tr>
    <td align="center">{Browser_Search}</td>
    <td>브라우저의 &quot;search&quot; 버튼</td>
  </tr>
  <tr>
    <td align="center">{Browser_Favorites}</td>
    <td>브라우저의 &quot;favorites&quot; 버튼</td>
  </tr>
  <tr>
    <td align="center">{Browser_Home}</td>
    <td>브라우저를 기동하고 홈페이지로 갑니다</td>
  </tr>
  <tr>
    <td align="center">{Volume_Mute}</td>
    <td>마스터 볼륨 음소거. 보통 <code><a href="SoundSet.htm">SoundSet</a>, +1, , mute</code>와 동등함.</td>
  </tr>
  <tr>
    <td align="center">{Volume_Down}</td>
    <td>마스터 볼륨을 줄입니다. 보통 <code><a href="SoundSet.htm">SoundSet</a> -5</code>와 동등.</td>
  </tr>
  <tr>
    <td align="center">{Volume_Up}</td>
    <td>마스터 볼륨을 높입니다. 보통 <code><a href="SoundSet.htm">SoundSet</a> +5</code>와 동등함.</td>
  </tr>
  <tr>
    <td align="center">{Media_Next}</td>
    <td>미디어 플레이어에서 다음 트랙으로</td>
  </tr>
  <tr>
    <td align="center">{Media_Prev}</td>
    <td>미디어 플레이어에서 이전 트랙으로</td>
  </tr>
  <tr>
    <td align="center">{Media_Stop}</td>
    <td>미디어 플레이어 중지</td>
  </tr>
  <tr>
    <td align="center">{Media_Play_Pause}</td>
    <td>미디어 플레이어 정지/연주</td>
  </tr>
  <tr>
    <td align="center">{Launch_Mail}</td>
    <td>이메일 어플리케이션 기동</td>
  </tr>
  <tr>
    <td align="center">{Launch_Media}</td>
    <td>미디어 플레이어 기동</td>
  </tr>
  <tr>
    <td align="center">{Launch_App1}</td>
    <td>사용자 app1 기동</td>
  </tr>
  <tr>
    <td align="center">{Launch_App2}</td>
    <td>사용자 app2 기동</td>
  </tr>
  <tr>
    <th>&nbsp;</th>
    <th>&nbsp;</th>
  </tr>
  <tr>
    <td align="center">{PrintScreen}</td>
    <td>화면 인쇄</td>
  </tr>
  <tr>
    <td align="center">{CtrlBreak}</td>
    <td>Ctrl+break</td>
  </tr>
  <tr>
    <td align="center">{Pause}</td>
    <td>정지</td>
  </tr>
  <tr>
    <th>&nbsp;</th>
    <th>&nbsp;</th>
  </tr>
  <tr>
    <td align="center"><strong>{Click [Options]}</strong><br>
    <span class="ver">[v1.0.43+]</span></td>
    <td><a name="Click"></a><a href="Click.htm">Click 명령어</a>와 같은 옵션을 사용하여 마우스 클릭을 전송합니다. 예를 들어, <code>{Click}</code>은 마우스 커서의 현재 위치에 왼 마우스 버튼을 한 번 클릭합니다. 그리고 <code>{Click 100, 200}</code>는 좌표 100, 200에 클릭합니다 (<a href="CoordMode.htm">CoordMode</a>에 기반). 클릭 없이 마우스를 이동시키려면, 좌표 다음에 0을 지정하십시오; 예를 들어: <code>{Click 100, 200, 0}</code>. 마우스 클릭 사이의 지연 시간은  <a href="SetMouseDelay.htm">SetMouseDelay</a>로 결정됩니다 (<a href="SetKeyDelay.htm">SetKeyDelay</a>로 결정되지 않습니다).</td>
  </tr>
  <tr>
    <td align="center">{WheelDown}, {WheelUp}, {WheelLeft}, {WheelRight}, {LButton}, {RButton}, {MButton}, {XButton1}, {XButton2}</td>
    <td>커서의 현재 위치에 마우스 버튼 이벤트를 전송합니다 (위치와 기타 옵션에 관하여 통제하려면, 위의 <a href="Click.htm">{Click}</a>을 사용하십시오). 마우스 클릭 사이의 지연 시간은 <a href="SetMouseDelay.htm">SetMouseDelay</a>으로 결정됩니다. WheelLeft/Right는 v1.0.48+을 요구하지만, Windows Vista 미만의 운영 체제에서는 아무 효과가 없습니다.</td>
  </tr>
  <tr>
    <td align="center"><strong>{Blind}</strong></td>
    <td><p><a name="blind"></a>문자열에서 {Blind}가 첫 항목이면, 프로그램은 Alt/Control/Shift/Win 키가 눌린 상태에서 시작했을 경우 떼려고 하지 않습니다. 예를 들어, 핫키 <code>+s::Send {Blind}abc</code>는 abc가 아니라 ABC를 전송합니다. 왜냐하면 사용자가 Shift 키를 누르고 있기 때문입니다.</p>
      <p>{Blind}는 또한 <a href="SetStoreCapslockMode.htm">SetStoreCapslockMode</a>를 무시합니다; 즉, Capslock의 상태가 바뀌지 않습니다. 마지막으로, {Blind}는 추가 Control 키눌림을 생략합니다; 그러므로: 1) LWin/RWin 키를 눌러도 시작 메뉴가 촉발되지 않습니다; 2) Alt 키를 눌러도 메뉴 바가 활성화되지 않습니다.</p>
      <p>맹목-모드는 <a href="../misc/Remap.htm">키를 리맵핑할 때</a> 내부적으로 사용됩니다. 예를 들어, 리맵핑 <code>a::b</code>는: 1) &quot;a&quot;를 타자하면 &quot;b&quot;를 생산하고; 2) 대문자 A를 타자하면 대문자 B를 생산하며 ; 그리고 3) Control-A를 타자하면 Control-B를 생산합니다.</p>
      <p>{Blind}는 SendRaw과 <a href="ControlSend.htm">ControlSendRaw</a>가 지원하지 않습니다. 게다가, <a href="#SendPlayDetail">SendPlay</a>도 완벽하게는 지원하지 못합니다. 특히 수식 키들을 다룰 때 (Control, Alt, Shift, 그리고 Win) 지원하지 못합니다.</p></td>
  </tr>
  <tr>
    <td align="center"><strong>{Raw}</strong><br>
    <span class="ver">[v1.0.43+]</span></td>
    <td><a name="Raw" id="Raw"></a>키눌림을 보이는 그대로 전송합니다. {Enter}를 ENTER 키눌림으로 변환하지 않고, <code>^c</code>를 Control-C로 변환하지 않습니다, 등등. 문자열 {Raw}는 문자열의 시작부터 일어날 필요는 없지만, 일단 지정되면, 문자열의 나머지에 효과를 유지합니다.</td>
  </tr>
</table>

<h2>키를 반복하기 또는 키를 누르고 있기</h2>
<p>
<strong>키를 반복하려면</strong>: 키의 이름에 활괄호를 두르고 다음에 반복할 횟수를 지정합니다. 예를 들어:</p>
<pre>Send {DEL 4}  <em>; Delete 키를 4 번 누릅니다.</em>
Send {S 30}   <em>; 대문자 S를 30개 전송합니다.</em>
Send +{TAB 4}  <em>; Shift-Tab을 4 번 누릅니다.</em></pre>
<p>
<strong>키를 누르고 있거나 떼기</strong>: 키의 이름을 활괄호로 둘러싸고 다음에 단어 <strong>Down</strong> 또는 <strong>Up</strong>을 지정합니다. 예를 들어:</p>
<pre>Send {b down}{b up}
Send {TAB down}{TAB up}
Send {Up down}  <em>; 위 화살표 키를 누릅니다.</em>
Sleep 1000  <em>; 1초 동안 누르고 있습니다.</em>
Send {Up up}  <em>; 위 화살표 키를 뗍니다.</em></pre>
<p>
키가 위의 방법을 통하여 눌릴 때, 자동 반복을 시작하지 않습니다. 반면에 물리적으로 키를 누르고 있으면 자동 반복을 시작합니다 (이것은 자동-반복이 드라이버/하드웨어의 특징이기 때문입니다). 그렇지만, <a href="Loop.htm">Loop</a>를 사용하면 자동 반복을 흉내낼 수 있습니다. 다음 예제는 20 개의 탭 키눌림을 전송합니다:</p>
<pre>Loop 20
{
    Send {Tab down}  <em>; 자동-반복은 연속적인 누르기 이벤트로 구성됩니다 (업-이벤트 없음).</em>
    Sleep 30  <em>; 키 눌림 사이에 대기하는 밀리 초 (또는 <a href="SetKeyDelay.htm">SetKeyDelay</a>를 사용하십시오).</em>
}
Send {Tab up}  <em>; 키를 뗍니다.</em></pre>
<p>
단어 <em>DownTemp</em>도 사용할 수 있습니다. 그의 효과는 수식 (Control/Shift/Alt/Win) 키를 제외하고 <em>Down</em>과 똑 같습니다. 

그런 경우, <em>DownTemp</em>는 연이은 전송에 키가 영구히 눌려 있는 것은 아니며, 그러므로 키눌림이 요구하면 언제든지 떼어도 좋다고 알려줍니다. 예를 들어, <code>Send {Control DownTemp}</code> 다음에 <code>Send a</code>가 따라오면 보통의 &quot;a&quot; 키눌림을 생산하며, control-A 키눌림을 생산하지 않습니다.</p>

<h2 id="Remarks">총평</h2>
<p>
Send 명령어가 지원하는 문자에 특별한 제한은 없습니다. 문자가 현재 키보드 레이아웃에 존재하지 않으면, 오토핫키 버전에 따라  유니코드 문자 패킷 또는 <a href="#asc">Alt+nnnnn</a> 조합을 전송해 흉내낼 수 있습니다. 유니코드 문자는 텍스트로 유니코드 버전의 오토핫키에서 직접적으로 지원합니다. 또는 다른 버전이라면 <a href="#sendu">{U+nnnn} 표기법</a>을 사용하면 됩니다.</p>
<p>
<strong>SendInput/SendPlay와 비교한 BlockInput</strong>: <a href="BlockInput.htm">BlockInput</a> 명령어는 사용자가 물리적으로 타자하는 키 눌림이 흉내낸 키눌림에 방해를 받지 않도록 막아 주지만, 종종 <a href="#SendInputDetail">SendInput</a>이나 <a href="#SendPlayDetail">SendPlay</a>를 사용하면 더 좋은 경우가 있습니다. 키눌림과 마우스 클릭이 인터럽트가 불가능합니다. BlockInput과 다르게, SendInput/Play 는 전송하는 동안 사용자가 타자한 키들을 버리지 않습니다; 대신, 그런 키들은 버퍼 처리되었다가 나중에 전송됩니다.</p>
<p>
엄청나게 많은 키눌림을 전송할 경우, <a href="../Scripts.htm#continuation">계속 섹션</a>을 사용하면 가독성과 유지관리성을 개선할 수 있습니다.</p>
<p>
운영 체제는 CTRL-ALT-DELETE 조합을 허용하지 않기 때문에, <code>Send ^!{Delete}</code>와 같이 하더라도 아무 효과가 없습니다.</p>
<p>
<b>Send는 아무 효과가 없을 수 있습니다</b> Windows Vista 이후 활성 창이 관리자 권한으로 실행중인데 스크립트는 관리자 권한이 없으면 그렇습니다. 이것은 사용자 인터페이스 권한 격리(User Interface Privilege Isolation) 보안 매커니즘 때문입니다.</p>

<h2 id="SendInputDetail">SendInput <span class="ver">[v1.0.43+]</span></h2>
<p>
SendInput은 일반적으로 키눌림과 마우스 클릭을 전송하는 데 선호되는 방법입니다. 왜냐하면 속도가 월등하고 신뢰성이 있기 때문입니다. 대부분의 상황에서, SendInput은 거의 즉시 실행됩니다. 기다란 문자열을 보내도 순식간입니다. SendInput은 빠르기 때문에, 더 신뢰성이 있습니다. 왜냐하면 다른 창이 의도치 않게 나타나거나 키눌림을 가로 채는 빈도가 줄어들기 때문입니다. SendInput 동안에 사용자가 타자하면 연기되었다가 나중에 처리되므로 신뢰성은 더욱 개선됩니다.</p>
<p>
다른 전송 모드와 다르게, 운영 체제는 SendInput을 대략 5000 문자로 제한합니다 (이 값은 운영 체제의 버전과 수행성능 설정에 따라 달라집니다). 이 제한을 넘어서 문자들과 이벤트들은 전송되지 않습니다.</p>
<p>
<strong>주의:</strong> SendInput은 SetKeyDelay를 무시합니다. 왜냐하면 운영 체제가 이 모드에서는 지연 시간을 지원하지 않기 때문입니다. 그렇지만, 아래에 기술한 상황 아래에서 SendInput은 <a href="#SendEvent">SendEvent</a>에 의존합니다. SendEvent는 <code><a href="SetKeyDelay.htm">SetKeyDelay -1, 0</a></code>를 사용합니다 

(단, SendEvent의 키 지연시간이(KeyDelay) <code>-1,-1</code>인 경우는 예외입니다. 이 경우는 <code>-1,-1</code>이 사용됩니다). 

SendInput이 <a href="#SendPlayDetail">SendPlay</a>에 의존할 때, SendPlay의 키 지연시간(KeyDelay)을 사용합니다.</p>
<p>
<a name="SendInputUnavail"></a>SendInput을 실행하는 스크립트에 <a href="_InstallKeybdHook.htm">저-수준 키보드 갈고리</a>가 설치되어 있다면, SendInput은 자동으로 <a href="#SendEvent">SendEvent</a>에 의존합니다 (아니면 <a href="SendMode.htm"><code>SendMode InputThenPlay</code></a>가 켜져 있을 경우라면 <a href="#SendPlayDetail">SendPlay</a>에 의존합니다). 외부 갈고리의 존재 때문에 SendInput의 모든 장점이 가려집니다. 그 때문에 SendPlay와 SendEvent에 비해 열등합니다. 그렇지만, SendInput은 AutoHotkey v1.0.43+이 아니라면 저-수준 갈고리를 탐지할 수 없기 때문에, 이런 경우는 의존할 것이 없으므로 SendPlay/Event 보다 신뢰성이 더 떨어집니다.</p>
<p>
SendInput이 <a href="#Click">{Click}</a>와 같은 수단을 통하여 마우스 클릭을 전송할 때 그리고 <a href="SetMouseDelay.htm"><code>CoordMode Mouse, Relative</code></a>가 켜져 있을 때 (기본값), 모든 클릭은 전송이 시작될 때 활성화 된 창에 상대적입니다. 그러므로, SendInput이 의도적으로 (알트-탭 같은 수단으로) 또다른 창을 활성화하면, 같은 명령어 안에서 연이은 클릭의 좌표들은 오류가 일어납니다. 왜냐하면 여전히 새 창이 아니라 예전 창에 상대적이기 때문입니다.</p>

<h2 id="SendPlayDetail">SendPlay <span class="ver">[v1.0.43+]</span></h2>
<p>
SendPlay의 가장 큰 장점은 다른 모드와 다르게 광범위한 게임에서 마우스 클릭과 키눌림을 &quot;재시연&quot;할 수 있다는 것입니다. 예를 들어, 특정한 게임은 오직 <a href="../Hotstrings.htm#SendMode">SendPlay 옵션이</a>이 있을 경우에만 <a href="../Hotstrings.htm#SendMode">핫스트링</a>을 받아 들입니다. 그렇지만, SendPlay는 Windows Vista 이후에서 사용자 계정 통제(User Account Control)가 켜져 있으면, 아무 효과가 없습니다. 스크립트가 사용자 권한으로 실행되어도 마찬가지입니다. 다음 스크립트는 이 문제의 우회책을 제공합니다: <a href="http://www.autohotkey.com/forum/topic75595.html">http://www.autohotkey.com/forum/topic75595.html</a>.</p>
<p>
세 가지 전송 모드 중에서, SendPlay가 가장 이상합니다. 왜냐하면 키눌림과 마우스 클릭을 사실상 흉내내지 않기 때문입니다. 대신에, 일련의 이벤트 (메시지)를 만들어 냅니다. 그 메시지들이 활성 창으로 직접 흘러 들어갑니다 (<a href="ControlSend.htm">ControlSend</a>와 비슷하게, 그러나 낮은 수준에서). 결과적으로, SendPlay는 핫키나 핫트링을 촉발시키지 않습니다.</p>
<p>
<a href="#SendInputDetail">SendInput</a>처럼, SendPlay의 키눌림은 사용자가 타자한 키눌림 때문에 흩어지지 않습니다. 그래서, 사용자가 어쩌다가 SendPlay 중에 타자를 하더라도, 그런 키눌림은 연기되었다가 나중에 처리됩니다.</p>
<p>
SendPlay는 SendInput에 비해 상당히 느립니다. 그러나 보통  전통적인 <a href="#SendEvent">SendEvent</a> 모드 보다는 빠릅니다 (<a href="SetKeyDelay.htm">KeyDelay</a>가 -1일 경우에도 마찬가지입니다).</p>
<p>
Windows 키 (LWin 그리고 RWin)는  <a href="_InstallKeybdHook.htm">키보드 갈고리</a>가 설치되어 있으면 SendPlay 동안 자동으로 막힙니다. 이 덕분에 전송하는 동안에 사용자가 우발적으로 Windows 키를 눌러도 시작 메뉴가 나타나지 않습니다. 대조적으로, LWin와 RWin 말고 다른 키들은 막아줄 필요가 있습니다. 왜냐하면 운영 체제가 자동으로 키들을 (버퍼 처리하여) SendPlay가 끝날 때까지 연기해 주기 때문입니다.</p>
<p>
SendPlay는 SetKeyDelay와 SetMouseDelay의 표준 설정을 사용하지 않습니다. 대신에, 기본값으로 전혀 대기 시간이 없습니다. 이 대기 시간은 다음 예제와 같이 바꿀 수 있습니다:</p>

<pre><a href="SetKeyDelay.htm">SetKeyDelay</a>, 0, 10, <strong>Play</strong>  <em>; SendPlay 모드에서는 0과 -1이 같음을 주목하십시오.</em>
<a href="SetMouseDelay.htm">SetMouseDelay</a>, 10, <strong>Play</strong></pre>
<p>
SendPlay는 Capslock, Numlock, 또는 Scroll-lock 키를 켜고 끌 수 없습니다. 비슷하게, <a href="GetKeyState.htm">GetKeyState</a>로 보이는 키의 상태를 바꿀 수 없습니다.
단, 그 키눌림들이 스크립트의 창 중에 하나로 전송된다면 예외입니다. 그 때까지, 왼쪽/오른쪽 수식키에 변화가 있다면 (예, RControl) 오직 좌우 구분 없는 수식키를 통해서만 탐지할 수 있습니다 (예, Control). 또, SendPlay는 <a href="SendMode.htm#Play">SendMode 페이지</a>에 기술된 다른 제한도 있습니다.</p>
<p>
<a href="#SendInputDetail">SendInput</a> 그리고 <a href="#SendEvent">SendEvent</a>과 다르게, 사용자는 Control-Alt-Del이나 Control-Escape를 눌러서 SendPlay를 인터럽트할 수 있습니다. 이런 일이 일어날 때, 나머지 키눌림은 전송되지 않지만 스크립트른 마치 SendPlay가 정상적으로 전송을 완료한 것처럼 실행을 계속합니다.</p>
<p>
SendPlay는 send LWin과 RWin 이벤트를 보낼 수 있지만, 창에 직접적으로 전송합니다. 운영 체제 고유의 기능을 수행하지 않습니다. 이를 우회하려면 <a href="#SendEvent">SendEvent</a>를 사용하십시오. 예를 들어, <code>SendEvent #r</code>는 시작 메뉴의 실행 대화상자를 보여줄 것입니다.</p>

<h2>관련 항목</h2>
<p>
<a href="SendMode.htm">SendMode</a>, <a href="SetKeyDelay.htm">SetKeyDelay</a>, <a href="SetStoreCapslockMode.htm">SetStoreCapslockMode</a>, <a href="_EscapeChar.htm">피신 연속열 (예, `%)</a>, <a href="ControlSend.htm">ControlSend</a>, <a href="BlockInput.htm">BlockInput</a>, <a href="../Hotstrings.htm">핫스트링</a>, <a href="WinActivate.htm">WinActivate</a></p>

<h2>예제</h2>
<pre class="NoIndent">Send Sincerely,{enter}John Smith  <em>; 두 줄의 서명을 타자합니다.</em>
Send !fs <em>; File-&gt;Save 메뉴를 선택합니다 (Alt+F를 누른 다음 S).</em>
Send {End}+{Left 4} <em>; 텍스트 끝으로 점프해서 네 개의 shift+left-arrow 키눌림을 전송합니다.</em>
SendInput <a href="#Raw">{Raw}</a>기다란 날 문자열들이 빠른 방법을 사용하여 전송됨 (<a href="#SendInputDetail">SendInput</a>).</pre>

</body>
</html>
