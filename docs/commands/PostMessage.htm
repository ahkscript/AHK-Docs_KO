<html>
<head>
<title>PostMessage / SendMessage</title>
<meta name="description" content="Send messages to a window with this free macro program. PostMessage puts a message in the window's message queue, but SendMessage waits for a reply.">
<meta http-equiv="Content-Type" content="text/html; charset=euc-kr">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<link href="../static/theme.css" rel="stylesheet" type="text/css" />
<script src="../static/content.js" type="text/javascript"></script>
</head>
<body>

<h1>PostMessage / SendMessage</h1>

<p> 메시지를 창이나 콘트롤에 보냅니다 (SendMessage는 승인을 기다립니다).</p>

<pre class="Syntax">PostMessage, Msg [, wParam, lParam, Control, WinTitle, WinText, ExcludeTitle, ExcludeText]
SendMessage, Msg [, wParam, lParam, Control, WinTitle, WinText, ExcludeTitle, ExcludeText, Timeout]</pre>
<h3>매개변수</h3>
<dl>

  <dt>Msg</dt>
  <dd><p>전송할 메시지 번호, <a href="../Variables.htm#Expressions">표현식</a>가능. 숫자를 알아 내려면 <a href="../misc/SendMessageList.htm">메시지 목록</a>을 참조하십시오.</p></dd>

  <dt>wParam</dt>
  <dd><p>메시지의 첫 번째 구성요소. <a href="../Variables.htm#Expressions">표현식</a> 가능. 비어 있거나 생략하면 0이 전송됩니다.</p></dd>

  <dt>lParam</dt>
  <dd><p>메시지의 두 번째 구성요소. <a href="../Variables.htm#Expressions">표현식</a> 가능. 비어 있거나 생략하면 0이 전송됩니다.</p></dd>

  <dt>Control</dt>
  <dd><p>이 매개변수가 비어있거나 생략되면, 메시지는 그의 콘트롤 중에 하나가 아니라 직접 목표 창에 전송됩니다. 그렇지 않으면, 이 매개변수는 ClassNN (클래스이름과 콘트롤의 실체 번호) 또는 콘트롤의 텍스트일 수 있습니다. 둘 모두 Window Spy로 알아낼 수 있습니다. 텍스트를 사용할 때, 부합 행위는 <a href="SetTitleMatchMode.htm">SetTitleMatchMode</a>로 결정됩니다.</p>
    <p>
	콘트롤의 HWND (창 핸들)을 처리하려면, <em>Control</em> 매개변수를 비워 두고 <code>ahk_id %ControlHwnd%</code>를 <em>WinTitle</em> 매개변수에 지정하십시오 (이것은 숨은 창에도 작동합니다. <a href="DetectHiddenWindows.htm">DetectHiddenWindows</a>가 꺼져 있어도(Off) 마찬가지입니다). 콘트롤의 HWND는 전형적으로 <a href="ControlGet.htm#Hwnd">ControlGet Hwnd</a>, <a href="MouseGetPos.htm">MouseGetPos</a>, 또는 <a href="DllCall.htm">DllCall</a>를 통하여 열람합니다.</p>
    </dd>

  <dt>WinTitle</dt>
  <dd><p>목표 창을 식별하는 창 제목 또는 기타 기준. <a href="../misc/WinTitle.htm">WinTitle</a> 참조.</p></dd>

  <dt>WinText</dt>
  <dd><p>존재하면, 이 매개변수는 목표 창 텍스트의 부문자열입니다 (Window Spy에 노출). 숨은 텍스트는  <a href="DetectHiddenText.htm">DetectHiddenText</a>가 켜져 있어야(ON) 탐지됩니다.</p></dd>

  <dt>ExcludeTitle</dt>
  <dd><p>제목에 이 값이 있는 창은 무시합니다.</p></dd>

  <dt>ExcludeText</dt>
  <dd><p>텍스트에 이 값이 있는 창은 무시합니다.</p></dd>

  <dt>Timeout</dt>
  <dd><p><span class="ver">[AHK_L 42+]:</span> 목표 창이 메시지를 처리하기를 기다릴 밀리초의 최대 개수. 생략하면 기본값은 5000 (밀리초)입니다. 이 값은 이 매개변수를 지원하지 않았던 예전 버전의 AutoHotkey에서 기본값입니다. 메시지가 이 시간 안에 처리되지 않으면, 명령어는 끝나고 ErrorLevel에 단어 FAIL을 설정합니다. 이 매개변수는 <a href="../Variables.htm#Expressions">표현식</a>일 수 있습니다.</p></dd>

</dl>

<h3>ErrorLevel</h3>
<p>
<span class="ver">[v1.1.04+]</span> 이 명령어는 실패시 예외를 던질 수 있습니다. 더 자세한 정보는 <a href="Catch.htm#RuntimeErrors">실행시간 에러</a>를 참조하십시오.</p>
<p>
PostMessage: <a href="../misc/ErrorLevel.htm">ErrorLevel</a>은 문제가 있었으면 1이 설정됩니다. 예를 들어 목표 창이나 콘트롤이 존재하지 않을 경우에 1이 설정됩니다. 그렇지 않으면 0이 설정됩니다.</p>
<p>SendMessage: <a href="../misc/ErrorLevel.htm">ErrorLevel</a>은 문제가 있었거나 시간제한에 걸리면 단어 FAIL이 설정됩니다. 그렇지 않으면, 메시지의 숫자 값 결과가 설정됩니다. 가끔 이 값이 메시지와 그의 목표 창의 성질에 따라 &quot;reply&quot;일 경우가 있습니다.</p>
<p>
가능한 값의 범위는 오토핫키의 버전과 목표 창에 따라 다릅니다. 32-비트 버전의 오토핫키를 사용하거나, 또는 목표 창이 32-비트이면, 그 결과는 0부터 4294967295 까지의 32-비트 무부호 정수입니다. 64-비트 버전의 오토핫키를 64-비트 창에 사용하면, 그 결과는 -9223372036854775808과 9223372036854775807 까지의 64-비트 부호있는 정수입니다 .</p>
<p>
결과가 32-비트 부호 있는 정수이기를 원한다면 (-2147483648부터 2147483648까지의 값), 다음과 같이 32-비트로 잘라내고 부호있는 값으로 변환할 수 있습니다:</p>

<pre>MsgReply := ErrorLevel &lt;&lt; 32 &gt;&gt; 32</pre>
<p>
이 변환은 AutoHotkey 64-비트에서도 필요할 수가 있습니다. 왜냐하면, 32-비트 창으로부터의 결과는 확장되지 않기 때문입니다. 예를 들어, 32-비트 창으로부터의 결과가  -1이면 어느 오토핫키 버전에서도 0xFFFFFFFF으로 보입니다. 반면에 64-비트 창으로부터의 결과가  -1이면 32비트 버전의 오토핫키에서는 0xFFFFFFFF으로 보이고 64비트 버전에서는 -1로 보입니다.</p>

<h3>논평</h3>
<p>
이 명령어들은 주의해서 사용해야 합니다. 왜냐하면 엉뚱한 창에 메시지를 전송하면 (또는 무효한 메시지를 전송하면) 예상치 못한 행위를 야기하게 되고 심지어 목표 어플리케이션이 충돌을 일으킬 수 있기 때문입니다. 대부분의 어플리케이션은 외부 소스로부터 어떤 유형의 메시지를 받도록 설계되어 있지 않습니다.</p>
<p>
PostMessage는 메시지를 목표 창에 연관된 메시지 큐에 넣습니다. 승인이나 응답을 기다리지 않습니다. 대조적으로, SendMessage는 목표 창이 그 메시지를 처리하기를 시간제한에 걸릴 때까지 기다립니다.</p>
<p>
<em>wParam</em>과 <em>lParam</em> 매개변수는 정수여야 합니다. AutoHotkey 또는 목표 창이 32-비트이면, 오직 아래의 32 비트만 사용됩니다; 즉, 값은 범위가 -2147483648과 4294967295 (0xFFFFFFFF) 사이입니다. 오토핫키와 목표 창이 모두 64-비트이면, <a href="../Variables.htm#cap">오토핫키가 지원하는</a> 어떤 정수도 사용할 수 있습니다. 오토핫키의 모든 정수 값처럼, 접두사가 0x이면 십육진수를 나타냅니다. 예를 들어 0xFF는 255와 동등합니다.</p>
<p>
문자열은 변수의 주소를 지정하면 <em>wParam</em> 또는 <em>lParam</em>을 통하여 전송할 수 있습니다. 다음 예제는 <a href="../Variables.htm#amp">주소 연산자 (&amp;)</a>를 사용해 전송합니다:</p>

<pre>SendMessage, 0xC, 0, <strong>&amp;MyVar</strong>, ClassNN, WinTitle  <em>; 0XC is WM_SETTEXT</em></pre>
<p>
v1.0.43.06+에서, 메시지 수신자에 의하여 MyVar 안에 배정된 문자열은 별도의 추가 절차 없이 적절하게 인지됩니다. 그렇지만, 이것은 매개변수의 첫 문자가 앰퍼센드 (&amp;)일 경우에만 작동합니다; 예를 들어, <code>5+&amp;MyVar</code>는 작동하지 않지만 <code>&amp;MyVar</code> 또는 <code>&amp;MyVar+5</code>는 작동합니다.</p>
<p>
인용부호 처리된/기호 그대로의 문자열도 다음 예제와 같이 전송할 수 있습니다 (&amp; 연산자는 이 경우 사용하면 안 됩니다):</p>

<pre>Run Notepad
WinWait Untitled - Notepad
SendMessage, 0xC, 0, <strong>&quot;New Notepad Title&quot;</strong>  <em>; 0XC is WM_SETTEXT</em></pre>
<p>
메시지 하나를 숨어 있든 비활성화되어 있든 시스템에 있는 모든 창에 보내려면, <code>ahk_id 0xFFFF</code>를 <em>WinTitle</em> (0xFFFF는 HWND_BROADCAST임)에 지정하십시오. 이 테크닉은 다음 예제와 같이 방송용 의도의 메시지에만 사용해야 합니다:</p>

<pre>SendMessage, 0x1A,,,, ahk_id 0xFFFF  <em>; 0x1A is WM_SETTINGCHANGE</em></pre>
<p>
스크립트가 메시지를 받도록 하려면 <a href="OnMessage.htm">OnMessage()</a>를 사용하십시오.</p>
<p>
이 명령어드들을 사용하는 방법에 관한 소개는 <a href="../misc/SendMessage.htm">메시지 자습서</a>를 참조하십시오.</p>
<p>
창 제목과 텍스트는 대소문자를 구분합니다. 숨은 창은 <a href="DetectHiddenWindows.htm">DetectHiddenWindows</a>가 켜져 있어야 탐지됩니다.</p>

<h3>관련 항목</h3>
<p><a href="../misc/SendMessageList.htm">Message List</a>, <a href="../misc/SendMessage.htm">Message Tutorial</a>, <a href="OnMessage.htm">OnMessage()</a>, <a href="../misc/Winamp.htm">Automating Winamp</a>, <a href="DllCall.htm">DllCall</a>, <a href="ControlSend.htm">ControlSend</a>, <a href="WinMenuSelectItem.htm">WinMenuSelectItem</a></p>

<h3 id="Examples">예제</h3>
<pre class="NoIndent">#o::  <em>; 모니터를 끌 Win+O 핫키.</em>
Sleep 1000  <em>; 사용자에게 키를 뗄 기회를 줍니다 (키를 떼면 모니터가 다시 깹니다).
; Turn Monitor Off:</em>
SendMessage, 0x112, 0xF170, 2,, Program Manager  <em>; 0x112는 WM_SYSCOMMAND이고, 0xF170는 SC_MONITORPOWER입니다.
; 위에 주목하십시오: 2 대신에 -1을 사용하면 모니터가 켜집니다.
; 2 대신에 1을 사용하면 모니터의 저전력 모드가 켜집니다.</em>
return

<em>; 사용자가 선택한 화면 보호기를 시작합니다:</em>
SendMessage, 0x112, 0xF140, 0,, Program Manager  <em>; 0x112는 WM_SYSCOMMAND이고, 0xF140는 SC_SCREENSAVE입니다.</em>

<em>; 한 줄 위로 감습니다 (수직 스크롤 바가 있는 콘트롤에 대하여):</em>
ControlGetFocus, control, A
SendMessage, 0x115, 0, 0, %control%, A

<em>; 한 줄 아래로 감습니다:</em>
ControlGetFocus, control, A
SendMessage, 0x115, 1, 0, %control%, A

<em>; 활성 창의 키보드 레이아웃/언어를 영어로 전환합니다:</em>
PostMessage, 0x50, 0, 0x4090409,, A  <em>; 0x50은 WM_INPUTLANGCHANGEREQUEST입니다.</em>

<em>; 이 예제는 Winamp에게 현재 활성화되어 있는 트랙 번호를 물어봅니다:</em>
SetTitleMatchMode, 2
SendMessage, 1024, 0, 120, - Winamp
if ErrorLevel &lt;&gt; FAIL
{
    ErrorLevel++  <em>; Winamp의 카운트는 &quot;0&quot;에서 시작합니다. 그래서 1로 조정합니다.</em>
    MsgBox, Track #%ErrorLevel% is active or playing.
}
<em>; 더 자세한 정보는 <a href="../misc/Winamp.htm">Winamp 자동화 하기</a>를 참조하십시오.</em>

<em>; AHK 스크립트의 프로세스 ID를 찾기 위해 (&quot;<a href="WinGet.htm">WinGet PID</a>&quot;에 대한 대안):</em>
SetTitleMatchMode, 2
DetectHiddenWindows, on
SendMessage, 0x44, 0x405, 0, , SomeOtherScript.ahk - AutoHotkey v
MsgBox %ErrorLevel% is the process id.</pre>

</body>
</html>
