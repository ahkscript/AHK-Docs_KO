

<html>
<head>
<title>GUI</title>
<meta http-equiv="Content-Type" content="text/html; charset=euc-kr">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<link href="../static/theme.css" rel="stylesheet" type="text/css" />
<script src="../static/content.js" type="text/javascript"></script>
</head>
<body>

<h1>GUI</h1>

<p>창과 콘트롤을 생성하고 관리합니다. 그런 창은 데이터 엔트리 폼 또는 맞춤 사용자 인터페이스에 사용할 수 있습니다.</p>

<pre class="Syntax">Gui, sub-command [, Param2, Param3, Param4]</pre>
<h2>목차</h2>
<ul>
  <li><a href="#New">New</a>: 새 창을 만듭니다.</li>
  <li><a href="#Add">Add</a>: 텍스트, 버튼, 또는 체크박스 같은 콘트롤을 생성합니다.</li>
  <li><a href="#Show">Show</a>: 창을 보여줍니다. 또한 창을 최대화, 최소화, 또는 이동할 수 있습니다.</li>
  <li><a href="#Submit">Submit</a>: 사용자의 입력을 저장하고 선택적으로 창을 감춥니다.</li>
  <li><a href="#Cancel">Cancel</a> (또는 Hide): 창을 감춥니다.</li>
  <li><a href="#Destroy">Destroy</a>: 창을 삭제합니다.</li>
  <li><a href="#Font">Font</a>: 연이어 생성되는 콘트롤에 대하여 글꼴의 모양, 크기, 스타일, 그리고 색을 설정합니다.</li>
  <li><a href="#Color">Color</a>: 창과 그의 콘트롤에 대하여 배경 색을 설정합니다.</li>
  <li><a href="#Margin">Margin</a>: 콘트롤에 명시적으로 위치가 지정되어 있지 않으면 여백/공간을 설정합니다.</li>
  <li><a href="#Options">창에 대한 옵션과 스타일</a>: 창의 모습과 행위에 대하여 다양한 옵션을 설정합니다.</li>
  <li><a href="#Menu">Menu</a>: 메뉴 바를 추가하거나 제거합니다.</li>
  <li><a href="#Minimize">Minimize / Maximize / Restore</a>: 창에 지시된 연산을 수행합니다.</li>
  <li><a href="#Flash">Flash</a>: 창과 그의 태스크바 버튼을 깜빡입니다.</li>
  <li><a href="#Default">Default</a>: 현재 쓰레드의 기본 GUI 창 이름을 변경합니다.</li>
  <li><a href="#Position">콘트롤의 위치 지정과 크기 변경</a></li>
  <li><a href="#Events">사용자 입력을 저장하고 그에 응답하기</a>: 변수 그리고 g-labels</li>
  <li><a href="#OtherOptions">콘트롤에 대한 옵션과 스타일</a></li>
  <li><a href="#Labels">창 이벤트</a>: <a href="#GuiClose">GuiClose</a> | <a href="#GuiEscape">GuiEscape</a> | <a href="#GuiSize">GuiSize</a> | <a href="#GuiContextMenu">GuiContextMenu</a> | <a href="#GuiDropFiles">GuiDropFiles</a></li>
  <li><a href="#MultiWin">여러 GUI 창 만들기</a></li>
  <li><a href="#DefaultWin">GUI 이벤트, 쓰레드 그리고 서브루틴</a></li>
  <li>기타: <a href="#Navigate">키보드 항해</a> | <a href="#Appear">창의 겉모습</a> | <a href="#GenRemarks">총평</a></li>
  <li><a href="#Examples">예제</a>: GUI 창과 콘트롤을 시연하는 작동하는 스크립트들.</li>
</ul>

<h2 id="New">Gui, New [, Options, Title] <span class="ver">[v1.1.04+]</span></h2>
<p>
창을 만들고 현재 쓰레드에 대하여 <a href="#Default">기본 창</a>으로 설정합니다.</p>
<pre>Gui, New  <em>; 이름 없고 번호 없는 GUI를 새로 하나 만듭니다.</em>
Gui, Name: New  <em>; 새로 GUI를 만듭니다. 같은 이름으로 기존의 GUI가 있으면 제거합니다.</em>
</pre>
<p><strong><em>Options</em></strong> 메인 GUI 명령어가 지원하는 <a href="#Options">옵션</a>을 담을 수 있습니다.</p>
<p><strong><em>Title</em></strong>이 생략되면, 스크립트 파일의 이름이 사용됩니다.</p>
<p>이 명령어는 다음 약점이 따라 옵니다:</p>
<ul>
  <li>대부분의 경우 창은 요구하면 자동으로 생성됩니다. 그래서 보통 <em>Gui New</em>를 호출할 필요가 없습니다.</li>
  <li>새 창을 <em>현재 쓰레드</em>에 대하여 <a href="#Default">기본 창</a>으로 설정할 수 있지만, 비-GUI 쓰레드도 여전히 <a href="#DefaultWin">GUI 번호 1</a>을 기본값으로 설정할 수 있습니다.</li>
  <li>GUI에 이름이 없고 <a href="#Default">기본 GUI</a>가 아니면, 그의 HWND로 식별하여야 합니다. <code><a href="#GuiHwndOutputVar">+Hwnd<i>GuiHwnd</i></a></code> 옵션을 사용하여 새 창의 HWND를 <em>GuiHwnd</em>에 저장할 수 있습니다. <code>Gui, %<i>GuiHwnd</i>%:Default</code>를 사용하면 기본값으로 다른 Gui 명령어들을 그 창에 작동시킬 수 있습니다.</li>
</ul>
<p>긍정적인 면에 관하여:</p>
<ul>
  <li><em>Gui New</em>를 호출하면 스크립트가 기존의 GUI를 변경하는 것이 아니라, 새로 만든다는 것을 확신할 수 있습니다. 또한 코드를 읽는 사람들에게 (또는 미래의 여러분에게) 스크립트의 목적을 더 명료하게 보여줄 수 있습니다.</li>
  <li><em>Gui New</em>는 각 GUI에 대하여 유일한 이름 또는 번호를 고를 필요를 제거합니다. 이는 스크립트가 하나 이상의 GUI를 생성할 필요가 있을 때, 또는 다른 스크립트에 포함될 의도가 있을 때 특히 유용할 수 있습니다.</li>
  <li>GUI가 <a href="#Show">보여질</a> 때가 아니라 생성될 때 창의 제목을 설정하는 것이 종종 더 직관적인 경우가 있습니다.</li>
</ul>

<p>이름이 주어지지 않으면, 다음이 적용됩니다:</p>
<ul>
  <li><a href="#GuiClose"><em>GuiClose</em></a>와 같이 특별한 <a href="#Labels">라벨</a>은 기본적으로 &quot;Gui&quot;를 접두사로 가집니다. 단, 옵션에서 <a href="#PlusLabel">+Label<em>Prefix</em></a>로 오버라이드하는 경우는 예외입니다.</li>
  <li>GUI기 새 쓰레드를 기동할 때, <a href="../Variables.htm#Gui">A_Gui</a>는 이름 대신에 HWND가 담깁니다.</li>
</ul>
<p><strong>주의:</strong> v1.1.08 이전에서, 이 명령어는 이름이 지정되면 기본 Gui를 설정하지 않았습니다.</p>

<h2 id="Add">Gui, Add, ControlType [, Options, Text]</h2>
<p>콘트롤을  GUI 창에 추가합니다 (필요하면, 먼저 GUI 창 자체를 생성합니다).</p>

<p><em>ControlType</em>은 다음 중 하나입니다:</p>
<ul>
  <li><a href="GuiControls.htm#Text">Text</a>, <a href="GuiControls.htm#Edit">Edit</a>, <a href="GuiControls.htm#UpDown">UpDown</a>, <a href="GuiControls.htm#Picture">Picture</a></li>
  <li><a href="GuiControls.htm#Button">Button</a>, <a href="GuiControls.htm#Checkbox">Checkbox</a>, <a href="GuiControls.htm#Radio">Radio</a></li>
  <li><a href="GuiControls.htm#DropDownList">DropDownList</a>, <a href="GuiControls.htm#ComboBox">ComboBox</a></li>
  <li><a href="GuiControls.htm#ListBox">ListBox</a>, <a href="ListView.htm">ListView</a>, <a href="TreeView.htm">TreeView</a></li>
  <li><a href="GuiControls.htm#Link">Link</a>, <a href="GuiControls.htm#Hotkey">Hotkey</a>, <a href="GuiControls.htm#DateTime">DateTime</a>, <a href="GuiControls.htm#MonthCal">MonthCal</a></li>
  <li><a href="GuiControls.htm#Slider">Slider</a>, <a href="GuiControls.htm#Progress">Progress</a></li>
  <li><a href="GuiControls.htm#GroupBox">GroupBox</a>, <a href="GuiControls.htm#Tab">Tab</a>, <a href="GuiControls.htm#StatusBar">StatusBar</a></li>
  <li><a href="GuiControls.htm#ActiveX">ActiveX</a> (예, 인터넷 익스플로러 콘트롤)</li>
  <li><a href="GuiControls.htm#Custom">Custom</a></li>
</ul>
<p>예를 들어:</p>
<pre>Gui, Add, Text,, Please enter your name:
Gui, Add, Edit, vName
Gui, Show</pre>

<h2 id="Show">Gui, Show [, Options, Title]</h2>
<p>
따로 <em>Options</em>에 지정하지 않으면, 이 명령어는 창을 보이게 만들고, (필요하면) 창 크기를 복원하고, <a href="WinActivate.htm">활성화</a> 하며, 그리고 그의 타이틀을 설정합니다. <em>Title</em>이 생략되면, 이전 제목이 유지됩니다 (또는 없으면, 스크립트의 이름이 사용됩니다).</p>
<p>
아래의 X, Y, W, 그리고 H 옵션을 생략하면 창의 이전 크기와 위치를 유지할 수 있습니다. 이전의 위치가 없을 경우, 아래에 언급된 X 또는/그리고 Y 옵션이 없다면 창은 두 차원 중 하나에 또는 둘 모두에 맞게 자동 중앙 정렬됩니다. 이전의 크기가 없을 경우, 창은 내용을 가진 콘트롤의 크기와 위치에 맞게 자동 조절됩니다.</p>
<p>
다음 문자열이 <em>Options</em>에 존재할 수 있습니다 (각 숫자를 십진수로 지정하십시오. 십육진수가 아닙니다):</p>
<p>
<strong>Wn</strong>: <strong>n</strong>에 창의 클라이언트 구역의 너비 (픽셀 단위)를 지정합니다 (클라이언트 구역에서 창의 테두리, 제목 바, 그리고 <a href="#Menu">메뉴 바</a>는 제외됩니다).</p>
<p>
<strong>Hn</strong>: <strong>n</strong>에 창의 클라이언트 구역의 높이를 픽셀 단위로 지정합니다.</p>
<p>
<strong>Xn</strong>: <strong>n</strong>에 화면에서 창의 X-위치를 픽셀 단위로 지정합니다. 위치가 0이면 화면에서 가장 왼쪽에 보이는 왼쪽의 컬럼 픽셀입니다.</p>
<p>
<strong>Yn</strong>: <strong>n</strong>에 화면에서 Y-위치를 픽셀 단위로 지정합니다. 위치 0은 화면에서 보이는 가장 위쪽 행의 픽셀입니다.</p>
<p><strong>Center</strong>: 창을 화면에서 수평 수직으로 가운데에 정렬합니다.</p>
<p><strong>xCenter</strong>: 창을 화면에서 수평으로 중앙 정렬합니다. 예를 들어: <code>Gui, Show, xCenter y0</code>.</p>
<p><strong>yCenter</strong>: 화면에서 창을 수직으로 중앙 정렬합니다.</p>
<p><strong><a name="AutoSize"></a>AutoSize</strong>: 창의 크기를 현재 보이는 콘트롤에만 맞게 변경합니다. 이것은 새 콘트롤을 추가한 후 창의 크기를 바꿀 때, 또는 기존의 콘트롤이 크기가 바뀌거나, 숨거나, 또는 다시 나타나거나 할 때 유용합니다. 예를 들어:<br>
  <code>Gui, Show, AutoSize Center</code></p>
<p><br>
  <em><strong>다음 중 하나가 존재할 수도 있습니다:</strong></em></p>
<p><strong>Minimize</strong>: 창을 최소화하고 그 아래에 있는 창을 활성화 합니다.</p>
<p><strong>Maximize</strong>: 창을 최대화하고 활성화합니다.</p>
<p><strong>Restore</strong>: 창을 복구합니다. 창을 보여주고 활성화합니다.</p>
<p><strong>NoActivate</strong>: 창을 복구합니다. 창을 활성화하지 않고 보여줍니다.</p>
<p><strong>NA</strong>: 창을 활성화하지 않고 보여줍니다. 그 창이 최소화되어 있더라도, 그대로 있겠지만 아마도 z-순서는 더 높아질 것입니다 (z-순서란 알트-탭 선택자에 보여지는 순서입니다). 
창이 이전에 숨어 있었으면, 이 때문에 아마도 활성 창이 비활성화되지 않았다고 할지라도 그 위에 나타날 것입니다.</p>
<p>
<strong>Hide</strong>: 창을 감추고 그 아래의 창을 활성화 합니다. 이것은 기능상 <a href="#Cancel">Gui Cancel</a>과 동일합니다. 단, 숨은 창을 이동하고, 크기 변경을 할 수 있고 또는 보여줄 필요 없이 새 제목을 줄 수 있다는 점은 다릅니다. 예를 들어: <code>Gui, Show, Hide x55 y66 w300 h200, New Title</code>.</p>

<h2 id="Submit">Gui, Submit [, NoHide]</h2>
<p>
각 콘트롤의 내용을 그의 <a href="#var">연관 변수</a>에 저장하고 창을 감춥니다. 단, NoHide 옵션이 있는 경우는 예외입니다. <a href="GuiControls.htm#ListBoxMulti">다중-선택 ListBox</a>와 같이 여러 필드의 출력을 생산하는 콘트롤에 대하여, 그 출력은 창의 <a href="#Delimiter">현재 가름자</a>를 사용합니다. 그 창이 존재하지 않으면 -- 아마도 <a href="#Destroy">Gui Destroy</a>를 통하여 사라져 버렸다면 -- 이 명령어는 아무 효과가 없습니다.</p>

<h2 id="Cancel">Gui, Cancel</h2>
<p>그의 <a href="#var">연관 변수</a>에 콘트롤의 내용을 저장하지 않고 창을 감춥니다. 창이 존재하지 않으면 -- 아마도 <a href="#Destroy">Gui Destroy</a>를 통하여 파괴되어 버렸다면 -- 이 명령어는 아무 효과도 없습니다.</p>

<h2 id="Destroy">Gui, Destroy</h2>
<p>
창과 그의 모든 콘트롤을 (존재하면) 제거하고, 상응하는 메모리와 시스템 자원을 풀어줍니다. 나중에 스크립트가 그 창을 다시 만들면, 글꼴과 색깔 같은 창의 모든 특성은 (마치 창이 존재하지 않았던 것처럼) 기본 값으로 시작합니다. <code>Gui Destroy</code>를 사용하지 않더라도, 모든 GUI 창은 스크립트가 종료할 때 자동으로 파괴됩니다.</p>

<h2 id="Font">Gui, Font [, Options, FontName]</h2>
<p>
창에 추가된 콘트롤에 대하여 이 시점부터 글꼴 모양, 크기, 스타일 그리고/또는 색을 설정합니다. 예를 들어:</p>

<pre>gui, font, s10, Verdana  <em>; Set 10-point Verdana.</em></pre>
<p>
마지막 매개변수 두 개를 생략하면 글꼴을 시스템의 기본 GUI 모양, 크기 그리고 색으로 복구할 수 있습니다.</p>
<p>
<em>FontName</em>은 글꼴 이름입니다. 예를 들어 <a href="../misc/FontsStandard.htm">글꼴 테이블</a>에서 고를 수 있는 이름입니다. 

<em>FontName</em>을 생략하거나 시스템에 존재하지 않으면, 이전의 글꼴 모양이 사용됩니다 (또는 없으면, 시스템의 기본 GUI 모양이 사용됩니다). 선호하는 글꼴이 없다고 할지라도 여러 시스템에서 GUI 창이 비슷한 글꼴을 가지게 만드는 데 유용합니다. 예를 들어, 다음 명령어를 순서대로 사용하면, Verdana 글꼴이 Arial보다 우선하고, Arial은 MS sans serif보다 우선 순위가 주어집니다:</p>

<pre>gui, font,, MS sans serif
gui, font,, Arial
gui, font,, Verdana  <em>; 선호하는 글꼴.</em></pre>
<p>
<em>Options</em> 매개변수가 비어 있으면, 이전의 글꼴 속성이 사용됩니다. 그렇지 않으면, 다음 옵션 기호들을 대신 지정하십시오:</p>
<p>
<strong>C</strong>: 컬러 이름 (<a href="Progress.htm#colors">컬러 차트</a> 참조) 또는 RGB 값 -- 또는 단어 Default를 지정하면 시스템의 기본 컬러에 의존할 수 있습니다 (대부분의 시스템에서 검정색). 예를 들어: <code>cRed</code>, <code>cFFFFAA</code>, <code>cDefault</code>. 주의: <a href="GuiControls.htm#Button">Buttons</a>은 맞춤 색을 준수하지 않습니다. 또한, C 옵션을 포함함으로써 현재 색 말고 글꼴 색을 가지고 콘트롤을 개별적으로 만들 수 있습니다. 예를 들어: <code>Gui, Add, Text, cRed, My Text</code>.</p>
<p>
<strong>S</strong>: 크기 (포인트 단위). 예를 들어: <code>s12</code> (십진수로 지정하십시오. 십육진수가 아닙니다)</p>
<p>
<strong>W</strong>: 두께 (두꺼움), 1과 1000 사이의 숫자입니다 (400은 보통이고 700이면 볼드체입다). 예를 들어: <code>w600</code> (십육진수가 아니라 십진수로 지정하십시오)</p>
<p>
다음 단어들을 지원합니다: <strong>bold</strong>, <em>italic</em>, <s>strike</s>, <u>underline</u>, 그리고 norm. <em>Norm</em>은 글꼴을 보통 두께와/무게로 돌려줍니다. 그리고 이탤릭, 취소선, 그리고 밑줄을 끕니다 (그러나 기존의 색과 크기는 유지합니다). norm을 사용하여 모든 속성을 끈 다음 선택적으로 하나씩 켜는 것이 가능합니다. 예를 들어, <code>norm italic</code>을 지정하면 글꼴을 정상으로 만든 다음 이택릭으로 설정합니다.</p>
<p>
여러 옵션을 지정하려면, 각 옵션 사이에 스페이스를 포함시키십시오. 예를 들어: <code>cBlue s12 bold</code>.</p>
<p>
스크립트가 <a href="#MultiWin">여러 GUI 창</a>을 생성하면, 각 창마다 콘트롤을 더 만들 목적으로 자신의 &quot;현재 글꼴&quot;을 기억합니다.</p>
<p>
관련하여, 운영 체제는 사용자가 글꼴, 컬러, 또는 아이콘을 고르도록 표준 대화상자를 제공합니다. 이 대화상자는 <a href="DllCall.htm">DllCall()</a>을 통하여 보여줄 수 있습니다. 다음에 예시합니다: <a href="http://www.autohotkey.com/forum/topic17230.html">www.autohotkey.com/forum/topic17230.html</a>.</p>
<p id="fontq">
<strong>Q</strong>: <span class="ver">[AHK_L 19+]:</span> 텍스트 가공 품질. 예를 들어: <code>q3</code>. Q 다음에 다음 테이블에 있는 숫자가 따라와야 합니다:</p>
<table class="info">
  <tr><td>0 = DEFAULT_QUALITY</td><td>글꼴의 모습은 상관하지 않습니다.</td></tr>
  <tr><td>1 = DRAFT_QUALITY</td><td>PROOF_QUALITY를 사용할 때에 비해 글꼴의 모습이 덜 중요합니다.</td></tr>
  <tr><td>2 = PROOF_QUALITY</td><td>논리적 글꼴 속성에 정확하게 부합하는 것보다 글꼴의 문자 품질이 더 중요합니다.</td></tr>
  <tr><td>3 = NONANTIALIASED_QUALITY</td><td>글꼴을 부드럽게 외곽선 처리하지 않습니다.</td></tr>
  <tr><td>4 = ANTIALIASED_QUALITY</td><td>글꼴이 지원하면 글꼴을 부드럽게 외곽선 처리합니다. 그리고 글꼴의 크기는 너무 작지도 너무 크지도 않습니다.</td></tr>
  <tr><td>5 = CLEARTYPE_QUALITY</td><td>Windows XP 이후: 설정하면, ClearType 외곽선 처리 방법을 사용하여 텍스트를 가공합니다.</td></tr>
</table>
<p>
이런 값들의 의미에 관한 더 자세한 정보는 <a href="http://msdn.microsoft.com/en-us/library/dd183499.aspx">MSDN: CreateFont</a>를 참조하십시오.</p>
<p>
고품질 설정이 보통 기본값이기 때문에, 이 특징은 주로 앤티-엘리어싱을 끄면 텍스트가 더 선명하게 보일 경우에 사용됩니다.</p>

<h2 id="Color">Gui, Color [, WindowColor, ControlColor]</h2>
<p>
창의 그의 콘트롤의 배경색을 설정합니다. <em>WindowColor</em>는 GUI 창 자체에 대한 배경색으로 사용됩니다. <em>ControlColor</em>는 창에 존재하는 그리고 존재할 모든 콘트롤에 적용됩니다 (그렇지만 어떤 유형의 콘트롤의 맞춤 색을 지원하지 않습니다). <em>ControlColor</em>을 처음에는 <a href="ListView.htm">ListViews</a>와 <a href="TreeView.htm">TreeViews</a>가 준수하지만, 연이어서 <em>ControlColor</em>를 변경하면 영향을 미치지 않습니다. 그런 경우, <code>GuiControl +BackgroundFF9977, MyListView</code>를 사용하여 명시적으로 색을 변경하십시오.</p>
<p>
두 매개변수 중 하나라도 그대로 두면 현재 색이 유지됩니다. 그렇지 않으면, 16가지 기본 <a href="Progress.htm#colors">HTML 컬러 이름</a> 또는6-자리 RGB 컬럼 이름 (0x 접두사는 선택적), 또는 단어 Default를 지정하면 그의 기본 값으로 돌아갈 수 있습니다. 예를 들어: <code>Silver</code>, <code>FFFFAA</code>, <code>0xFFFFAA</code>, <code>Default</code>.</p>
<p>
기본값으로, 창의 배경 색은 시스템의 버튼색입니다. 그리고 콘트롤의 배경색은 시스템의 기본 창의 색입니다 (보통 흰색).</p>
<p>
<a href="#Menu">메뉴 바</a>와 그의 하위 메뉴 색은 다음 예제와 같이 바꿀 수 있습니다: <code><a href="Menu.htm">Menu</a>, MyMenuBar, Color, White</code>.</p>
<p>
배경을 투명하게 만들려면 <a href="WinSet.htm#TransColor">WinSet TransColor</a>를 사용하십시오. 그렇지만, 먼저 <a href="#Color">Gui, Color</a>을 통하여 맞춤 창을 할당하지 않고 이렇게 하면, 버튼도 투명하게 됩니다. 이를 피하려면, 먼저 맞춤 색을 할당한 다음 그 색을 투명하게 만드십시오. 예를 들어:</p>
<pre>Gui, Color, EEAA99
Gui +LastFound  <em>; GUI 창을 <a href="../misc/WinTitle.htm#LastFoundWindow">마지막 발견 창</a>으로 만들어 아래 줄에 사용합니다.</em>
WinSet, TransColor, EEAA99</pre>
<p>
또 테두리와 제목 바를 투명 배경을 가진 창으로부터 제거하려면, 창을 투명하게 <strong>만든 후에</strong> 다음과 같이 하십시오:</p>

<pre>Gui -Caption  <em>; 또는 <a href="#DefaultWin">기본 창</a>이 아니라면 <i>Gui, GuiName:-Caption</i>을 사용하십시오.</em></pre>
<p>
이 페이지의 하단 근처에 위를 시연해주는 화면-위 디스플레이 (OSD)의 예제가 있습니다.</p>

<h2 id="Margin">Gui, Margin [, X, Y]</h2>
<p>
<strong>X</strong> 그리고 <strong>Y</strong>는 명시적인 <a href="#XY">X 또는 Y 좌표</a>가 없는 콘트롤을 자동 배치할 때 창의 상/하/좌/우에 둘 여백의 픽셀의 개수입니다. 또, 자동 배치된 콘트롤들을 서로 분리할 수직 수평 거리를 결정하기 위해 여백이 사용됩니다. 마지막으로, (명시적으로 크기가 주어지지 않을 때) 처음 <a href="#Show">Gui Show</a>를 사용할 때  창의 크기를 계산하기 위해 여백이 고려됩니다.</p>
<p>
<code>Gui, Margin</code>은 <a href="#Default">기본 창</a>에만 영향을 주는 반면에, <code>Gui, Name:Margin</code>는 <a href="#MultiWin">이름붙은 창</a>에만 영향을 미칩니다. 이 명령어가 사용되지 않으면, 첫 콘트롤이 창에 추가될 때, 그 창은 현재 선택된 <a href="#Font">글꼴</a>의 크기에 비례하여 사방에 기본 여백을 얻습니다 (상하로 글꼴 높이의 0.75 배 그리고 좌우로 글꼴 높이의 1.25 배).</p>
<p>
콘트롤을 추가하는 동안 여백을 바꿀 수 있지만, 그 때의 변경은 이미 존재하는 콘트롤에는 영향을 주지 않고 앞으로 추가될 콘트롤에만 영향을 줍니다. 마지막으로, Xㄴ Y가 비어 있으면 상응하는 여백은 바뀌지 않습니다.</p>

<h2 id="Options">Gui, +/-Option1 +/-Option2 ...</h2>
<p>
GUI 명령어 바로 다음에 여러 옵션을 지정할 수 있습니다. 수행성능의 이유로, 모든 옵션을 한 줄에서 설정하는 것이 더 좋습니다. 그리고 창을 만들기 전에 (즉, <a href="#Add">Gui Add</a>와 같은 다른 하위-명령어들을 사용하기 전에) 그렇게 하는 편이 더 좋습니다.</p>
<p>
이 명령어의 효과는 점증적입니다. 즉, 명시적으로 지정된 설정만 변경합니다. 다른 설정들은 그대로 둡니다.</p>
<p>
플러스 사인을 지정하면 옵션을 추가할 수 있고 마이너스 사인은 제거할 수 있습니다. 예를 들어:</p>
<pre>Gui +Resize -MaximizeBox  <em>; <a href="#DefaultWin">기본</a> GUI 창의 설정을 변경합니다.</em>
Gui <strong>MyGui:</strong>+Resize -MaximizeBox  <em>; 이름이 <i>MyGui</i>인 GUI의 설정을 변경합니다.</em></pre>
<p>
<strong>AlwaysOnTop</strong>: 창을 항상 다른 모든 창 위에 있도록 만듭니다. 이 효과는 <a href="WinSet.htm#AlwaysOnTop">WinSet AlwaysOnTop</a>과 같습니다.</p>
<p>
<strong>Border</strong>: 가는-줄 테두리를 창 둘레에 두릅니다. 이것은 일반적이지 않습니다.</p>
<p>
<strong>Caption</strong> (기본으로 존재): 제목 바와 두꺼운 창 테두리/모서리를 제공합니다. 창에서 캡션을 제거할 때 <a href="WinSet.htm#TransColor">WinSet TransColor</a>를 사용하고 있다면, TransColor를 설정한 후에 제거하십시오.</p>
<p>
<strong><a name="Delimiter"></a>Delimiter</strong>: 파이프 (|) 말고 창이 사용해야 하는 필드 가름자를 지정합니다. 이 가름자는 콘트롤의 내용이 <a href="#Add">Gui Add</a>를 통하여 추가되거나, <a href="GuiControl.htm">GuiControl</a>를 통하여 변경되거나, 또는 <a href="#Submit">Gui Submit</a>나 <a href="GuiControlGet.htm">GuiControlGet</a>를 통하여 열람될 때 사용됩니다. 

단어 Delimiter 다음에 바로 문자 하나를 지정하십시오. 예를 들어, <code>Gui +Delimiter`n</code>은 라인피드 문자를 사용합니다. 이는 <a href="../Scripts.htm#continuation">계속 섹션</a>에 특히 적절할 수 있습니다. 비슷하게, <code>Gui +Delimiter|</code>는 기본 가름자로 되돌아 갑니다. 

스페이스나 탭을 사용하려면, <code>Gui +DelimiterSpace</code> 또는 <code>Gui +DelimiterTab</code>을 지정하십시오. 구분자가 바뀌면, 이 특정한 창위에서 작동하는 기존의 그리고 잇따르는 모든 <a href="../misc/Threads.htm">쓰레드</a>에 영향을 줍니다.</p>
<p>
<strong>Disabled</strong>: 창을 비활성화 합니다. 사용자가 그의 콘트롤과 상호작용하지 못하게 막습니다. 이는 종종 다른 창을 소유한 창에 사용됩니다 (<a href="#Owner">Owner</a> 참조).</p>
<p id="DPIScale"><strong>DPIScale</strong> <span class="ver">[v1.1.11+]</span>: <code>Gui -DPIScale</code>를 사용하면 DPI 스케일링을 끌 수 있습니다. 이는 기본 값으로 켜져 있습니다. 비-표준 DPI 설정의 시스템에 DPI 스케일링이 활성화 되면, 이 Gui 명령어는 자동으로 좌표와 크기를 조절하여 콘트롤에 대략 비슷하게 보이는 크기를 줍니다 (그러나 해상도는 더 높습니다). 예를 들어, DPI가 144 (150%)이면, <code>Gui Show, w100</code>는 Gui를 150 픽셀 너비로 만들지만, <a href="../Variables.htm#GuiWidth">A_GuiWidth</a>는 여전히 100을 돌려줍니다. <a href="../Variables.htm#ScreenDPI">A_ScreenDPI</a>에는 시스템의 현재 DPI가 담겨 있습니다.</p>
<p id="GuiHwndOutputVar">
<strong>Hwnd</strong><em>OutputVar</em> <span class="ver">[v1.1.04+]:</span> 이 옵션은 <em>OutputVar</em>에 GUI의 창 핸들 (HWND)을 저장합니다. 예를 들어: <code>Gui +HwndMyGuiHwnd</code>. 함수 안에서 <em>MyGuiHwnd</em>는 <a href="../Functions.htm#DynVar">함수적 동적 변수</a>로 취급됩니다. GUI의 HWND는 종종 <a href="PostMessage.htm">PostMessage</a>, <a href="PostMessage.htm">SendMessage</a>, 그리고 <a href="DllCall.htm">DllCall</a>와 함께 사용됩니다. 또한 <a href="../misc/WinTitle.htm#ahk_id">ahk_id WinTitle</a>로 또는 GUI 이름 대신에 직접적으로 사용되기도 합니다; 예를 들어, <code>Gui %MyGuiHwnd%:Destroy</code>.</p>
<p>
<strong><a name="PlusLabel"></a>Label</strong> <span class="ver">[v1.0.44.09+]:</span> 이 창의 <a href="#Labels">특별 라벨</a>에 맞춤 이름을 설정합니다. 예를 들어, <code>Gui MyGui:+LabelMyGui_On</code>는 MyGuiGuiClose와 MyGuiGuiSize 대신에 라벨 MyGui_OnClose와 MyGui_OnSize 를 사용합니다. 다른 말로 하면, 모든 <a href="#Labels">특수 라벨</a>의 이름에 문자열 &quot;MyGuiGui&quot;는 &quot;MyGui_On&quot;으로 교체됩니다. 이는 또한 여러 창이 같은 라벨 세트를 공유하도록 만드는 데 사용할 수도 있습니다 (이 경우 스크립트는 <a href="../Variables.htm#Gui">A_Gui</a>에 문의해 어느 창이 서브루틴을 기동했는지 결정할 수 있습니다).</p>
<p>
<strong><a name="LastFound"></a>LastFound</strong>: <a href="../misc/WinTitle.htm#LastFoundWindow">마지막 발견 창</a>이 될 창을 설정합니다 (그렇지만 <a href="#DefaultWin">Gui 쓰레드</a> 안에서는 자동으로 처리되기 때문에 불필요 합니다). 이 덕분에 <a href="WinSet.htm">WinSet</a>과 같은 명령어들은 숨어 있을 경우에도 창을 처리할 수 있습니다 (즉, <a href="DetectHiddenWindows.htm">DetectHiddenWindows</a>는 필요하지 않습니다). 이것은 특히 보여주기 전에 창의 특성을 바꾸는 데 유용합니다. 예를 들어:</p>
<pre>Gui +LastFound
WinSet, TransColor, %CustomColor% 150
Gui Show</pre>
<p>
<strong><a name="LastFoundExist"></a>LastFoundExist</strong> <span class="ver">[v1.0.43.09+]:</span> 다른 옵션과 다르게, LastFoundExist는 같은 줄에 다른 연산이 없을 경우에만 인지됩니다. <em>+LastFoundExist</em>는 <em>+LastFound</em>와 같습니다. 단, 창이 아직 존재하지 않을 경우에도 생성되지 않는다는 점은 다릅니다. 주요 사용법은 특정 GUI 창이 존재하는지 탐지하는 것입니다. 예를 들어:</p>
<pre>Gui MyGui:+LastFoundExist
IfWinExist
    MsgBox GUI "MyGui" already exists.</pre>
<p>
<strong>MaximizeBox</strong>: 최대화 버튼을 제목 바에 활성화합니다. 이것은 또 아래의 <em>Resize</em>의 일부에 포함될 수도 있습니다.</p>
<p><strong>MinimizeBox</strong> (기본 값으로 보여줌): 최소화 버튼을 제목 바에 활성화 합니다.</p>
<p>
<strong><a name="MinSize"></a>MinSize</strong> 그리고 <strong>MaxSize</strong> <span class="ver">[v1.0.44.13+]:</span> 창의 최대 최소 크기를 결정합니다. 예를 들어, 사용자가 그의 모서리를 끌어 크기를 바꿀 때, 단어 <em>MinSize</em> 그리고/또는 <em>MaxSize</em>를 앞에 접두사 없이 지정하면 창의 현재 크기를 한계 값으로 사용할 수 있습니다 (창에 현재 크기가 없으면, <a href="#Show">Gui Show</a>를 맨 처음 사용했을 때의 크기를 사용합니다). 대안으로, 너비와 X, 다음에 높이를 사용할 수 있습니다; 예를 들어: <code>Gui +Resize +MinSize640x480</code>. 차원은 픽셀 단위입니다. 그리고 창의 클라이언트 구역을 지정합니다 (이 구역에서 테두리, 제목 바, 그리고 <a href="#Menu">메뉴 바</a>를 제외됩니다). 각 숫자를 십진수로 지정하십시오. 십육진수가 아닙니다.</p>
<p>
너비 또는 높이를 생략하면 그대로 둘 수 있습니다 (예, <code>+MinSize640x</code> 또는 <code>+MinSizex480</code>). 게다가, Min/MaxSize는 여러 번 지정해 한 차원에는 창의 현재 크기를 사용하고 다른 차원에는 명시적인 크기를 사용할 수 있습니다. 예를 들어, <code>+MinSize +MinSize640x</code>는 높이에 창의 현재 크기를 사용하고 너비에 640을 사용합니다.</p>
<p>
<em>MinSize</em> 그리고 <em>MaxSize</em>가 사용되지 않으면, 운영 체제의 기본 값이 사용됩니다 (비슷하게, <code>Gui -MinSize -MaxSize</code>를 사용하면 기본 값으로 되돌아 갈 수 있습니다). 주의: 창은 <a href="#Resize">+Resize</a>이 있어야 사용자에게 크기 변경을 허용할 수 있습니다.</p>
<p>
<strong><a name="OwnDialogs"></a>OwnDialogs</strong>: <code>Gui +OwnDialogs</code>는 각 <a href="../misc/Threads.htm">쓰레드</a>마다 지정해야 합니다 (예를 들어 ButtonOK 서브루틴). 연이어 보여지는 <a href="MsgBox.htm">MsgBox</a>, <a href="InputBox.htm">InputBox</a>, <a href="FileSelectFile.htm">FileSelectFile</a>, 그리고 <a href="FileSelectFolder.htm">FileSelectFolder</a> 대화상자는 그 창이 소유해야 합니다. 그런 대화상자는 모달이 되는데, 취소하기 전까지 사용자가 그 GUI 창과 상호작용할 수 없다는 뜻입니다. 대조적으로, <a href="ToolTip.htm">ToolTip</a>, <a href="Progress.htm">Progress</a>, 그리고 <a href="Progress.htm">SplashImage</a> 창은 소유되어 있는 경우에도 모달이 되지 않습니다; 그냥 그의 소유자보다 언제나 위에 있을 뿐입니다. 어느 경우든, 소유된 대화상자 또는 창은 소유한 GUI 창이 <a href="#Destroy">파괴되면</a> 자동으로 파괴됩니다.</p>
<p>
전형적으로 이 설정을 다시 끌 필요는 없습니다. 왜냐하면 다른 <a href="../misc/Threads.htm">쓰레드</a>에는 영향을 주지 않기 때문입니다. 그렇지만, 쓰레드가 소유한 창과 소유된 대화상자를 모두 보여줄 필요가 있다면, 이 설정을 <code>Gui -OwnDialogs</code>를 통하여 끄면 됩니다.</p>
<p>
창이름 접두사가 지정되지 않으면 -- 예를 들어 <code>Gui MyGui:+OwnDialogs</code> 대신에 <code>Gui +OwnDialogs</code>와 같이 사용하면 -- <a href="#DefaultWin">쓰레드의 기본 창</a>이 그 대화상자를 소유합니다.</p>
<p>
<strong><a name="Owner"></a>Owner</strong>: <em>+Owner</em>를 사용하면 그 창을 또다른 창에게 귀속시킬 수 있습니다. 소유된 창은 기본으로 태스크바 버튼이 없습니다. 그리고 보이면 언제나 그의 소유 창 위에 나타납니다. 또한 그의 소유 창이 파괴될 때 자동으로 파괴됩니다. <em>+Owner</em>는 창의 소유자를 생성한 <u>후에</u> 사용해야 합니다. 그러나 v1.1.05 이후는 소유된 창이 생성되기 전 또는 후에 사용해도 됩니다. <em>+Owner</em>를 사용하는 방법은 다음 예제와 같이 두 가지가 있습니다:</p>

<pre>Gui, MyGui:+OwnerMyOtherGui  <em>; <i>MyGui</i>를 <i>MyOtherGui</i>에 귀속시킵니다.</em>
Gui, MyGui:+Owner  <em>; <i>MyGui</i>를 <a href="Menu.htm#MainWindow">스크립트의 메인 창</a>에 귀속시켜 태스크바 버튼이 나타나지 못하도록 방지합니다.</em></pre>
<p>
<span class="ver">[v1.1.03+]:</span> <code>+Owner</code> 다음에 바로 기존의  Gui 번호나 <a href="#Name">이름</a> 또는 최상위 수준 창의 <a href="WinGet.htm#ID">HWND</a>가 따라올 수 있습니다.</p>
<p>
<strong>호환성 주의</strong>: v1.1.03 이후로, <code>+Owner</code>는 WS_CHILD 스타일을 제거하고 WS_POPUP 스타일을 설정합니다. Gui의 부모 창을 설정하려면, 스크립트는 <code>+Parent</code> 옵션을 사용하거나, 아니면 <code>+Owner</code> 옵션을 <em>사용한 후에</em> 적절한 스타일을 오버라이드 해야합니다.</p>
<p>
소유된 창 중 하나가 보이는 동안 소유 창과 사용자가 상호작용하지 못하도록 방지하려면, <code>Gui +Disabled</code>를 통하여 소유 창을 비활성화 하십시오. 나중에 (소유된 창을 취소하거나 소유된 창이 파괴되는 순간), <code>Gui -Disabled</code>를 통하여 소유 창을 다시 활성화 하십시오. 취소/파괴 전에 이렇게 하십시오. 그래야 소유 창이 자동으로 다시 활성화 됩니다.</p>
<p>
<strong><a name="Parent"></a>Parent</strong> <span class="ver">[v1.1.03+]</span>: <code>+Parent</code> 다음에 기존의 Gui 번호나 <a href="#Name">이름</a> 또는 창이나 콘트롤의 <a href="WinGet.htm#ID">HWND</a>를 지정하면 이 창의 부모 창으로 사용할 수 있습니다. 그 Gui를 다시 최상위 수준 창으로 바꾸려면, <code>-Parent</code>를 사용하십시오. 이 옵션은 창이 생성된 후에도 작동합니다.</p>
<p>
<strong><a name="Resize"></a>Resize</strong>: 창의 크기를 변경 가능하도록 만듭니다. 그리고 그의 최대화 버튼을 제목 바에 활성화 합니다. 최대화 버튼의 활성화를 피하려면, <code>+Resize -MaximizeBox</code>를 지정하십시오.</p>
<p>
<strong>SysMenu</strong> (기본으로 존재): <code>-SysMenu</code> (마이너스 SysMenu)를 지정하면 시스템 메뉴와 아이콘을 창의 좌상 모서리에서 생략할 수 있습니다. 뿐만 아니라 제목 바의 최대, 최소, 그리고 닫기 버튼도 생략됩니다.</p>
<p>
<strong><a name="Theme"></a>Theme</strong>: <code>-Theme</code>를 지정하면, 그 다음에 창에 생성되는 콘트롤은 모두 Windows XP 이상에서 고전 테마의 모습을 가집니다. 나중에 추가로 현재 테마를 준수하는 콘트롤을 생성하려면, <code>+Theme</code>를 통하여 다시 원래대로 바꿀 수 있습니다. 주의: 이 옵션은 Windows XP보다 오래된 운영 체제에 작동하지 않으며, XP 자체에도 고전 테마가 있으면 아무 효과가 없습니다. 마지막으로, 이 설정은 콘트롤에 개별적으로 바꿀 수 있습니다. 생성될 때 그의 옵션에<code>+Theme</code> 또는 <code>-Theme</code>을 지정하면 됩니다.</p>
<p>
<strong>ToolWindow</strong>: 좁은 제목 바를 제공하지만, 태스크바 버튼은 없습니다.</p>
<p>
<strong>(Unnamed Style)</strong>: 플러스나 마이너스 사인 다음에 바로 십진 또는 십육진 <a href="../misc/Styles.htm">스타일 번호</a>를 지정하십시오.</p>
<p><strong>(Unnamed ExStyle)</strong>: 플러스나 마이너스 사인 다음에 바로 기호 E 그리고 십진 또는 십육진 확장 스타일 번호를 지정하십시오. 예를 들어, <code>+E0x40000</code>는 WS_EX_APPWINDOW 스타일을 추가합니다. 이 스타일은 창에 태스크바 버튼을 제공합니다. 다른 확장 스타일은 (별로 사용되지 않기 때문에) 여기에 문서화되지 않았지만, WS_EX_APPWINDOW를 <a href="http://www.microsoft.com">www.microsoft.com</a>에서 검색해 보면 보실 수 있습니다.</p>

<h2 id="Menu">Gui, Menu [, MenuName]</h2>
<p>
메뉴 바를 창에 추가합니다. <a href="Menu.htm">Menu</a> 명령어를 사용하면 이 목적으로 평범한 메뉴를 만들 수 있습니다. 예를 들어:</p>

<pre>Menu, FileMenu, Add, &amp;Open<a href="_EscapeChar.htm">`t</a>Ctrl+O, MenuFileOpen  <em>; Ctrl+O에 관한 것은 아래의 논평을 참조하십시오.</em>
Menu, FileMenu, Add, E&amp;xit, MenuHandler
Menu, HelpMenu, Add, &amp;About, MenuHandler
Menu, MyMenuBar, Add, &amp;File, :FileMenu  <em>; 위에서 생성한 두 개의 하위 메뉴를 부착합니다.</em>
Menu, MyMenuBar, Add, &amp;Help, :HelpMenu
<strong>Gui, Menu, MyMenuBar</strong></pre>
<p>
위의 첫 줄에, <code>&amp;Open</code> 다음에 (그 사이에 탭 문자) <code>Ctrl+O</code>가 따라 오는 것을 주목하십시오. 사용자가 메뉴 항목을 선택하는 대신 누를 키보드 단축키를 가리킵니다. <span class="ver">[v1.1.04+]:</span> 단축 키가 Ctrl, Alt 그리고 Shift와 같은 표준 수식 키 이름만 사용하면, GUI에 대하여 자동으로 <em>키보드 단축키</em>로 등록됩니다. 식별 키가 없는 단일-문자 단축키는 대소문자를 구별하고 IME 또는 Alt+NNNN 같은 비정상정인 수단으로 촉발시킬 수 있습니다.</p>
<p>
특정 키 조합이 자동으로 작동하지 않으면, <a href="_IfWinActive.htm">문맥-감지 핫키</a>를 사용하는 것이 필요할 수 있습니다. 그렇지만, 그런 핫키는 전형적으로 <a href="Send.htm">Send</a>로 촉발되지 않으며 표준 키보드 단축키보다 다른 스크립트와 간섭을 일으킬 가능성이 더 높습니다.</p>
<p>
창의 현재 메뉴 바를 제거하려면, <code>Gui Menu</code>를 사용하십시오 (즉, 마지막 매개변수를 생략하십시오).</p>
<p>
메뉴가 일단 메뉴 바로 사용된 적이 있다면, 팝업 메뉴나 하위메뉴로 사용해서는 안됩니다. 왜냐하면 메뉴 바는 내부적으로 다른 형식을 요구하기 때문입니다 (그렇지만, 이 제한은 메뉴 바 자체에만 적용되지, 그의 하위 메뉴에는 적용되지 않습니다). 이를 우회할 필요가 있다면, 메뉴 바로 사용할 메뉴를 하나 만들고 다른 목적으로 사용할 메뉴를 하나 더 똑 같이 만드십시오.</p>
<p>
현재 메뉴 바로 사용중인 메뉴 바에 Delete와 DeleteAll과 같이 파괴적인 <a href="Menu.htm">메뉴 부-명령어</a>를 사용하는 것은 지원하지 않으며 그러면 에러 대화상자가 나타납니다 (단, <a href="Menu.htm">UseErrorLevel</a>가 겨져 있는 경우는 예외입니다). 

그런 식으로 변경하려면 다음 단계를 따르십시오: 
<ol>
	<li><code>Gui Menu</code>를 통하여 메뉴 바를 떼어냅니다 (즉, <em>MenuName</em>을 생략하십시오);
	<li>파괴합니다;
	<li><code>Gui, Menu, MyMenuBar</code>를 통하여 메뉴 바를 다시 부착합니다.
</ol>
</p>

<h2 id="Minimize"><a name="Maximize"></a><a name="Restore"></a><a name="Hide"></a>Gui, Hide / Minimize / Maximize / Restore</h2>
<p>
<code>Gui Hide</code>는 <a href="#Cancel">Gui Cancel</a>와 동등합니다. 다른 세 가지 명령어는 창을 (필요하면) 다시 보여준 다음 거기에 지정된 연산을 수행합니다. 창이 존재하지 않으면 -- 아마도 <a href="#Destroy">Gui Destroy</a>를 통하여 파괴되어 버렸다면 -- 이 명령어들은 아무 효과가 없습니다.</p>

<h2 id="Flash">Gui, Flash [, Off]</h2>
<p>
태스크바의 창 버튼을 깜빡입니다. 창 제목 바와 태스크바 바튼의 색을 뒤집어 깜밖입니다. 선택적인 단어 OFF 는 제목 바와 태스크 바 버튼이 원래의 색으로 돌아오도록 만듭니다 (그러나 실제 행위는 OS 버전에 따라 달라질 수 있습니다). 아래의 예제에서, 창은 세 번 깜빡입니다. 왜냐하면 깜빡임 한 쌍 마다 색이 뒤집어지고 다음 원래의 모습으로 복구되기 때문입니다:</p>
<pre>Loop 6
{
    Gui Flash
    Sleep 500  <em>; 이 값은 굉장히 민감합니다; 이 값을 바꾸면 예상 못한 행위를 야기할 수 있습니다.</em>
}</pre>

<h2 id="Default">Gui, GuiName:Default</h2>
<p>
<a href="../misc/Threads.htm">현재 쓰레드</a>의 기본 <a href="#MultiWin">GUI 창 이름</a>을 바꿉니다. 이 이름은 창 이름이 <a href="GuiControl.htm">GuiControl</a>, <a href="GuiControlGet.htm">GuiControlGet</a>, 그리고 Gui 명령어 자체에 지정되어 있지 않으면 사용됩니다. 다음 예제에서, 기본 창 이름은  &quot;MyGui&quot;로 바뀝니다: <code>Gui MyGui:Default</code>. 기본 창에 관한 더 자세한 정보는 <a href="#DefaultWin">쓰레드의 기본 창</a>을 참조하십시오.</p>

<h2 id="Position">SmartGUI Creator를 통한 위치 배정과 레이아웃</h2>
<p>
다음 섹션에서 기술하는 옵션들은 간단한 레이아웃에 적당하지만, Rajat의 SmartGUI Creator를 사용하는 편이 더 쉬울 수 있습니다. 왜냐하면 완전히 눈으로 볼 수 있기 때문입니다; 즉,, &quot;눈에 보이는 대로 얻습니다&quot;. SmartGUI Creator는 무료이고 <a href="http://www.autohotkey.com/docs/SmartGUI/">www.autohotkey.com/docs/SmartGUI/</a>으로부터 내려 받을 수 있습니다</p>

<h2 id="PosSize">콘트롤의 위치 배정과 크기 변경</h2>
<p>
<em>Options</em>으로부터 어떤 차원 그리고/또는 좌표가 생략되면, 그 콘트롤은 이전 콘트롤에 상대적으로 위치가 결정되고 자동으로 그의 내용에 맞게 자연스런 크기로 결정됩니다.</p>
<p>
다음 옵션이 지원됩니다:</p>
<p><strong><a name="R"></a>R</strong>: 텍스트 행 (R2.5와 같이 부동 소수점 수를 포함할 수 있습니다). <strong>R</strong>을 설정하는 것이 <strong>H</strong> (높이)를 설정하는 것보다 더 선호됩니다. <strong>R</strong>옵션과 <strong>H</strong> 옵션이 모두 존재하면, <strong>R</strong>이 우선 순위를 갖습니다. GroupBox에 대하여, 이 설정은 박스 안의 공간에 예약된 콘트롤의 개수입니다. <a href="GuiControls.htm#DropDownList">DropDownLists</a>, <a href="GuiControls.htm#ComboBox">ComboBoxes</a>, 그리고 <a href="GuiControls.htm#ListBox">ListBoxes</a>에 대하여, 콘트롤의 리스트 부분 안에 한 번에 보이는 항목의 개수입니다 (그러나 Windows XP 이후에서, 종종 DropDownList와 ComboBoxor에 <strong>R</strong> 옵션과<strong>H</strong> 옵션을 모두 생략하는 것이 바람집합니다. 그래야 팝업 리스트가 자동으로 사용가능한 사용자의 바탕화면의 높이를 이용할 수 있습니다). 다른 콘트롤 유형에 대하여, <strong>R</strong>은 그 콘트롤 안에 시각적으로 딱 맞는 텍스트의 행의 개수입니다.</p>
<p>
<strong>W</strong>: 픽셀 단위 너비. 생략되면, 어떤 콘트롤 유형은 내용에 기반하여 너비를 자동으로 계산합니다. 다른 콘트롤 유형은 다음과 같이 기본 너비가 있습니다:<br>
  <b>탭 콘트롤:</b>
  현재 글꼴 크기의 30 배, 더하기 <a href="#Margin">X-여백</a>의 세 배.<br>
<b>수직 진도 바:</b> 현재 글꼴 크기의 두 배.<br>
<b>수평 진도 바, 수평 슬라이더, 드롭다운 리스트, 콤보박스, 리스트박스, 편집박스, 그리고 핫키: </b>현재 글꼴 크기 15배 (단, 그룹박스는 안 여백을 위해 18배이므로 제외).</p>

<p>
<strong>H</strong>: 픽셀 단위 높이. <strong>H</strong>옵션과 <strong>R</strong>옵션이 모두 없으면, DropDownLists, ComboBoxes, ListBoxes, 그리고 빈 여러-줄 편집 콘트롤은 기본 값이 3 행입니다; GroupBoxes는 기본 값이 2 행입니다; 수직 슬라이더와 진도 바는 기본 값이 5 행입니다; 수평 슬라이더는 기본 값이 30 픽셀입니다 (단, 두께가 지정되어 있는 경우는 제외); 수평 진도 바는 기본 값이 현재 글꼴의 2배입니다; 핫키 콘트롤은 기본 값이 1 행입니다; 그리고 탭 콘트롤은 기본값이 10 행입니다. 다른 콘트롤 유형에 대하여, 높이는 그의 내용에 기반하여 자동으로 계산됩니다. </p>
<p>
DropDownLists 그리고 ComboBoxes에 대하여, <strong>H</strong>는 콘트롤에서 언제나 보이는 부분과 그의 리스트 부분을 조합해 높이를 결정한다는 것을 주목하십시오. (그러나 높이가 너무 낮게 설정되더라도, 적어도 하나의 항목은 리스트에 언제나 보일 것입니다). 또한, 모든 유형의 콘트롤에 대하여, <strong>H</strong> 옵션보다 <strong>R</strong> 옵션을 통하여 숫자를 지정하는 것이 더 좋습니다. 왜냐하면 콘트롤이 부분적으로 불완전하게 텍스트를 보여주지 못하게 방지하기 때문입니다.</p>
<p>
<strong>wp+n</strong>, <strong>hp+n</strong>, <strong>wp-n</strong>, <strong>hp-n</strong> (여기에서 <strong>n</strong>은 숫자임)를 사용하면 콘트롤의 너비와 높시를 이전에 추가된 콘트롤의 너비와 높이와 같게 설정할 수 있습니다. 선택적으로 플러스나 마이너스 사인을 사용해 조절하면 됩니다. 예를 들어, <code>wp</code>는  이전 콘트롤의 너비로 콘트롤의 너비를 설정합니다. 그리고 <code>wp-50</code>은 이전 콘트롤의 너비보다 50 작게 설정합니다.</p>
<p>
<strong><a name="XY"></a>X</strong>: X-위치. 예를 들어, <code>x0 y0</code>를 지정하면 콘트롤을 창의 클라이언트 구역의 좌상 모서리에 배치합니다. 클라이언트 구역은 제목 바와 메뉴 바 아래에 있습니다.  <strong>X</strong>는 생략되었지만 <strong>Y</strong>는 지정되었다면, 콘트롤은 이전에 추가된 모든 콘트롤의 오른쪽에 배치됩니다. 이것을 새로운 &quot;열&quot;의 시작으로 간주할 수 있습니다.</p>
<p>
<strong>Y</strong>: Y-위치. <strong>Y</strong>가 생략되었지만 <strong>X</strong>는 지정되었다면, 그 콘트롤은 이전에 추가된 모든 콘트롤의 아래에 배치됩니다. 이것을 새 &quot;행&quot;의 시작으로 간주할 수 있습니다.</p>
<p>
<strong>X</strong>나 <strong>Y</strong>를 생략하면 앞으로 콘트롤의 크기나 글꼴을 바꿀때 그에 딱 맞게 GUI 레이아웃을 지동으로 조절할 수 있으므로 유용합니다.
대조적으로, 매 콘트롤마다 절대 위치를 지정하면 수작업으로 아래에 있는 모든 콘트롤의 위치를 확대된 또는 축소된 콘트롤의 오른쪽으로 이동해야 합니다.</p>
<p>
<strong>X</strong>와 <strong>Y</strong>가 모두 생략되면, 콘트롤은 표준 패딩 거리를 사용하여 이전 콘트롤의 아래에 배치됩니다.</p>
<p>
<a name="PosPlus"></a><strong>X</strong>와 <strong>Y</strong>에 대하여, 선택적인 플러스 사인을 포함시키면 이전에 추가된 콘트롤의 오른쪽 또는 아래쪽 가장자리에 (각각) 상대적으로 콘트롤을 배치할 수 있습니다. 예를 들어, <code>Y+10</code>을 지정하면  표준 패딩 거리를 사용하는 대신에 이전 콘트롤의 10 픽셀 아래에 콘트롤을 배치합니다. 비슷하게, <code>X+10</code>을 지정하면 이전 콘트롤의 10 픽셀 오른쪽으로 콘트롤을 배치합니다. <code>X-10</code>과 같은 음수는 절대 위치 지정을 위해 예약되어 있으므로, 음의 오프셋을 사용하려면, 그 앞에 플러스 사인을 포함하십시오. 예를 들어: <code>X+-10</code>.</p>
<p id="PosPlusMargin">
<span class="ver">[v1.1.16+]:</span> <strong>X+</strong>와 <strong>Y+</strong>에 대하여, 기호 <strong>M</strong>을 창의 현재 <a href="#Margin">여백</a>에 대안으로 사용할 수 있습니다. 예를 들어, <strong>x+m</strong>은 이전 콘트롤의 오른쪽 가장자리에다 표준 패딩 거리를 사용합니다. <strong>xp y+m</strong>는 이전 콘트롤의 아래에 콘트롤을 배치합니다. 반면에 X 좌표만 지정하면 보통 기본값으로 <strong>yp</strong>를 뜻합니다.</p>
<p>
<strong>xp+n</strong>, <strong>yp+n</strong>, <strong>xp-n</strong>, <strong>yp-n</strong> (여기에서 <strong>n</strong>는 숫자임)는 이전 콘트롤의 좌상 모서리에 상대적으로 콘트롤을 배치하는 데 사용할 수 있습니다. 종종 <a href="GuiControls.htm#GroupBox">GroupBox</a> 안에 콘트롤들을 싸 넣을 때 유용합니다.</p>
<p>
<strong>xm</strong>과 <strong>ym</strong>을 사용하면 창의 좌단 그리고 상단 <a href="#Margin">여백</a>에 (각각) 콘트롤을 배치할 수 있습니다 (이 두 옵션 다음에 플러스/마이너스 사인과 숫자가 하나 따라올 수도 있습니다). x-위치 없이 <strong>ym</strong>을 지정하면, 콘트롤은 수직으로 상단 여백에 배치되지만 수평으로는 이전에 추가된 모든 콘트롤의 오른쪽에 배치됩니다. 이것을 새로운 &quot;열&quot;의 시작으로 간주할 수 있습니다. 그 반대로 역시 마찬가지입니다.</p>
<p>
<a name="xs"></a><strong>xs</strong> 그리고 <strong>ys</strong>: 이 옵션들은 <strong>xm</strong> 그리고 <strong>ym</strong>과 비슷하지만 이전에 그의 옵션에 단어 <a href="#Section">Section</a>을 가지고 콘트롤을 추가할 때 저장된 좌표를 참조합니다 (창의 첫 번째 콘트롤은 언제나 새 섹션을 시작합니다. 그의 옵션에 그 단어가 지정되어 있지 않아도 상관이 없습니다). 

x-위치 없이 <strong>ys</strong>를 지정하면, 콘트롤은 이전에 저장된 y-위치에 배치되지만, 가장 최근에 사용된 단어 <a href="#Section">Section</a> 때문에, 추가된 모든 콘트롤의 오른쪽에 배치됩니다 ; 이것을 그 섹션 안에서 새 열이 시작한 것으로 간주해도 좋습니다. 예를 들어:</p>

<pre>gui, add, edit, w600  <em>; 상당히 넓은 편집 콘트롤을 창의 상단에 추가합니다.</em>
gui, add, text, <strong>section</strong>, First Name:  <em>; 이 콘트롤의 위치를 저장하고 새 섹션을 시작합니다.</em>
gui, add, text,, Last Name:
gui, add, edit, <strong>ys</strong>  <em>; 이 섹션 안에서 새 열을 시작합니다.</em>
gui, add, edit
gui, show</pre>
<p>
위의 반대도 (y-위치를 생략하고 <strong>xs</strong>만 지정해도) 역시 마찬가지입니다 .</p>
<p>
<strong>xs</strong>와 <strong>ys</strong> 다음에 선택적으로 플러스/마이너스 사인과 숫자 하나가 따라올 수도 있습니다. 또한, 단어 <a href="#Section">Section</a>과 xs/ys를 둘 다 콘트롤의 옵션에 지정하는 것도 가능합니다; 이렇게 하면 자기 자신에 대해서는 이전 섹션을 사용하지만 뒤이은 콘트롤에는 새 섹션을 확립합니다.</p>

<h2 id="Events">사용자 입력을 저장하고 그에 반응하기</h2>
<p>
<strong><a name="var"></a>V</strong>: 변수. 변수를 콘트롤에 연관 짓습니다. 기호 V 다음에 바로, 전역 변수의 이름을 지정하십시오 (또는 전역 변수를 가리키는 <a href="../Functions.htm#ByRef">ByRef 지역 변수</a>, 또는 v1.0.46.01+에서는 <a href="../Functions.htm#static">정적 변수</a>). 예를 들어, <code><strong>v</strong>MyEdit</code>를 지정하면 <a href="#Submit">Gui Submit</a> 명령어가 사용될 때마다 콘트롤의 내용이 변수 <em>MyEdit</em>에 저장됩니다. 콘트롤이 입력이 불가능하더라도 -- Text 콘트롤이나 GroupBox 콘트롤이라도 --변수를 거기에 연관지으면 여전히 도움이 됩니다. 왜냐하면 변수의 이름이 콘트롤의 유일한 식별자로 기여할 수 있어서 <a href="GuiControl.htm">GuiControl</a>, <a href="GuiControlGet.htm">GuiControlGet</a>, 그리고 <a href="../Variables.htm#GuiControl">A_GuiControl</a>에 사용할 수 있기 때문입니다. 주의: <a href="#Submit">Gui Submit</a>은 입력 불가능한 콘트롤의 (예를 들어Text 그리고 GroupBox) 변수의 내용은 물론이고, 다음 섹션에 문서화된 것들도 변경하지 못합니다 (예를 들어 <a href="ListView.htm">ListView</a> 그리고 <a href="TreeView.htm">TreeView</a>).</p>
<p id="label">
<strong>G</strong>: Gosub (g-label). 사용자가 콘트롤을 클릭하거나 변경할 때 함수의 서브루틴을 자동으로 기동합니다. 기호 G 다음에 곧바로, 실행할 <a href="../misc/Labels.htm">라벨</a>의 이름을 지정하십시오. <code>gCancel</code>은 지정하면 묵시적인 <a href="#Cancel">Gui Cancel</a>을 실행할 수 있습니다 (그러나 이름이 &quot;Cancel&quot;인 라벨이 스크립트에 존재하면, 대신에 그 라벨이 실행됩니다). 서브루틴은 다음의 내장 변수들을 참조할 수도 있습니다: <a href="../Variables.htm#Gui">A_Gui</a>, <a href="../Variables.htm#GuiControl">A_GuiControl</a>, <a href="../Variables.htm#GuiEvent">A_GuiEvent</a>, 그리고 <a href="../Variables.htm#EventInfo">A_EventInfo</a>.</p>
<p>
<span class="ver">[v1.1.20+]:</span>유효한 라벨 이름이 아니면, 함수 이름을 대신 사용할 수 있습니다. 다른 방법으로, <a href="GuiControl.htm#Functor">GuiControl</a> 명령어를 사용하면 <a href="../objects/Functor.htm">함수 객체</a>를 콘트롤에 연관지을 수 있습니다. 함수는 선택적으로 다음 매개변수를 받을 수 있습니다 (여기에서 <code>gCtrlEvent</code>은 함수를 설정합니다):</p>

<pre class="Syntax">CtrlEvent(CtrlHwnd, GuiEvent, EventInfo, ErrorLevel)</pre>
<p>
매개변수의 의미는 콘트롤의 유형에 따라 다릅니다.</p>

<h2 id="OtherOptions">Controls: 공통 스타일과 기타 옵션</h2>
<p>
주의: 앞에 부호가 없으면, 플러스 사인이 있다고 간주됩니다; 예를 들어, <code>Wrap</code>은 <code>+Wrap</code>와 같습니다. 대조적으로, <code>-Wrap</code>는 단어-넘기기 특성을 제거합니다.</p>
<p>
<strong><a name="AltSubmit"></a>AltSubmit</strong>: 보조적인 제출 방법을 사용합니다. DropDownList, ComboBox, 그리고 ListBox에 대하여 이 매개변수는 <a href="#Submit">Gui Submit</a> 명령어가 텍스트가 아니라 선택된 항목의 위치를 저장하도록 만듭니다. 항목이 선택되지 않으면, ComboBox는 여전히 그의 편집 필드에 텍스트를 저장합니다; 비슷하게, DropDownList 또는 ListBox는 여전히 그의 <a href="#var">출력 변수</a>를 비웁니다. 주의: AltSubmit는 또 그런 콘트롤의 내용을 열람할 때 <a href="GuiControlGet.htm">GuiControlGet</a>의 행위에도 영향을 미칩니다.</p>
<p>
<strong>C</strong>: 텍스트의 색깔 (<a href="GuiControls.htm#Button">버튼</a>에는 아무 영향이 없습니다). 기호 C 다음에 곧바로 색 이름 (<a href="Progress.htm#colors">컬러 차트</a> 참조) 또는 RGB 값을 지정하십시오 (0x 접두사는 선택적임). 예제: <code>cRed</code>, <code>cFF2211</code>, <code>c0xFF2211</code>, <code>cDefault</code>.</p>
<p>
<strong>Disabled</strong>: 입력 가능한 콘트롤이 비활성 상태로 나타나도록 만듭니다. 그래서 사용자는 그의 내용에 초점을 두거나 변경할 수 없습니다. <a href="GuiControl.htm#Enable">GuiControl Enable</a>를 사용하면 나중에 활성화 할 수 있습니다. 주의: Edit 콘트롤을 읽기 전용으로 만들려면, 대신에 문자열 <code>ReadOnly</code>를 지정하십시오. 또한, 단어 Disabled는 선택적으로 다음에 바로 0 또는 1이 따라와 시작 상태를 나타낼 수 있습니다 (0이면 활성화 1이면 비활성화를 나타냅니다). 다른 말로, <code>Disabled</code>와 <code>Disabled%VarContainingOne%</code>는 같습니다.</p>
<p>
<strong>Hidden</strong>: 콘트롤은 처음에 안 보입니다. <a href="GuiControl.htm#Show">GuiControl Show</a>를 사용하면 나중에 보여줄 수 있습니다. 단어 Hidden은 선택적으로 다음에 곧바로 0 또는 1이 따라와 시작 상태를 나타낼 수 있습니다 (0이면 보이고 1이면 숨습니다). 다른 말로, <code>Hidden</code>과 <code>Hidden%VarContainingOne%</code>는 같습니다.</p>
<p>
<strong>Left</strong>: 콘트롤의 내용을 그의 가능한 너비 안에서 왼쪽으로 정렬합니다. 이 옵션은 다음 콘트롤에 영향을 미칩니다: Text, Edit, Button, Checkbox, Radio, UpDown, Slider, Tab, Tab2, GroupBox, DateTime.</p>
<p>
<strong>Right</strong>: 콘트롤의 텍스트를 그의 가능한 너비 안에서 오른쪽으로 정렬합니다. 체크박스와 라디오버튼에 대하여, 이는  또 박스 자신을 콘트롤의 왼쪽이 아니라 오른쪽에 배치합니다. 이 옵션은 다음 콘트롤에 영향을 줍니다: Text, Edit, Button, Checkbox, Radio, UpDown, Slider, Tab, Tab2, GroupBox, DateTime, Link.</p>
<p>
<strong>Center</strong>: 콘트롤의 텍스트를 그의 가능한 너비 안에서 가운데로 정렬합니다. 이 옵션은 다음 콘트롤에 영향을 줍니다: Text, Edit, Button, Checkbox, Radio, Slider, GroupBox.</p>
<p>
<strong><a name="Section"></a>Section</strong>: 새 섹션을 시작하고 나중에 <a href="#xs">위에</a> 기술한 <em>xs</em>와 <em>ys</em> 위치 지정 옵션에 사용하기 위해 이 콘트롤의 위치를 저장합니다.</p>
<p>
<strong><a name="Tabstop" id="Tabstop"></a>Tabstop</strong>: <code>-Tabstop</code>을 (즉, 마이너스 탭스탑) 사용하면 사용자가 TAB 키를 눌러 항해할 때. 입력 가능 콘트롤을 건너뛸 수 있습니다.</p>
<p>
<strong><a name="Wrap"></a>Wrap</strong>: 그의 가능한 너비 안에서 콘트롤의 내용에 단어-넘기기를 활성화합니다. 거의 모든 콘트롤 유형이 단어-줄넘기기를 켜고 시작하기 때문에, 단어 넘기기를 끄려면 <code>-Wrap</code>를 사용합시오.</p>
<p>
<strong>VScroll</strong>: 이런 유형의 콘트롤에 적절하면 수직 스크롤 바를 제공합니다.</p>
<p>
<strong>HScroll</strong>: 이런 유형의 콘트롤에 적절하면 수평 스크롤 바를 제공합니다. 이 문단의 나머지는 <a href="GuiControls.htm#ListBox">ListBox</a>에만 적용됩니다. 수평 스크롤 너비는 리스트 박스 너비의 3 배가 기본값입니다. 다른 스크롤 너비를 지정하려면, 숫자를 단어 HScroll 바로 다음에 지정하십시오. 예를 들어, <code>HScroll500</code>은 리스트박스 안에서 500 픽셀의 수평 스크롤을 허용합니다. 그렇지만, 지정된 스크롤 너비가 리스트박스의 너비보다 작으면, 스크롤 바가 보이지 않습니다 (그렇지만 조금이라도<em>HScroll</em>이 보여야 수평 스크롤바를 나중에 <code><a href="GuiControl.htm">GuiControl</a>, +HScroll500, MyScrollBar</code>를 통하여 추가할 수 있습니다. 그렇지 않으면 불가능합니다).</p>

<h2>콘트롤: 잘 쓰이지 않는 스타일과 옵션</h2>
<p>
<strong><a name="BackgroundTrans"></a>BackgroundTrans</strong>: 투명 배경을 사용합니다. 콘트롤이 텍스트 그림 또는 그룹박스 콘드롤 뒤에 있어도 뚫고 볼 수 있습니다. 예를 들어, 그림 콘트롤 위에 보여지는 투명한 텍스트 콘트롤은 텍스트를 그림의 일부분처럼 보이게 만듭니다. <code><a href="GuiControl.htm">GuiControl</a> +Background</code>를 사용하면 이 옵션을 나중에 제거할 수 있습니다. 투명 이미지에 관한 더 자세한 정보는 <a href="GuiControls.htm#PicAltSubmit">Picture 콘트롤의 AltSubmit 섹션</a>을 참조하십시오. 
<b>알려진 한계</b>: BackgroundTrans는 <a href="ListView.htm">ListView</a>가 들어 있는 <a href="GuiControls.htm#Tab">Tab 콘트롤</a> 안의 콘트롤에는 제대로 작동하지 않을 수 있습니다.</p>
<p>
<strong>-Background</strong> (즉, 마이너스 배경): 표준 배경색을 사용합니다.  <a href="#Color">Gui Color</a> 명령어로 설정된 색을 사용하지 않습니다. 이것은 주로 Tab 콘트롤이 창 색이 아니라 그의 표준 색을 가지도록 만드는 데 사용됩니다. <code><a href="GuiControl.htm">GuiControl</a> +Background</code>를 사용하면 나중에 이 옵션을 제거할 수 있습니다.</p>
<p>
<strong>Border</strong>: 콘트롤 둘레에 얇은 줄 테두리를 두릅니다. 대부분의 콘트롤은 이것이 필요하지 않습니다. 왜냐하면 이미 유형-종속적인 테두리가 있기 때문입니다. 테두리를 <em>기존의</em> 콘트롤에 추가할 때, 콘트롤의 너비와 높이를 각각 1 픽셀씩 증가시킬 필요가 있을 수도 있습니다.</p>
<p>
<strong><a name="HwndOutputVar"></a>Hwnd</strong><em>OutputVar</em> <span class="ver">[v1.0.46.01+]:</span> <a href="#Add">Gui Add</a>와 함께 사용될 때, 이 옵션은 새로 생성된 콘트롤의 창 핸들 (HWND)을 <em>OutputVar</em>에 저장합니다. 예를 들어: <code>Gui, Add, Edit, vMyEdit HwndMyEditHwnd</code>. 함수 안에 사용될 때, <em>MyEditHwnd</em>은  <a href="../Functions.htm#DynVar">함수 동적 변수</a>로 취급됩니다. 콘트롤의  HWND는 종종 <a href="PostMessage.htm">PostMessage</a>, <a href="PostMessage.htm">SendMessage</a>, 그리고 <a href="DllCall.htm">DllCall</a>에 사용됩니다. 또 직접적으로 <a href="../misc/WinTitle.htm#ahk_id">ahk_id WinTitle</a>로 사용되기도 합니다 (이것은 숨은 콘트롤에도 작동합니다. 심지어 <a href="DetectHiddenWindows.htm">DetectHiddenWindows</a>가 꺼져(Off) 있어도 상관 없습니다). 또는 <span class="ver">[in v1.1.04+]</span> GuiControl과 GuiControlGet에 <em>ControlID</em> 매개변수로 사용됩니다. 

관련하여 말씀 드리자면, 부모 창의 HWND는 <code><a href="#GuiHwndOutputVar">Gui MyGui:+HwndOutputVar</a></code>를 통하여 열람할 수 있습니다.</p>
<p>
<strong>Theme</strong>: 이 옵션은 새로 생성된 콘트롤에 대하여 창의 현재 테마 설정을 오버라이드 하는 데 사용될 수 있습니다. 기존의 콘트롤에 사용될 때는 아무 효과도 없습니다; 그렇지만, 미래의 버전에서 이 기능은 변경될 수 있습니다. 자세한 것은 <a href="#Theme">Gui +/-Theme</a>를 참조하십시오.</p>
<p>
<strong>(Unnamed Style)</strong>: 플러스 또는 마이너스 사인 다음에 바로 십진 또는 십육진 <a href="../misc/Styles.htm">스타일 번호</a>를 지정하십시오. 부호가 생략되면, 플러스 사인이 있다고 간주됩니다.</p>
<p>
<strong>(Unnamed ExStyle)</strong>: 플러스나 마이너스 사인 다음에 곧바로 기호 E 그리고 십진 또는 십육진 확장 스타일 번호를 지정하십시오. 사인이 생략되면, 플러스 사인이 있다고 간주됩니다. 예를 들어, <code>E0x200</code>는 WS_EX_CLIENTEDGE 스타일을 추가합니다. 이 스타일은 푹 들어간 사방 테두리를 제공하므로 그림이나 기타 콘트롤에 적절합니다.  다른 확장 스타일은 (거의 사용되지 않으므로) 여기에 문서화되지 않았지만, WS_EX_CLIENTEDGE를 <a href="http://www.microsoft.com">www.microsoft.com</a>에서 검색해 보십시오.</p>

<h2 id="Labels">창 이벤트</h2>
<p>다음 라벨 (서브루틴)은 스크립트에 존재한다면 자동으로 GUI 창과 연관됩니다:</p>
<ul>
  <li><a href="#GuiClose">GuiClose</a></li>
  <li><a href="#GuiEscape">GuiEscape</a></li>
  <li><a href="#GuiSize">GuiSize</a></li>
  <li><a href="#GuiContextMenu">GuiContextMenu</a></li>
  <li><a href="#GuiDropFiles">GuiDropFiles</a></li>
</ul>
<p><span class="ver">[v1.1.20+]:</span> 주어진 이벤트에 대하여 라벨이 존재하지 않으면, 그 이름의 함수가 대신 호출됩니다. 그 함수는 선택적으로 첫 매개변수로 GUI의 <a href="#GuiHwndOutputVar">HWND</a>를 받을 수 있습니다. 어떤 이벤트는 추가로 매개변수가 있습니다.</p>
<p>
<a href="#MultiWin">1 번 창을 제외하고</a> 다른 창들에 대하여, 창의 이름이나 번호는 위에 언급된 특수 라벨에 대하여 접두사로 사용됩니다; 예를 들어, <code>2GuiEscape</code> 그리고 <code>2GuiClose</code>는 2 번 창의 기본 라벨이 됩니다. 반면에 <em>MyGui</em>GuiEscape 그리고 <em>MyGui</em>GuiClose는 <em>MyGui</em>에 대하여 기본 라벨이 됩니다. 맞춤 접두사를 설정하려면, <code><a href="#PlusLabel">Gui +Label</a></code>를 사용하십시오.</p>

<p>
<strong><a name="GuiClose"></a>GuiClose</strong>: 다음 중 하나로 창이 닫힐 때 기동됩니다: 제목 바에서 X를 누름, 시스템 메뉴에서 &quot;닫기&quot;를 선택함, 또는 <a href="WinClose.htm">WinClose</a>로 닫음. 이 라벨이 없을 경우, 창을 닫으면 그냥 감춥니다. 이 효과는 <a href="#Cancel">Gui Cancel</a>과 같습니다. GuiClose에 응답하여 가장 흔한 조치 중 하나는 <a href="ExitApp.htm">ExitApp</a>입니다; 예를 들어:</p>

<pre>GuiClose:
ExitApp</pre>
<p>
<span class="ver">[v1.1.20+]:</span> GuiClose가 함수이면,  GUI는 닫히는 게 기본값입니다. 그 함수는 0 아닌 정수를 돌려주어 닫히지 못하도록 할 수 있습니다. 아래 예제에 보여주는 바와 같습니다:</p>

<pre>GuiClose(GuiHwnd) {  <em>; 이 매개변수를 선언하는 것은 선택적입니다.</em>
    MsgBox 4,, GUI를 정말 닫고 싶습니까?
    ifMsgBox No
        return true  <em>; true = 1</em>
}</pre>

<p>
<strong><a name="GuiEscape"></a>GuiEscape</strong>: GUI 창이 활성화 되어 있는 동안에 사용자가 Escape 키를 누를 때 기동됩니다. 라벨이 없으면, Escape를 눌러도 효과가 없습니다. 
<b>알려진 한계:</b> 창의 첫 콘트롤이 활성화 되어 있지 않으면 (콘트롤 유형에 따라 다름), GuiEscape 라벨은 기동하지 않습니다. 이런 효과를 생산하는 다른 상황이 있을 수 있습니다.</p>

<p><strong><a name="GuiSize"></a>GuiSize</strong>: 창이 크기가 바뀔때, 최대화, 최소화, 또는 복원될 때 기동됩니다. 내장 변수 <a href="../Variables.htm#GuiWidth">A_GuiWidth</a>와 <a href="../Variables.htm#GuiWidth">A_GuiHeight</a>에 창의 클라이언트 구역의 너비와 높이가 담깁니다. 클라이언트 구역에서 제목 바, 메뉴 바, 그리고 테두리를 제외합니다. 게다가, <a href="../Variables.htm#EventInfo">A_EventInfo</a> 그리고 <a href="../misc/ErrorLevel.htm">ErrorLevel</a>는 모두 다음 숫자 중 하나를 담습니다:</p>
<p>
  0: 창이 복원되었다. 또는 테두리를 끌어서 정상적으로 크기가 변경되었다.<br>
  1: 창이 최소화되었다.<br>
  2: 창이 최대화되었다.</p>
<p>
스크립트는 GuiSize를 사용해 사용자의 창 크기 변경에 응답하여 콘트롤의 크기와 위치를 다시 조절할 수 있습니다. <a href="http://ahkscript.org/boards/viewtopic.php?f=6&t=1079">tmplinshi와 toralf가 만든 AutoXYWH() </a>를 사용하면 더 쉽게 이것을 처리할 수 있습니다.</p>
<p>
창이 크기가 바뀔 때 (스크립트가 바꾸어도), GuiSize는 즉시 호출되지 않을 수 있습니다. 다른 창 이벤트와 마찬가지로, 현재 쓰레드가 <a href="Thread.htm#Interrupt">인터럽트가 불가능하다면</a>, GuiSize는 쓰레드가 인터럽트가 가능해질 때까지 호출되지 않습니다. 스크립트가 방금 창의 크기를 변경했다면, 다음 예제를 따라  GuiSize가 즉시 호출되는 것을 확인하십시오:</p>

<pre><a href="Critical.htm#Off">Critical Off</a>  <em>; Critical On이 사용되지 않았더라도.</em>
<a href="Sleep.htm">Sleep -1</a></pre>
<p>
<span class="ver">[v1.1.22.05+]:</span> <code>Gui Show</code>는 자동으로 <code>Sleep -1</code>을 수행합니다. 그래서 일반적으로 그 경우에는 Sleep을 호출할 필요가 없습니다.</p>
<p>
<span class="ver">[v1.1.20+]:</span> GuiSize가 함수이면, 그의 매개변수는 다음과 같습니다:</p>
<pre class="Syntax">GuiSize(GuiHwnd, EventInfo, Width, Height)</pre>

<p>
<strong><a name="GuiContextMenu"></a>GuiContextMenu</strong>: 사용자가 제목 바와 라벨을 제외하고 창을 아무데나 클릭하면 기동됩니다. 또 Apps 키나 Shift-F10 키눌림에 응답하여 기동됩니다. 대부분의 다른 GUI 라벨과 다르게, GuiContextMenu는 동시에 여러 병행 <a href="../misc/Threads.htm">쓰레드</a>를 가질 수 있습니다. 다음 내장 변수를 GuiContextMenu에서 사용할 수 있습니다:</p>
<ol>
  <li><a href="../Variables.htm#GuiControl">A_GuiControl</a>, 안에 이벤트를 받은 콘트롤의 <a href="../Variables.htm#GuiControl">텍스트나 변수 이름</a>이 들어 있습니다  (없으면 비어 있습니다).</li>
  <li><a href="../Variables.htm#EventInfo">A_EventInfo</a>: ListBox, ListView, 또는 TreeView가 문맥 메뉴의 목표일 때 (위의 A_GuiControl가 결정함), A_EventInfo는 어느 콘트롤의 항목이 목표인지 지정합니다:<br>
    <a href="GuiControls.htm#ListBox">ListBox</a> 또는 <a href="ListView.htm">ListView</a>: A_EventInfo에는 현재 초점이 있는 행의 번호가 담겨 있습니다 (없으면 0).<br>
    <a href="TreeView.htm">TreeView</a>: 우클릭에 대하여, A_EventInfo에는 클릭된 항목의 ID 번호가 담깁니다 (또는 사용자가 항목 말고 다른 곳을 클릭 했다면 0입니다). AppsKey와 Shift-F10에 대하여, A_EventInfo에는 선택된 항목의 ID 번호가 담깁니다.</li>
  <li>A_GuiX 그리고 A_GuiY, 여기에는 스크립트가 메뉴를 보여줄  X 좌표와 Y 좌표가 담깁니다 (예, <code><a href="Menu.htm">Menu</a>, MyContext, Show, %A_GuiX%, %A_GuiY%</code>). 좌표는 창의 조상단 모서리에 상대적입니다.</li>
  <li>A_GuiEvent, 사용자가 우클릭하면 단어 RightClick이 담기고 메뉴가 Apps 키 또는 Shift-F10에 의하여 촉발되었다면 Normal이 담깁니다.</li>
</ol>
<p>주의: <a href="GuiControls.htm#Edit">Edit</a> 그리고 <a href="GuiControls.htm#MonthCal">MonthCal</a> 콘트롤은 자신만의 문맥이 있기 때문에, 그 중에 하나에 우클릭하더라도 GuiContextMenu는 기동되지 않습니다.</p>
<p>
<span class="ver">[v1.1.20+]:</span> GuiContextMenu가 함수이면, 그의 매개변수는 다음과 같습니다:</p>
<pre class="Syntax">GuiContextMenu(GuiHwnd, CtrlHwnd, EventInfo, IsRightClick, X, Y)</pre>
<p>
<em>CtrlHwnd</em>는 콘트롤이 이벤트를 받지 않았으면 비어 있습니다. <em>IsRightClick</em>은  A_GuiEvent가 RightClick이면 참입니다.</p>

<p>
<strong><a name="GuiDropFiles"></a>GuiDropFiles</strong>:  끌어 떨구기 연산의 일부로 파일/폴더가 창에 떨구어질 때마다 기동됩니다 (그러나 라벨이 이미 실행 중이면, 떨구기 이벤트는 무시됩니다). 다음 내장 변수는 GuiDropFiles 안에서 사용가능 합니다:</p>
<ol>
  <li><a href="../Variables.htm#GuiControl">A_GuiControl</a>, 안에 파일이 떨구어진 콘트롤의 <a href="../Variables.htm#GuiControl">텍스트 또는 변수 이름</a>이 담겨 있습니다 (없으면 비어 있음).</li>
  <li><a href="../Variables.htm#EventInfo">A_EventInfo</a> 그리고 <a href="../misc/ErrorLevel.htm">ErrorLevel</a>, 둘 모두 안에 떨구어진 파일의 개수가 담겨 있습니다.</li>
  <li>A_GuiX 그리고 A_GuiY, 안에 파일이 떨구어진 곳의 X좌표와 Y 좌표가 각각 담겨 있습니다 (좌표는 창의 좌상 모서리에 상대적입니다).</li>
  <li>A_GuiEvent, 안에 떨구어진 파일의 이름이 들어 있습니다. 마지막을 제외하고 각각의 파일이름은 라인피드 (`n)로 끝닙니다.</li>
</ol>
<p>개별 파일을 추출하려면, 아래에 보여주는 바와 같이 <a href="LoopParse.htm">파싱 회돌이</a>를 사용하십시오:
</p>
<pre><em>; 예제 #1:</em>
Loop, parse, A_GuiEvent, `n
{
    MsgBox, 4,, File number %A_Index% is:`n%A_LoopField%.`n`nContinue?
    IfMsgBox, No, Break
}

<em>; 예제 #2: 첫 파일만 추출하려면, 다음 예제를 따르십시오:</em>
Loop, parse, A_GuiEvent, `n
{
    FirstFile = %A_LoopField%
    Break
}

<em>; 예제 #3: 알파벳 순으로 파일을 처리하려면, 다음 예제를 따르십시오:</em>
FileList = %A_GuiEvent%
Sort, FileList
Loop, parse, FileList, `n
    MsgBox File number %A_Index% is:`n%A_LoopField%.</pre>
<p>
창에 대하여 끌어 떨구기를 잠시 끄려면, <code>Gui -E0x10</code>를 통하여 WS_EX_ACCEPTFILES 스타일을 제거하십시오. 나중에 다시 활성화하려면, <code>Gui +E0x10</code>를 사용하십시오.</p>
<p>
<span class="ver">[v1.1.20+]:</span> GuiDropFiles이 함수이면, 그 매개변수는 아래 예제에 보여주는 바와 같습니다. <em>CtrlHwnd</em>는 파일이 GUI 자체에 떨구어지면 비어 있습니다. <em>FileArray</em>는파일이름의 <a href="../Objects.htm#Usage_Simple_Arrays">배열 (객체)</a>입니다. 여기에서  <code>FileArray[1]</code>은 첫 번째 파일이고 <code>FileArray.MaxIndex()</code>는 파일의 개수를 돌려줍니다. <a href="For.htm">for-회돌이</a>를 사용하면 파일을 반복할 수 있습니다:</p>

<pre>GuiDropFiles(GuiHwnd, FileArray, CtrlHwnd, X, Y) {
    for i, file in FileArray
        MsgBox File %i% is:`n%file%
}
</pre>

<p><strong>다른 이벤트를 탐지하고 응답하기</strong>: 다른 유형의 GUI 이벤트는 <a href="OnMessage.htm">OnMessage()</a>를 통하여 탐지하고 처리할 수 있습니다. 예를 들어, 사용자가 마우스를 창의 특정 콘트롤에 올려 놓을 때마다 스크립트는 문맥-감지 도움말을 툴팁을 통하여 보여줄 수 있습니다. 이것은 <a href="#ExToolTip">GUI ToolTip 예제</a>에서 시연합니다.</p>

<h2><a name="MultiWin" id="MultiWin"></a>여러 GUI 창 만들기</h2>
<p>
 <a href="#DefaultWin">기본 창</a> 말고 다른 창을 처리하려면, 그의 이름 또는 번호  (또는 v1.1.03+이라면, 그의 <a href="#GuiHwndOutputVar">HWND</a>) 그리고 다음에 쌍점을 두고 부-명령어를 다음 예제와 같이 포함하십시오:</p>

<pre>Gui, <strong>MyGui:</strong>Add, Text,, Text for about-box.
Gui, <strong>MyGui:</strong>Show</pre>
<p>
<code><a href="#Default">Gui MyGui:Default</a></code>을 사용하면 위의 &quot;MyGui:&quot; 접두사가 필요 없습니다. 게다가, 이 접두사는 <a href="#DefaultWin">GUI 쓰레드가</a> 그 쓰레드를 기동한 같은 창에 작동하면 필요가 없습니다.</p>
<p id="Name">
<span class="ver">[v1.1.03+]:</span> Gui 이름은 반드시 <a href="../Variables.htm#Variable_names">변수 이름</a>과 같은 규칙을 지겨야 합니다. 1과 99 사이의 숫자가 아닌 숫자 또는 두 자리 문자보다 더 긴 숫자는 (예를 들어 0x01) 반드시 기존의 Gui의 HWND이어야 합니다. 그렇지 않으면 명령어는 실패합니다. 취급할 수 있는 창의 개수는 운영 체제의 자원에만 제한됩니다.</p>
<p>
<span class="ver">[v1.1.04+]:</span> 이름 없는 GUI 창의 번호는 <a href="#New">Gui, New</a>를 사용하여 만들 수 있습니다.</p>

<h2 id="DefaultWin">GUI 이벤트, 쓰레드, 그리고 서브루틴</h2>
<p>
GUI <a href="../misc/Threads.htm">쓰레드</a>는 GUI 행위의 결과로 기동된 쓰레드로 정의됩니다. GUI 행위에는 GUI 창의 <a href="#Menu">메뉴 바</a>로부터 항목을 선택하는 것, 또는 그의 <a href="#label">g-labels</a>중 하나를 (버튼을 눌러서) 촉발시키는 일이 포함됩니다.</p>
<p>
GUI 쓰레드의 <strong>기본 <a href="#MultiWin">창 이름</a></strong>은 그 쓰레드를 기동한 창의 이름입니다. 비-GUI 쓰레드는 1을 기본 값으로 사용합니다.</p>
<p>
GUI <a href="../misc/Threads.htm">쓰레드</a>가 기동할 때마다, 그 쓰레드의 <a href="../misc/WinTitle.htm#LastFoundWindow">마지막 발견 창</a>은 그 GUI 창 자체로 시작합니다. 이 덕분에 창과 콘트롤에 대한 명령어들이 -- 예를 들어 <a href="WinMove.htm">WinMove</a>, <a href="WinHide.htm">WinHide</a>, <a href="WinSet.htm">WinSet</a>, <a href="WinSetTitle.htm">WinSetTitle</a>, 그리고 <a href="ControlGetFocus.htm">ControlGetFocus</a> 명령어가 --  GUI 창 자신에게 작동할 때는 WinTitle과 WinText를 생략할 수 있습니다 (심지어 숨어 있어도 작동합니다).</p>
<p>
앞에서 클릭해서 그의 <a href="#label">g-label</a>이 이미 실행 중인 동안에 콘트롤을 클릭하면 아무 효과도 없고 그 이벤트는 폐기됩니다. 이를 피하려면, <a href="Critical.htm">Critical</a>을 서브루틴의 첫 줄에 사용하십시오 (그렇지만, 이렇게 하면 핫키 누름과 같이 다른 <a href="../misc/Threads.htm">쓰레드</a>도 버퍼처리 또는 지연될 것입니다.).</p>
<p>
내장 변수 A_Gui와 A_GuiControl 안에는 현재 쓰레드를 기동한 창 이름과 콘트롤 ID가 담겨 있습니다. 더 자세한 것은 <a href="../Variables.htm#Gui">A_Gui</a> 그리고 <a href="../Variables.htm#GuiControl">A_GuiControl</a>를 참조하십시오.</p>
<p>
여러 이벤트가 같은 서브루틴을 수행하도록 만들려면, 라벨들을 연속적으로 서브루틴 위에 지정하십시오. 예를 들어:</p>
<pre>GuiEscape:
GuiClose:
ButtonCancel:
ExitApp  <em>; 위의 모든 라벨은 이것을 수행합니다.</em></pre>
<p>
모든 GUI <a href="../misc/Threads.htm">쓰레드는</a> <a href="SendMode.htm">SendMode</a>와 같은 설정에 대하여 기본 값을 가지고 새롭게 시작합니다. 이 기본 값은 <a href="../Scripts.htm#auto">자동-실행 섹션</a>에서 변경할 수 있습니다.</p>

<h2 id="Navigate">키보드 항해</h2>
<p>
GUI 창은 탭 키로 항해할 수 있습니다. 탭 키는 초점을 다음 입력-가능 콘트롤로 이동시킵니다l (<a href="#Tabstop">Tabstop</a> 스타일이 제거된 콘트롤은 건너 뜁니다). 항해의 순서는 콘트롤이 원래 추가된 순서로 결정됩니다. 창이 처음 보이면, Tabstop 스타일을 가지고 있는 첫 번째 입력-가능 콘트롤이 키보드 초점을 가집니다 (대부분의 콘트롤 유형은 기본으로 탭스탑 스타일을 가지고 있습니다).</p>
<p>
<a name="ShortcutKey"></a>어떤 콘트롤은 키보드 단축키를 만드는 앰퍼센드가 포함되어 있을 수 있습니다 (&amp;). 이 단축 키는 콘트롤의 텍스트에 밑줄 문자로 보여집니다 (시스템 설정에 따라 다름). 사용자는 ALT 키를 누른 채로 상응하는 문자를 타자하여 그 단축키를 활성화 합니다. 버튼, 체크박스, 그리고 라디오 버튼에 대하여, 단축키를 누르는 것은 콘트롤을 클릭하는 것과 동일합니다. GroupBoxes와 Text controls에 대하여, 단축키를 누르면 키보드 초점이 첫 번째 입력-가능 <a href="#Tabstop">tabstop</a> 콘트롤로 점프합니다. 그렇지만 여러 콘트롤이 같은 단축키를 가지고 있는 경우, 단축 키를 누르면 같은 단축키를 가지고 있는 모든 콘트롤 중에 하나를 골라 무작위로 점프합니다.</p>
<p>
앰퍼센드를 글자 그대로 위에 언급한 콘트롤 유형에 보여주려면, 두 개의 앰퍼센드를 연속으로 다음 예제와 같이 지정하십시오: <code>Save &amp;&amp; Exit</code>.</p>

<h2 id="Appear">창의 모습</h2>
<p>
아이콘에 대하여  GUI 창은 창이 만들어지는 순간 효과가 있던 트레이 아이콘을 사용합니다. 그래서, 다른 아이콘을 가지려면, 트레이 아이콘을 바꾸고 나서 창을 만드십시오. 예를 들어: <code><a href="Menu.htm">Menu</a>, Tray, Icon, MyIcon.ico</code>. 또 작은 아이콘 말고 큰 아이콘을 가지는 것도 가능합니다 (큰 아이콘은 알트-탭 태스크 전환기에 보여집니다.). 이것은 DllCall과 SendMessage를 통하여 달성할 수 있습니다; 예를 들어:</p>

<pre>hIcon32 := <a href="DllCall.htm">DllCall</a>(&quot;LoadImage&quot;, uint, 0
    , str, &quot;My Icon.ico&quot;  <em>; 아이콘 파일 (이 파일에 여러 아이콘이 들어 있을 수 있습니다).</em>
    , uint, 1  <em>; 이미지의 종류: IMAGE_ICON</em>
    , int, 32, int, 32  <em>; 이미지의 원하는 너비와 높이 (LoadImage가 어느 아이콘이 제일 좋은지 결정하는 데 도움이 됩니다).</em>
    , uint, 0x10)  <em>; Flags: LR_LOADFROMFILE</em>
Gui +LastFound
<a href="PostMessage.htm">SendMessage</a>, 0x80, 1, hIcon32  <em>; 0x80는 WM_SETICON입니다; 그리고 1은 ICON_BIG이는 뜻입니다 ( 0이면 ICON_SMALL을 의미함).</em>
Gui Show</pre>
<p>
OS의 제한 때문에, 비-기본 텍스트 컬러가 지정된 체크박스, 라디오 버튼, 그리고 그룹박스는 Windows XP 이상에서 고전 테마의 겉모습을 가집니다.</p>
<p>
관련 주제: <a href="#Margin">창의 여백</a>.</p>

<h2 id="GenRemarks">총평</h2>
<p>
<a href="GuiControl.htm">GuiControl</a>과 <a href="GuiControlGet.htm">GuiControlGet</a>을 사용하면 GUI 창의 콘트롤을 개별적으로 처리할 수 있습니다.</p>
<p>
각 GUI 창은 최대 11,000 개의 콘트롤을 가질 수 있습니다. 그렇지만, 5000 개가 넘는 콘트롤을 만들 때 조심하십시오. 왜냐하면 어떤 콘트롤 유형에 대해서는 시스템의 안정성에 문제가 생길 수 있기 때문입니다.</p>
<p>
스크립트 어디서든 GUI 명령어를 사용하면 자동으로 <a href="_Persistent.htm">영속적</a>이 됩니다 (그 GUI 명령어가 실제로 실행되지 않더라도 상관 없습니다). 또 단일 실체이기도 합니다. 단, <a href="_SingleInstance.htm">#SingleInstance</a> 지시어를 사용해 오버라이드 한 경우는 예외입니다.</p>

<h2>관련 항목</h2>
<p>
<a href="GuiControl.htm">GuiControl</a>, <a href="GuiControlGet.htm">GuiControlGet</a>, <a href="Menu.htm">Menu</a>, <a href="GuiControls.htm">콘트롤 유형</a>, <a href="ListView.htm">ListView</a>, <a href="TreeView.htm">TreeView</a>, <a href="Control.htm">Control</a>, <a href="ControlGet.htm">ControlGet</a>, <a href="Progress.htm">SplashImage</a>, <a href="MsgBox.htm">MsgBox</a>, <a href="FileSelectFile.htm">FileSelectFile</a>, <a href="FileSelectFolder.htm">FileSelectFolder</a></p>

<h2 id="Examples">예제</h2>
<pre class="NoIndent"><em>; 예제: SplashTextOn과 비슷한 효과를 얻습니다:</em>

Gui, +AlwaysOnTop +Disabled -SysMenu +Owner  <em>; +Owner를 사용하면 태스크 바 버튼이 보이지 않습니다.</em>
Gui, Add, Text,, Some text to display.
Gui, Show, NoActivate, Title of Window  <em>; NoActivate는 현재 활성 창을 비활성화하지 못하도록 합니다.</em></pre>
<p>&nbsp;</p>
<pre class="NoIndent"><em>; 예제: 이름과 성을 물어 보는 간단한 입력-박스:</em>

Gui, Add, Text,, First name:
Gui, Add, Text,, Last name:
Gui, Add, Edit, vFirstName ym  <em>; ym 옵션은 콘트롤의 새 열을 시작합니다.</em>
Gui, Add, Edit, vLastName
Gui, Add, Button, default, OK  <em>; 라벨 ButtonOK는 (존재하면) 버튼이 눌릴 때 실행됩니다.</em>
Gui, Show,, Simple Input Example
return  <em>; 자동-실행 섹션의 끝. 스크립트는 사용자가 무언가 일을 할 때 까지 휴식 상태에 들어갑니다.</em>

GuiClose:
ButtonOK:
Gui, Submit  <em>; 각 콘트롤의 연관 변수에 사용자의 입력을 저장합니다.</em>
MsgBox You entered &quot;%FirstName% %LastName%&quot;.
ExitApp</pre>
<p>&nbsp;</p>
<pre class="NoIndent"><em>; 예제: 탭 콘트롤:</em>

Gui, Add, Tab2,, First Tab|Second Tab|Third Tab  <em>; Tab2 vs. Tab는 v1.0.47.05를 요구합니다.</em>
Gui, Add, Checkbox, vMyCheckbox, Sample checkbox
Gui, Tab, 2
Gui, Add, Radio, vMyRadio, Sample radio1
Gui, Add, Radio,, Sample radio2
Gui, Tab, 3
Gui, Add, Edit, vMyEdit r5  <em>; r5는 높이가 5 행 이라는 뜻입니다.</em>
Gui, Tab  <em>; 즉, 이어서 추가되는 콘트롤들은 탭 콘트롤에 속하지 않습니다.</em>
Gui, Add, Button, default xm, OK  <em>; xm은 버튼을 좌하 모서리에 배치합니다.</em>
Gui, Show
return

ButtonOK:
GuiClose:
GuiEscape:
Gui, Submit  <em>; 각 콘트롤의 내용을 그의 연관 변수에 저장합니다.</em>
MsgBox You entered:`n%MyCheckbox%`n%MyRadio%`n%MyEdit%
ExitApp</pre>
<p>&nbsp;</p>

<pre class="NoIndent"><em>; 예제: 디렉토리에 있는 파일을 담고 있는 ListBox:</em>

Gui, Add, Text,, Pick a file to launch from the list below.`nTo cancel, press ESCAPE or close this window.
Gui, Add, ListBox, vMyListBox gMyListBox w640 r10
Gui, Add, Button, Default, OK
Loop, C:\*.*  <em>; 이 폴더와 와일드카드 패턴을 여러분의 기호에 맞게 바꾸십시오.</em>
{
    GuiControl,, MyListBox, %A_LoopFileFullPath%
}
Gui, Show
return

MyListBox:
if A_GuiEvent &lt;&gt; DoubleClick
    return
<em>; 그렇지 않으면, 사용자가 리스트 항목을 더블클릭한 것입니다. 그래서 OK를 클릭한 것과 똑같이 취급합니다.
; 그래서 다음 라벨로 빠져 나갑니다.</em>
ButtonOK:
GuiControlGet, MyListBox  <em>; ListBox의 현재 선택을 열람합니다.</em>
MsgBox, 4,, Would you like to launch the file or document below?`n`n%MyListBox%
IfMsgBox, No
    return
<em>; 그렇지 않으면, 기동을 시도합니다:</em>
Run, %MyListBox%,, UseErrorLevel
if ErrorLevel = ERROR
    MsgBox Could not launch the specified file.  Perhaps it is not associated with anything.
return

GuiClose:
GuiEscape:
ExitApp</pre>
<p>&nbsp;</p>

<pre class="NoIndent"><a name="ExToolTip"></a><em>; 예제: 사용자가 마우스를 특정 콘트롤에 올려 놓을 때마다 (툴팁을 통하여) 문맥-감지 도움말을 보여줍니다:</em>

Gui, Add, Edit, v<strong>MyEdit</strong>
<strong>MyEdit</strong>_TT := &quot;This is a tooltip for the control whose variable is MyEdit.&quot;
Gui, Add, DropDownList, v<strong>MyDDL</strong>, Red|Green|Blue
<strong>MyDDL</strong>_TT := &quot;Choose a color from the drop-down list.&quot;
Gui, Add, Checkbox, vMyCheck, This control has no tooltip.
Gui, Show
<a href="OnMessage.htm">OnMessage</a>(0x200, &quot;WM_MOUSEMOVE&quot;)
return

WM_MOUSEMOVE()
{
    static CurrControl, PrevControl, _TT  <em>; _TT는 아래의 ToolTip 명령어에 사용하기 위해 빈 상태를 유지합니다.</em>
    CurrControl := A_GuiControl
    If (CurrControl &lt;&gt; PrevControl and not InStr(CurrControl, &quot; &quot;))
    {
        ToolTip  <em>; 이전의 툴팁을 모두 끕니다.</em>
        SetTimer, DisplayToolTip, 1000
        PrevControl := CurrControl
    }
    return

    DisplayToolTip:
    SetTimer, DisplayToolTip, Off
    <a href="ToolTip.htm">ToolTip</a> % %CurrControl%_TT  <em>; 앞의 퍼센트 사인은 표현식을 사용하라고 알립니다.</em>
    SetTimer, RemoveToolTip, 3000
    return

    RemoveToolTip:
    SetTimer, RemoveToolTip, Off
    ToolTip
    return
}


GuiClose:
ExitApp</pre>
<p>&nbsp;</p>
<pre class="NoIndent"><a name="OSD"></a><em>; 예제: 투명 창을 통한 화면-위 디스플레이 (OSD):</em>

CustomColor = EEAA99  <em>; RGB 색 가능 (아래에서 투명하게 만들 것입니다).</em>
Gui +LastFound +AlwaysOnTop -Caption +ToolWindow  <em>; +ToolWindow는 태스크바 버튼과 알트-탭 메뉴 항목을 회피합니다.</em>
Gui, Color, %CustomColor%
Gui, Font, s32  <em>; 커다란 글꼴 크기를 설정합니다 (32-포인트).</em>
Gui, Add, Text, vMyText cLime, XXXXX YYYYY  <em>; XX &amp; YY는 자동-크기 조절 창으로 기여합니다.
; 이 색을 가진 모든 픽셀을 투명하게 만들고 텍스트 자체는 반투명하게 만듭니다 (150):</em>
WinSet, TransColor, %CustomColor% 150
SetTimer, UpdateOSD, 200
Gosub, UpdateOSD  <em>; 타이머를 기다리지 않고 먼저 즉시 갱신합니다.</em>
Gui, Show, x0 y400 NoActivate  <em>; NoActivate는 현재 활성 창을 비활성화하지 못하도록 막습니다.</em>
return

UpdateOSD:
MouseGetPos, MouseX, MouseY
GuiControl,, MyText, X%MouseX%, Y%MouseY%
return</pre>
<p>&nbsp;</p>
<pre class="NoIndent"><em>; 예제: 배경 이미지 위에 중첩된 움직이는 진도 바.</em>

Gui, Color, White
Gui, Add, Picture, x0 y0 h350 w450, %A_WinDir%\system32\ntimage.gif
Gui, Add, Button, Default xp+20 yp+250, Start the Bar Moving
Gui, Add, Progress, vMyProgress w416
Gui, Add, Text, vMyText wp  <em>; wp는 &quot;이전의 너비를 사용하라&quot;는 뜻입니다.</em>
Gui, Show
return

ButtonStartTheBarMoving:
Loop, %A_WinDir%\*.*
{
    if A_Index &gt; 100
        break
    GuiControl,, MyProgress, %A_Index%
    GuiControl,, MyText, %A_LoopFileName%
    Sleep 50
}
GuiControl,, MyText, Bar finished.
return

GuiClose:
ExitApp</pre>
<p>&nbsp;</p>
<pre class="NoIndent"><em>; 예제: 간단한 이미지 뷰어:</em>

Gui, +Resize
Gui, Add, Button, default, &amp;Load New Image
Gui, Add, Radio, ym+5 x+10 vRadio checked, Load &amp;actual size
Gui, Add, Radio, ym+5 x+10, Load to &amp;fit screen
Gui, Add, Pic, xm vPic
Gui, Show
return

ButtonLoadNewImage:
FileSelectFile, file,,, Select an image:, Images (*.gif; *.jpg; *.bmp; *.png; *.tif; *.ico; *.cur; *.ani; *.exe; *.dll)
if file =
    return
Gui, Submit, NoHide <em>; 라디오 버튼의 값을 저장합니다.</em>
if Radio = 1  <em>; 이미지를 그의 실제 크기로 보여줍니다.</em>
{
    Width = 0
    Height = 0
}
else <em>; Second radio is selected: 이미지를 화면 크기에 맞게 조절합니다.</em>
{
    Width := A_ScreenWidth - 28  <em>; 마이너스 28 만큼 테투리와 여백 안에  여유가 있습니다.</em>
    Height = -1  <em>; &quot;화면 비율 유지&quot;가 가장 좋아 보입니다.</em>
}
GuiControl,, Pic, *w%width% *h%height% %file%  <em>; 이미지를 적재합니다.</em>
Gui, Show, xCenter y0 AutoSize, %file%  <em>; 그림 크기에 맞게 창을 조절합니다.</em>
return

GuiClose:
ExitApp</pre>
<p>&nbsp;</p>
<pre class="NoIndent"><em>; 예제: 메뉴 바가 있는 간단한 텍스트 편집기.</em>

<em>; 메뉴 바를 위하여 부-메뉴를 생성합니다:</em>
Menu, FileMenu, Add, &amp;New, FileNew
Menu, FileMenu, Add, &amp;Open, FileOpen
Menu, FileMenu, Add, &amp;Save, FileSave
Menu, FileMenu, Add, Save &amp;As, FileSaveAs
Menu, FileMenu, Add  <em>; Separator line.</em>
Menu, FileMenu, Add, E&amp;xit, FileExit
Menu, HelpMenu, Add, &amp;About, HelpAbout

<em>; 부-메뉴를 메뉴 바에 부착해 메뉴 바를 생성합니다:</em>
Menu, MyMenuBar, Add, &amp;File, :FileMenu
Menu, MyMenuBar, Add, &amp;Help, :HelpMenu

<em>; 메뉴 바를 창에 부착합니다:</em>
Gui, Menu, MyMenuBar

<em>; 메인 편집 콘트롤을 생성하고 그 창을 보여줍니다:</em>
Gui, +Resize  <em>; 창을 크기가 변경가능하게 만듭니다.</em>
Gui, Add, Edit, vMainEdit WantTab W600 R20
Gui, Show,, Untitled
CurrentFileName =  <em>; 현재 파일이 없음을 나타냅니다.</em>
return

FileNew:
GuiControl,, MainEdit  <em>; 편집 콘트들을 비웁니다.</em>
return

FileOpen:
Gui +OwnDialogs  <em>; 사용자가 FileSelectFile 대화상자를 포기하도록 만들고 나서 메인 창으로 되돌아 옵니다.</em>
FileSelectFile, SelectedFileName, 3,, Open File, Text Documents (*.txt)
if SelectedFileName =  <em>; No file selected.</em>
    return
Gosub FileRead
return

FileRead:  <em>; 호출자는 변수 SelectedFileName을 우리 대신에 설정합니다.</em>
FileRead, MainEdit, %SelectedFileName%  <em>; 파일의 내용을 변수 안으로 읽어 들입니다.</em>
if ErrorLevel
{
    MsgBox Could not open &quot;%SelectedFileName%&quot;.
    return
}
GuiControl,, MainEdit, %MainEdit%  <em>; 텍스트를 콘트롤 안에 넣습니다.</em>
CurrentFileName = %SelectedFileName%
Gui, Show,, %CurrentFileName%   <em>; 파일 이름을 제목 바에 보여줍니다.</em>
return

FileSave:
if CurrentFileName =   <em>; 아직 파일이름이 선택되지 않았습니다. 그래서 대신 Save-As를 수행합니다.</em>
    Goto FileSaveAs
Gosub SaveCurrentFile
return

FileSaveAs:
Gui +OwnDialogs  <em>; 사용자가 FileSelectFile 대화상자를 포기하도록 만들고 메인 창으로 돌아옵니다.</em>
FileSelectFile, SelectedFileName, S16,, Save File, Text Documents (*.txt)
if SelectedFileName =  <em>; 파일이 선택되지 않았습니다.</em>
    return
CurrentFileName = %SelectedFileName%
Gosub SaveCurrentFile
return

SaveCurrentFile:  <em>; 호출자는 CurrentFileName이 비어 있지 않음을 확인합니다.</em>
IfExist %CurrentFileName%
{
    FileDelete %CurrentFileName%
    if ErrorLevel
    {
        MsgBox The attempt to overwrite &quot;%CurrentFileName%&quot; failed.
        return
    }
}
GuiControlGet, MainEdit  <em>; 편집 콘트롤의 내용을 열람합니다.</em>
FileAppend, %MainEdit%, %CurrentFileName%  <em>; 내용을 파일에 저장합니다.
; 성공하면, 파일 이름을 제목 바에 보여줍니다 (FileSaveAs에 의하여 호출되는 경우):</em>
Gui, Show,, %CurrentFileName%
return

HelpAbout:
Gui, About:+owner1  <em>; 메인 창을 (Gui #1) &quot;about box&quot;의 소유자로 만듭니다.</em>
Gui +Disabled  <em>; 메인 창을 비활성화 합니다.</em>
Gui, About:Add, Text,, Text for about box.
Gui, About:Add, Button, Default, OK
Gui, About:Show
return

AboutButtonOK:  <em>; 이 섹션은 위의 &quot;about box&quot;가 사용합니다.</em>
AboutGuiClose:
AboutGuiEscape:
Gui, 1:-Disabled  <em>; 메인 창을 다시 활성화 합니다 (다음 단계로 나아가기 전에 반드시 활성화 해야 함).</em>
Gui Destroy  <em>; about box를 파괴합니다.</em>
return

GuiDropFiles:  <em>; 끌어 &amp; 떨구기를 지원합니다.</em>
Loop, Parse, A_GuiEvent, `n
{
    SelectedFileName = %A_LoopField%  <em>; 첫 번째 파일만 얻습니다 (여러 파일이 있을 경우에).</em>
    break
}
Gosub FileRead
return

GuiSize:
if ErrorLevel = 1  <em>; 창은 최소화되어 있습니다. 아무 필요도 없습니다.</em>
    return
<em>; 그렇지 않으면, 창은 크기가 변경되거나 최대화됩니다. 편집 콘트롤의 크기를을 그에 맞게 조절합니다.</em>
NewWidth := A_GuiWidth - 20
NewHeight := A_GuiHeight - 20
GuiControl, Move, MainEdit, W%NewWidth% H%NewHeight%
return

FileExit:     <em>; 사용자가 File 메뉴에서 &quot;Exit&quot;을 선택했습니다.</em>
GuiClose:  <em>; 사용자가 창을 닫았습니다.</em>
ExitApp</pre>
</body>
</html>
