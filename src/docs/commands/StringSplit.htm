

<html>
<head>
<title>StringSplit / StrSplit()</title>
<meta http-equiv="Content-Type" content="text/html; charset=euc-kr">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<link href="../static/theme.css" rel="stylesheet" type="text/css" />
<script src="../static/content.js" type="text/javascript"></script>
</head>
<body>

<h1>StringSplit / StrSplit()</h1>

<p>문자열을 지정된 구분자로 갈라 부문자열의 배열로 만듭니다.</p>

<pre class="Syntax">StringSplit, OutputArray, InputVar [, Delimiters, OmitChars]
Array := StrSplit(String [, Delimiters, OmitChars])  <em>; [v1.1.13+]</em></pre>
<h3>Parameters</h3>
<h4>StringSplit</h4>
<dl>

  <dt>OutputArray</dt>
  <dd><p><em>InputVar</em>로부터 추출된 각 부문자열을 저장할 <a href="../misc/Arrays.htm#pseudo">의사-배열</a>의 이름. 예를 들어, MyArray가 지정되면, 이 명령어는 생산된 부문자열의 개수를 (없으면 0) MyArray0에 배치합니다. 첫 번째 부분자열은 MyArray1에, 두 번째 부문자열은 MyArray2에, 등등 배치합니다.</p>
  <p>
  <a href="../Functions.htm">함수</a> 안에서, 지역이 아니라 전역적인 의사-배열을 생성하려면, 함수 안에서 MyArray0를 전역 변수로 <a href="../Functions.htm#Global">선언</a>하십시오 (<a href="../Functions.htm#AssumeGlobal">전역-간주</a> 함수에 대하여 그 반대도 마찬가지입니다). 그렇지만, <a href="../Functions.htm#ArrayConfusion">흔한 혼란의 근원</a> 때문에, 각 원소마다 따로따로 선언해야 할 경우도 종종 있습니다. 더 자세한 정보는 <a href="../Functions.htm#PseudoArrays">함수</a>를 참조하십시오.</p></dd>

  <dt>InputVar</dt>
  <dd><p>내용을 분석할 변수의 이름. 이름을 퍼센트 사인으로 둘러 싸지 마십시오. 단, 변수의  <em>내용</em>이 이름으로 사용되기를 원하는 경우라면 예외입니다. 주의: <em>InputVar</em>는 <em>OutputArray</em> 안에 있는 변수 중 하나가 되어야 합니다.</p></dd>

  <dt>Delimiters</dt>
  <dd><p>
  이 매개변수가 비어 있거나 생략되면, <em>InputVar</em>의 각 문자는 별도의 부문자열로 간주됩니다.</p>
      <p>그렇지 않으면, <em>Delimiters</em>는 하나 이상의 문자를 담습니다 (대소문자 구분). 각 구분자는 <em>InputVar</em>에서 부문자열 사이의 경계가 나타나는 곳을 결정하는 데 사용됩니다. 구분 문자들은 부문자열의 일부분으로 간주되지 않기 때문에, <em>OutputArray</em>에 절대로 복사되지 않습니다. 또한, <em>InputVar</em> 안에서 구분자 사이에 아무 것도 없으면, 그에 상응하는 원소는 빈 원소입니다.</p>      
      <p>
	  예를 들어: <code>`,</code> (피신된 쉼표)는 쉼표가 나타날 때마다 문자열을 분리합니다. 비슷하게, <code>%A_Tab%%A_Space%</code>는 <em>InputVar</em> 안에서 스페이스나 탭을 만날 때마다 새로운 배열 원소를 생성합니다.</p>
      <p>
	  문자열을 문자가 아니라 구분자로 사용하려면, 먼저 <a href="StringReplace.htm">StringReplace</a>를 사용해 그 문자열이 나타나면 모두, 텍스트에서 절대로 기호 그대로 사용되지 않는 하나의 문자로 교체하십시오. 다음 예제를 연구해 보십시오. 다음 예제는 문자열 &lt;br&gt;을 구분자로 사용합니다:</p>

<pre>StringReplace, NewHTML, HTMLString, &lt;br&gt;, ``, All  <em>; &lt;br&gt;이 나타날 때마다 액센트 문자로 바꿉니다.</em>
StringSplit, MyArray, NewHTML, ``  <em>; 액센트 문자에 기반해 문자열을 가릅니다.</em></pre></dd>

</dl>

<h4>StrSplit() <span class="ver">[v1.1.13+]</span></h4>
<dl>

  <dt>Array<br>(반환 값)</dt>
  <dd><p>문자열 (객체)의 <a href="../Objects.htm#Usage_Simple_Arrays">배열</a>.</p></dd>

  <dt>String</dt>
  <dd><p>분리할 문자열.</p></dd>

  <dt>Delimiters</dt>
  <dd><p>이 매개변수가 비어 있거나 생략되면, 입력 문자열의 각 문자는 별도의 부문자열로 간주됩니다.</p>
      <p>그렇지 않으면, <em>Delimiters</em>는 단일 문자열이거나 문자열 배열일 수 있습니다. 각 구분자는 부문자열 사이의 경계가 나타나는 곳을 결정하는데 사용됩니다. 구분자는 부문자열의 일부분으로 간주되지 않으므로, 절대로 반환된 배열에 포함되지 않습니다. 또한, 입력 문자열에서 구분자 한 쌍 사이에 아무것도 없다면, 그에 상응하는 배열 원소는 빈 원소입니다.</p>      
      <p>
	  예를 들어: <code>&quot;,&quot;</code>는 문자열을 쉼표가 나타날 때마다 분리합니다. 비슷하게, <code>[A_Tab, A_Space]</code>는 입력 문자열에서 스페이스나 탭을 만날 때마다 새 배열 원소를 생성합니다.</p></dd>

</dl>
<h4>Both</h4>
<dl>

  <dt>OmitChars</dt>
  <dd><p>각 배열 원소의 앞과 뒤로부터 배제할 문자열의 리스트 (대소문자 구분, 선택적). 예를 들어, <em>OmitChars</em>가 <code>%A_Space%%A_Tab%</code> (StringSplit) 또는 <code>" `t"</code> (StrSplit)이면, 스페이스와 탭은 모든 원소의 앞과 뒤로부터 제거됩니다 (가운데는 아님).</p>
    <p>
	<em>Delimiters</em>가 비어 있으면, <em>OmitChars</em>는 배열로부터 어느 문자를 배제해야 하는지를 나타냅니다.</p>
    <p>
	대부분의 다른 명령어의 마지막 매개변수와 다르게, StringSplit에 대하여 <em>OmitChars</em>에서 쉼표는 반드시 피신시켜야 합니다 (`,).</p></dd>

</dl>

<h3>논평</h3>
<p>
의사 배열이 이미 존재하면, StringSplit 명령어는 앞쪽부터 N개의 원소의 값만 변경합니다. 여기에서  N은 <em>InputVar</em>에서 출현하는 부문자열의 개수입니다. N 번째 이후의 원소는 변경되지 않습니다. 그러므로, 얼마나 많은 항목이 실제로 이 명령어로 생산되었는가를 알아내려면, 0 원소를 사용하는 것이 가장 안전합니다 (MyArray0). </p>
<p>
스페이스와 탭 같은 공백 문자들은 유지됩니다. 단, 그 문자 자체가 구분자이거나 <em>OmitChars</em>에 포함되는 경우는 예외입니다. 탭과 스페이스는 <a href="Trim.htm">Trim</a> 함수를 호출해 변수의 양쪽 끝으로부터 다듬을 수 있습니다. 예를 들어: <code>MyArray1 := Trim(MyArray1)</code>.</p>
<p>
표준 CSV (쉼표로 가른 값(comma separated value)) 형식의 문자열을 가르려면, <a href="LoopParse.htm">파싱 회돌이</a>를 사용하십시오. CSV 처리가 내장되어 있습니다.</p>
<p>
문자열을 가르기 전에 필드를 다른 순서로 정렬하려면, <a href="Sort.htm">Sort</a> 명령어를 사용하십시오.</p>
<p>
부문자열을 메모리에 영원히 저장할 필요가 없다면, <a href="LoopParse.htm">파싱 회돌이</a>의 사용을 고려해 보십시오 -- 특히 <em>InputVar</em>가 매우 방대하다면 꼭 고려해 보시기를 바랍니다. 그런 경우는 방대한 양의 메모리가 저장될 것입니다. 예를 들어:</p>

<pre>Colors = red,green,blue
Loop, parse, Colors, `,
    MsgBox Color number %A_Index% is %A_LoopField%.</pre>

<h3>관련 항목</h3>
<p><a href="LoopParse.htm">파싱 회돌이</a>, <a href="../misc/Arrays.htm">배열</a>, <a href="Sort.htm">Sort</a>, <a href="SplitPath.htm">SplitPath</a>, <a href="IfInString.htm">IfInString</a>, <a href="StringGetPos.htm">StringGetPos</a>, <a href="StringMid.htm">StringMid</a>, <a href="StringTrimLeft.htm">StringTrimLeft</a>, <a href="StringTrimLeft.htm">StringTrimRight</a>, <a href="StringLen.htm">StringLen</a>, <a href="StringLower.htm">StringLower</a>, <a href="StringLower.htm">StringUpper</a>, <a href="StringReplace.htm">StringReplace</a></p>

<h3>예제</h3>
<pre class="NoIndent">TestString = This is a test.
StringSplit, word_array, TestString, %A_Space%, .  <em>; 점은 제외합니다.</em>
MsgBox, The 4th word is %word_array4%.

Colors = red,green,blue
StringSplit, ColorArray, Colors, `,
Loop, %ColorArray0%
{
    this_color := ColorArray%a_index%
    MsgBox, Color number %a_index% is %this_color%.
}</pre>
<pre class="NoIndent">TestString := "This is a test."
word_array := StrSplit(TestString, A_Space, ".")  <em>; 점은 제외합니다.</em>
MsgBox % "The 4th word is " word_array[4]

Colors := "red,green,blue"
ColorArray := StrSplit(Colors, ",")
Loop % ColorArray.MaxIndex()
{
    this_color := ColorArray[a_index]
    MsgBox, Color number %a_index% is %this_color%.
}</pre>

</body>
</html>
