<html>
<head>
<title>RegExMatch</title>
<meta http-equiv="Content-Type" content="text/html; charset=euc-kr">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<link href="../static/theme.css" rel="stylesheet" type="text/css" />
<script src="../static/content.js" type="text/javascript"></script>
</head>
<body>

<h1>RegExMatch() <span class="ver">[v1.0.45+]</span></h1>

<p>문자열에 패턴이 담겨 있는지 알아냅니다 (정규 표현식).</p>

<pre class="Syntax">FoundPos := RegExMatch(Haystack, NeedleRegEx [, UnquotedOutputVar = &quot;&quot;, StartingPosition = 1])</pre>
<h3>매개변수</h3>
<p>
<b>역주</b> : 정규표현식으로  목표 문자열에서 패턴을 찾는 것을<br>
건초더미(<em>Haystack</em>)에서 바늘(<em>NeedleRegEx</em>)을 찾는 것에비유함.
</p>
<dl>
  <dt>FoundPos</dt>
  <dd><p>RegExMatch()는 문자열 <em>Haystack</em>에 <em>NeedleRegEx</em>가 나타난 가장 왼쪽의 위치를 돌려줍니다. 위치가 1이면 첫 번째 문자입니다. 패턴이 발견되지 않으면 0을 돌려줍니다. 에러가 일어나면 (<em>NeedleRegEx</em> 안에서 구문 에러가 일어나면), 빈 문자열이 반환됩니다. ErrorLevel은 0 대신에 <a href="#ErrorLevel">아래의</a> 값 중 하나가 사용됩니다.</p></dd>

  <dt>Haystack</dt>
  <dd><p>내용을 검색할 문자열.</p></dd>

  <dt>NeedleRegEx</dt>
  <dd><p>검색 할 패턴, 펄-호환의 정규 표현식입니다 (PCRE). 패턴의 <a href="../misc/RegEx-QuickRef.htm#Options">옵션</a>은 문자열 처음에 포함해야 하고 그 다음에 닫는 반괄호가 따라 옵니다. 예를 들어, 패턴 &quot;<span class="red">i)</span>abc.*123&quot;는 대소문자 비구분 옵션을 켜고 &quot;abc&quot;를 검색 한 다음, 0개 이상의 문자를 검색하고, 다음에 &quot;123&quot;을 검색합니다. 옵션이 없다면, &quot;)&quot;는 선택적입니다; 예를 들어, &quot;)abc&quot;는 &quot;abc&quot;와 동등합니다.</p></dd>

  <dt>UnquotedOutputVar</dt>
  <dd><p><strong>Mode 1 (기본값):</strong> <em>OutputVar</em>는 한 따옴표를 제거한 변수입니다. 그 안에다 전체 패턴에 부합한 <em>Haystack</em> 부분을 저장합니다. 패턴이 발견되지 않으면 (즉, 함수가 0을 돌려주면), 이 변수와 모든 배열 원소는 비워집니다.</p>
      <p><a name="Array"></a><a href="../misc/RegEx-QuickRef.htm#subpat">나포 부패턴</a>이 <em>NeedleRegEx</em> 안에 존재하면, 그에 부합한 것들은 바탕 이름이 <em>OutputVar</em>인 <a href="../misc/Arrays.htm#pseudo">의사-배열</a>에 저장됩니다.  예를 들어, 변수의 이름이 <em>Match</em>라면, 첫 부패턴에 부합하는 부문자열은 <em>Match1</em>에 저장되고, 두 번째는 <em>Match2</em>에 저장됩니다, 등등. 이에 대한 예외는 <a href="#NamedSubPat">이름 붙인 부패턴</a>입니다: 숫자가 아니라 이름으로 저장됩니다. 예를 들어, 이름붙인 부패턴&quot;(?P&lt;Year&gt;\d{4})&quot; 에 부합한 부문자열은 <em>MatchYear</em>에 저장됩니다. 특정한 부패턴이 전혀 부합하지 않으면 (즉, 함수가 0을 돌려주면), 그에 상응하는 변수는 비워집니다.</p>
      <p><a href="../Functions.htm">함수</a> 안에서, 지역이 아닌 전역 의사 배열을 생성하려면, 의사 배열의 바탕 이름을 사용하기 전에 (예, Match) 전역 변수로 <a href="../Functions.htm#Global">선언</a> 하십시오. <a href="../Functions.htm#AssumeGlobal">전역-간주</a> 함수에 대하여 그 반대도 마찬가지입니다. 그렇지만, <a href="../Functions.htm#ArrayConfusion">흔한 혼란의 근원</a> 때문에 각 원소마다 선언할 필요가 있는 경우도 있습니다.</p>
      <p><a name="PosMode"></a><strong>Mode 2 (위치와 길이):</strong> 대문자 P가 RegEx의 옵션에 존재하면 -- 예를 들어 &quot;<span class="red">P)</span>abc.*123&quot; --전체 패턴 부합의 <em>길이</em>가 <em>OutputVar</em>에 저장됩니다 (부합이 없으면 0). <a href="../misc/RegEx-QuickRef.htm#subpat">나포 부패턴</a>이 존재하면, 그 위치와 길이가 두 개의 <a href="../misc/Arrays.htm#pseudo">의사-배열</a>에 저장됩니다: <em>OutputVarPos</em> 그리고 <em>OutputVarLen</em>. 예를 들어, 변수의 바탕 이름이 <em>Match</em>라면, 첫 부패턴 부합의 <em>위치</em>가 1-기반으로 <em>MatchPos1</em>에 저장되고, 그의 길이는 <em>MatchLen1</em>에 저장됩니다 (부패턴에 부합이 없거나 함수가 0을 돌려주면 0이 저장됩니다).  이에 대한 예외는 <a href="#NamedSubPat">이름붙인 부패턴</a>입니다: 숫자가 아니라 이름으로 저장됩니다 (예, <em>MatchPosYear</em> 그리고 <em>MatchLenYear</em>).</p>
      <p id="ObjectMode"><strong>Mode 3 (일치 객체)</strong> <span class="ver">[v1.1.05+]</span><strong>:</strong> 대문자 O가 RegEx 옵션에 존재하면 -- 예를 들어 &quot;<span class="red">O)</span>abc.*123&quot; -- <a href="#MatchObject">일치 객체</a>가 <em>UnquotedOutputVar</em>에 저장됩니다. 이 객체를 사용하면 전체 부합과 <a href="../misc/RegEx-QuickRef.htm#subpat">나포된 부패턴</a> 각각의 위치와 길이 그리고 값을 열람할 수 있습니다.</p>
    </dd>

  <dt>StartingPosition</dt>
  <dd><p><em>StartingPosition</em>을 생략하면 기본값은 1입니다 (<em>Haystack</em>의 시작). 그렇지 않으면,  2를 지정해 두 번째 문자에서 시작하거나 3을 지정해 세 번째 문자에서 시작할 수 있습니다. 등등. <em>StartingPosition</em>이 <em>Haystack</em>의 길이를 넘어 가면, 검색은  <em>Haystack</em> 끝의 빈 문자열에서 시작합니다 (전형적으로 부합 결과가 없습니다).</p>
      <p><em>StartingPosition</em>이 보다 작으면, <em>Haystack</em> 끝으로부터의 상대거리고 간주합니다. 예를 들어, 0은 마지막 문자에서 시작하고,  -1은 마지막 문자 바로 앞에서 시작합니다.  <em>StartingPosition</em>이 <em>Haystack</em>의 왼쪽 끝을 넘어서 시도하면, 모든 <em>Haystack</em>을 검색합니다.</p>
      <p><em>StartingPosition</em>의 값에 상관없이, 반환 값은 언제나 <em>Haystack</em>의 첫 문자에 상대적입니다. 예를 들어,  &quot;123abc789&quot;에서 &quot;abc&quot;의 위치는 언제나 4입니다.</p></dd>

</dl>
<h3 id="ErrorLevel">ErrorLevel</h3>
<p><span class="ver">[v1.1.04+]</span> 이 함수는 실패시 예외를 던질 수 있습니다 (&quot;부합 없음&quot;과 혼동하지 마십시오). 더 자세한 정보는 <a href="Catch.htm#RuntimeErrors">실행시간 에러</a>를 참조하십시오.</p>
<p><a href="../misc/ErrorLevel.htm">ErrorLevel</a>은 다음 값중 하나가 설정됩니다:</p>
<ul>
  <li>0, 에러가 일어나지 않았다는 뜻입니다.</li>
  <li>다음과 같은 형태의 문자열: <em>Compile error N at offset M: description</em>. 이 문자열에서, <em>N</em>은 PCRE 에러 번호이고, <em>M</em>은 정규 표현식 안에서의 범칙 문자의 위치입니다. 그리고 <em>description</em>은 그 에러를 설명하는 텍스트입니다.</li>
  <li>음의 정수, 정규 표현식을 <em>실행</em>하는 동안에 에러가 일어났다는 뜻입니다. 그런 에러가 자주 일어나지는 않지만 일어난다면 다음과 같은 에러가 거의 대부분입니다: &quot;too many possible empty-string matches&quot; (-22), &quot;recursion too deep&quot; (-21), 그리고 &quot;reached match limit&quot; (-8). 이런 에러가 일어나면, 패턴을 더 엄격하게 재설계하십시오. 예를 들어 *를 ?, +로 교체하거나 가능하면 {0,3}과 같이 제한하십시오.</li>
</ul>
<h3>Options</h3>
<p>수식자에 관해서 <a href="../misc/RegEx-QuickRef.htm#Options">Options</a>를 참조하십시오. 예를 들어 &quot;<span class="red">i)</span>abc&quot;와 같은 경우, 패턴 &quot;abc&quot;에 대소문자 구분을 끕니다.</p>

<h3 id="MatchObject">Match Object <span class="ver">v1.1.05+</span></h3>
<p>
대문자 O가 RegEx 옵션에 존재하면, 일치 객체가 <em>UnquotedOutputVar</em>에 저장됩니다. 이 객체는 다음과 같은 특성을 소유합니다:</p>
<p>
<strong>Match.Pos(N)</strong>: 나포된 부패턴 또는 전체 부합의 위치를 돌려줍니다.</p>
<p><strong>Match.Len(N)</strong>: 나포된 부패턴 또는 전체 부합의 길이를 돌려줍니다.</p>
<p><strong>Match.Value(N)</strong>: 나포된 부패턴 또는 전체 부합을 돌려줍니다.</p>
<p><strong>Match.Name(N)</strong>: 주어진 부패턴의 이름을 돌려줍니다</p>
<p><strong>Match.Count()</strong>: 부패턴의 전체 개수를 돌려줍니다.</p>
<p><strong>Match.Mark()</strong>: 마지막으로 만난 <code>(*MARK:NAME)</code>의 <em>NAME</em>을 돌려줍니다.</p>
<p><strong>Match[N]</strong>: <em>N</em>이 0이거나 유효한 부패턴 번호 또는 이름이라면, 이것은 <code>Match.Value(N)</code>과 동등합니다. 그렇지 않으면, <em>N</em>은 위의 특성의 이름 중 하나일 수 있습니다. 예를 들어, <code>Match[&quot;Pos&quot;]</code> 그리고 <code>Match.Pos</code>는 <code>Match.Pos()</code>와 동등합니다. 단, 이름이 &quot;Pos&quot;인 부패턴이 존재하면 예외입니다. 이 경우 <code>Match.Value("Pos")</code>와 동등합니다.</p>
<p><strong>Match.N</strong>: 위와 같습니다. 단, <em>N</em>이 인용부호를 붙이지 않은 이름이거나 숫자인 경우는 예외입니다.</p>
<p>위의 모든 특성에 대하여, <em>N</em>은 다음 중 하나가 될 수 있습니다:</p>
<ul>
  <li>모든 부합하면 0.</li>
  <li>부패턴의 번호, 이름붙은 부패턴도 마찬가지.</li>
  <li>부패턴의 이름.</li>
</ul>
<p><em>N</em>을 지정하면 반괄호 () 대신에 각괄호 []를 사용해도 됩니다.</p>

<h3>수행성능</h3>
<p>문자열 안에서 간단한 부문자열을 검색하려면 <a href="../Functions.htm#InStr">InStr()</a>을 사용하십시오. 왜냐하면 RegExMatch()보다 더 빠르기 때문입니다.</p>
<p>수행성능을 개선하기 위하여, 자주 사용되는 정규 표현식 100개를 메모리에 (컴파일된 형태로) 캐쉬합니다.</p>
<p><a href="../misc/RegEx-QuickRef.htm#Study">연구 옵션 (S)</a>으로 종종 (예를 들어 회돌이 안에서) 많이 사용되는 정규 표현식의 수행성능을 개선시킬 수 있습니다.</p>

<h3>논평</h3>
<p>
<a name="NamedSubPat"></a>부패턴에 이름을 부여할 수 있습니다. 예를 들어 패턴 &quot;(?P&lt;Year&gt;\d{4})&quot;에 단어 <em>Year</em>가 부여 되어 있습니다. 이름은 최대 32개의 알파벳숫자와 밑줄 문자로 구성되니다. 다음 제한은  &quot;O&quot; (일치 객체) 모드에 적용되지 않습니다. 이름 붙인 부패턴도 RegEx 연산 자체에서 숫자로 참조할 수 있지만 (예, \1은 첫 나포 패턴에 실제로 부합한 문자열을 가리키는 역참조입니다), (숫자가 아니라) <em>이름으로만</em> <a href="#Array">출력 의사-변수</a>에 저장됩니다. 예를 들어, &quot;Year&quot;가 첫 번째 부패턴이라면, <em>OutputVarYear</em>은 그 부합한 부문자열이 설정되지만, <em>OutputVar1</em>은 전혀 바뀌지 않습니다 (이전 값을 그대로 유지합니다). 그렇지만, <a href="../misc/RegEx-QuickRef.htm#subpat">이름없는 부패턴</a>이 &quot;Year&quot; 다음에 일어나면, 그것은 <em>OutputVar1</em>이 아니라 <em>OutputVar2</em>에 저장됩니다.</p>
<p>
abc123와 같이 대부분의 문자는 정규 표현식 안에 기호 그대로 사용할 수 있습니다. 그렇지만,  <strong>\.*?+[{|()^$</strong>와 같은 문자는 반드시 앞에 역사선을 배치해야 문자 그대로 보여지게 됩니다. 예를 들어, <strong>\.</strong>는 문자 그대로의 점이고 <strong>\\</strong>는 기호 그대로의 역사선입니다. 피신은 \Q...\E을 사용하여 대신할 수 있습니다. 예를 들어: <code>\QLiteral Text\E</code>.</p>
<p>
정규 표현식 안에서, 탭과 새줄 같은 특수 문자들은 액센트 (`) 또는 역사선 (\)으로 피신시킬 수 있습니다. 예를 들어, `t는 \t와 같습니다. 단, <b>x</b> 옵션이 사용된 경우는 예외입니다.</p>
<p>
정규 표현식의 기본을 배우려면 (또는 패턴 구문을 새롭게 기억해 보려면), <a href="../misc/RegEx-QuickRef.htm">RegEx 간편 참조서</a>를 참조하십시오.</p>
<p>
오토핫키의 정규 표현식은 펄-호환의 정규 표현식 (PCRE)을 사용하여 구현되었습니다: <a href="http://www.pcre.org/">www.pcre.org</a>.</p>

<h3>관련 항목</h3>
<p>
<a href="RegExReplace.htm">RegExReplace()</a>, <a href="../misc/RegEx-QuickRef.htm">RegEx Quick Reference</a>, <a href="../misc/RegExCallout.htm">정규 표현식 외부요청</a>, <a href="../Functions.htm#InStr">InStr()</a>, <a href="IfInString.htm">IfInString</a>, <a href="StringGetPos.htm">StringGetPos</a>, <a href="../Functions.htm#SubStr">SubStr()</a>, <a href="SetTitleMatchMode.htm#RegEx">SetTitleMatchMode RegEx</a>, <a href="http://www.autohotkey.com/forum/topic16164.html">전역적 일치와 Grep (포럼 링크)</a></p>
<p>
텍스트 데이터를 얻는 흔한 방법: <a href="FileRead.htm">FileRead</a>, <a href="URLDownloadToFile.htm">UrlDownloadToFile</a>, <a href="../misc/Clipboard.htm">Clipboard</a>, <a href="GuiControls.htm#Edit">GUI 편집 콘트롤</a></p>

<h3>예제</h3>
<pre class="NoIndent">FoundPos := RegExMatch(&quot;xxxabc123xyz&quot;, &quot;abc.*xyz&quot;)  <em>; 4를 돌려줍니다, 부합이 발견된 위치입니다.</em>
FoundPos := RegExMatch(&quot;abc123123&quot;, &quot;123$&quot;)  <em>; $가 끝에 부합하기를 요구하기 때문에 7을 돌려줍니다.</em>
FoundPos := RegExMatch(&quot;abc123&quot;, &quot;i)^ABC&quot;)  <em>; 대소문자를 구분하지 않는 옵션을 통하여 부합했으므로 1을 돌려줍니다.</em>
FoundPos := RegExMatch(&quot;abcXYZ123&quot;, &quot;abc(.*)123&quot;, SubPat)  <em>; 1을 돌려주고 &quot;XYZ&quot;를 SubPat1에 저장합니다.</em>
FoundPos := RegExMatch(&quot;abc123abc456&quot;, &quot;abc\d+&quot;, &quot;&quot;, 2)  <em>; 시작 위치가 1이 아니라 2이기 때문에 1 이 아니라 7을 돌려줍니다..</em>

<em>; 일반적인 RegEx 예제들은 <a href="../misc/RegEx-QuickRef.htm">RegEx 간편 참조서</a>를 참조하십시오.</em></pre>

</body>
</html>
