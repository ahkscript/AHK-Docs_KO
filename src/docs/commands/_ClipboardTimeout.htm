

<html>
<head>
<title>#ClipboardTimeout</title>
<meta http-equiv="Content-Type" content="text/html; charset=euc-kr">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<link href="../static/theme.css" rel="stylesheet" type="text/css" />
<script src="../static/content.js" type="text/javascript"></script>
</head>
<body>

<h1>#ClipboardTimeout</h1>

<p>첫 시도가 실패하면 스크립트가 클립보드에 얼마나 오랫동안 접근을 시도해야 하는지 변경합니다.</p>

<pre class="Syntax">#ClipboardTimeout Milliseconds</pre>
<h3>매개변수</h3>
<dl>

  <dt>Milliseconds</dt>
  <dd><p>밀리초 단위 간격. -1을 지정하면 무제한 시도합니다. 0을 지정하면 한 번만 시도합니다. 이 지시어가 없는 스크립트는 1000 ms 시간제한을 사용합니다.</p></dd>

</dl>
<h3>논평</h3>
<p>
어떤 어플리케이션은 클립보드를 오랜 시간 동안 열어 둡니다. 아마도 상당히 많은 양의 데이터를 읽고 쓰기 위해서 일겁니다. 그런 경우, 이 설정을 증가시키면 스크립트가 포기하고 에러 메시지를 보여주기 전에 오랫 동안 기다릴 수 있습니다.</p>
<p>
이 설정은 모든 <a href="../misc/Clipboard.htm">클립보드</a> 연산에 적용됩니다.  그 중에 가장 단순한 예는 다음과 같습니다: <code>Var = %Clipboard%</code> 그리고 <code>Clipboard = New Text</code>.</p>
<p>
클립보드가 다시 사용 가능할 때까지 스크립트가 기다릴 때마다, 새 <a href="../misc/Threads.htm">쓰레드</a>는 기동할 수 <u>없으며</u> <a href="SetTimer.htm">타이머</a>도 실행되지 않습니다. 그렇지만, 사용자가 <a href="../Hotkeys.htm">핫키</a>를 누르거나, <a href="Menu.htm">맞춤 메뉴 항목</a>을 선택하거나, 아니면 버튼을 누른 것과 같은 <a href="Gui.htm">GUI 행위</a>를 수행하면, 그 이벤트는 나중에, 다시 말해, 클립보드가 완전히 사용 가능해진 후에 그의 서브루틴이 실행될 때까지 버퍼 처리됩니다.</p>
<p>
이 지시어가 있으면 첫 시도가 실패하더라도 클립보드 데이터를 다시 읽으려고 시도하지 않습니다. v1.1.16 이전에서는 스크립트가 시간제한이 풀릴 때까지 기다려야 했습니다. 그러나 그렇게 함으로써 더 이상 데이터를 받지 못하게 되었습니다.</p>

<h3>관련 항목</h3>
<p><a href="../misc/Clipboard.htm">Clipboard</a>, <a href="Thread.htm">Thread</a></p>
<h3>예제</h3>
<pre class="NoIndent">#ClipboardTimeout 2000</pre>

</body>
</html>
