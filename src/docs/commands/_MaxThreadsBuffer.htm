

<html>
<head>
<title>#MaxThreadsBuffer</title>
<meta http-equiv="Content-Type" content="text/html; charset=euc-kr">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<link href="../static/theme.css" rel="stylesheet" type="text/css" />
<script src="../static/content.js" type="text/javascript"></script>
</head>
<body>

<h1>#MaxThreadsBuffer</h1>
<p>
<a href="_MaxThreadsPerHotkey.htm">#MaxThreadsPerHotkey</a> 제한에 도달할 때 키눌림을 무시하지 않고 모든 또는 어느 정도는 <a href="../Hotkeys.htm">핫키</a>가 버퍼 처리됩니다.</p>

<pre class="Syntax">#MaxThreadsBuffer On|Off</pre>
<h3>매개변수</h3>
<dl>

  <dt>On|Off</dt>
  <dd><p><strong>On</strong>: 여기부터 다음 <code>#MaxThreadsBuffer ON</code> 지시어 사이의 모든 핫키 서브루틴이 <a href="_MaxThreadsPerHotkey.htm">#MaxThreadsPerHotkey</a> 제한에 걸릴 때마다 핫키의 눌림을 무시하는 대신에 버퍼 처리됩니다.</p>
    <p><strong>Off</strong>: 이것이 기본 행위입니다. 핫키를 눌러도 핫키가 이미 쓰레드의 최대 개수를 이미 실행하고 있다면 무시됩니다 (보통 1이지만, 이는 <a href="_MaxThreadsPerHotkey.htm">#MaxThreadsPerHotkey</a>로 바꿀 수 있습니다).</p></dd>

</dl>

<h3>논평</h3>
<p>
이 지시어는 잘 사용되지 않습니다. 왜냐하면 이런 유형의 버퍼 처리는, OFF가 기본값인데, 보통 득보다 실이 많기 때문입니다. 예를 들어, 우발적으로 핫키를 두 번 눌러, 이 설정이 ON이 되고, 그의 첫 번째 <a href="../misc/Threads.htm">쓰레드</a>가 끝나는데 1 초보다 적게 걸리면 그 핫키의 서브루틴은 자동으로 두 번 실행됩니다. (이런 유형의 버퍼는 1초 이후에 종료되도록 설계되어 있습니다). 오토핫키는 핫키를 여러가지 방식으로 버퍼 처리한다는 것을 주목하십시오 (예를 들어 <code><a href="Thread.htm">Thread Interrupt</a></code> 그리고 <code><a href="Critical.htm">Critical</a></code>). 이런 특이한 방식은 해롭기만 할 뿐입니다. 그리하여 기본으로 OFF 상태입니다.</p>
<p>
이 지시어를 사용하는 주 목적은 키보드의 자동-반복 특징의 반응 능력을 끌어 올리는 데 있습니다. 예를 들어, 핫키를 누르고 있을 때 <a href="_MaxThreadsPerHotkey.htm">#MaxThreadsPerHotkey</a>가 1로 설정되어 있다면 (기본값), 들어오는 키눌림은 그 핫키 서브루틴이 이미 실행 중일 경우 무시됩니다. 그리하여, 서브루틴이 끝날 때, 다음 자동-반복 키눌림이 들어오기를 기다려야 합니다. 이 대기 시간은 자동-반복 사이클의 키눌림 사이에 잡혀 있기 때문에 대략 50ms 남짓 걸릴 것입니다. 이 50ms의 지연 시간을 피할 수 있습니다. 자동-반복되는 동안에 좋은 반응성이 필요한 모든 핫키에 이 지시어를 활성화하면 됩니다.</p>
<p>
다른 모든 # 지시어처럼, 이 지시어는 그냥 명령어처럼 아무데나 배치하면 안됩니다 (즉, 서브루틴 안에 포함시킬 필요가 없습니다). 대신에, 효과를 주고 싶은 첫 핫키 라벨 바로 다음에 배치하십시오.</p>

<h3>관련 항목</h3>
<p><a href="_MaxThreads.htm">#MaxThreads</a>, <a href="_MaxThreadsPerHotkey.htm">#MaxThreadsPerHotkey</a>, <a href="Critical.htm">Critical</a>, <a href="Thread.htm">Thread (명령어)</a>, <a href="../misc/Threads.htm">쓰레드</a>, <a href="Hotkey.htm">핫키</a>, <a href="_MaxHotkeysPerInterval.htm">#MaxHotkeysPerInterval</a>, <a href="_HotkeyInterval.htm">#HotkeyInterval</a>, <a href="ListHotkeys.htm">ListHotkeys</a></p>

<h3>예제</h3>
<pre class="NoIndent">#MaxThreadsBuffer on
#x::MsgBox, 이 핫키는 위와 같은 종류의 버퍼 처리를 사용합니다.
#y::MsgBox, 이것도 마찬가지입니다.
#MaxThreadsBuffer off
#z::MsgBox, 그러나 이것은 아닙니다.</pre>

</body>
</html>
