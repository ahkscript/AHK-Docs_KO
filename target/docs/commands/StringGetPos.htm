<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<title>StringGetPos</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<link href="../static/theme.css" rel="stylesheet" type="text/css" />
<script src="../static/content.js" type="text/javascript"></script>
</head>
<body>

<h1>StringGetPos</h1>

<p>문자열 안에서 지정된 부분문자열의 위치를 열람합니다.</p>

<pre class="Syntax">StringGetPos, OutputVar, InputVar, SearchText [, L#|R#, Offset]
Position := <a href="../Functions.htm#InStr">InStr</a>(Haystack, Needle [, CaseSensitive?, StartingPos]) <em>; 자세한 것은 <a href="../Functions.htm#InStr">InStr() function</a>를 참조합니다.</em></pre>
<h3>매개변수</h3>
<dl>

  <dt>OutputVar</dt>
  <dd><p>열람된 위치를 저장할 변수의 이름. <em>InputVar</em>의 첫 문자에 상대적입니다. 위치가 0이면 StringGetPos에 대하여 첫 문자이고 위치가 1이면 <a href="../Functions.htm#InStr">InStr()</a>에 대하여 첫 문자입니다.</p></dd>

  <dt>InputVar</dt>
  <dd><p>내용이 검색될 입력 변수의 이름. 이름을 퍼센트 사인으로 둘러 싸지 마십시오. 변수의 <em>내용</em>을 이름으로 사용하고 싶다면 예외입니다.</p></dd>

  <dt>SearchText</dt>
  <dd><p>검색할 문자열. 부합은 대소문자를 구분하지 않습니다. 단, <a href="StringCaseSense.htm">StringCaseSense</a>가 켜져 있는 경우는 예외입니다.</p></dd>

  <dt>L#|R#</dt>
  <dd><p>이 매개변수는 <em>InputVar</em> 안에서 <em>SearchText</em>가 여러 번 출현하면 몇 번째 부합을 발견할지에 영향을 미칩니다. 이 매개변수를 생략하면, 첫 번째 부합을 위해 <em>InputVar</em>를 왼쪽부터 검색합니다. 이 매개변수가 1이거나 기호 R이면, 검색이 <em>InputVar</em>의 오른쪽부터 시작해 왼쪽으로 첫 번째 부합을 발견할 때까지 계속됩니다.</p>
      <p>첫 번째 부합말고 다른 부합을 발견하려면, 기호 L 또는 R 다음에 출현 횟수를 지정하십시오. 예를 들어, 오른쪽에서 네 번째 출현을 발견하고 싶으면. r4를 지정하십시오. 주의: 숫자를 0이하로 지정하면, 부합이 발견되지 않습니다.</p></dd>

  <dt>Offset</dt>
  <dd><p>왼쪽 끝 또는 오른쪽 끝으로부터 (위의 매개변수에 따라) 건너 뛸 문자의 개수. 생략하면, 기본값은 0입니다. 예를 들어, 다음은 왼쪽 10번째 문자부터 검색을 시작합니다: <code>StringGetPos, OutputVar, InputVar, abc, , 9</code>. 이 매개변수는 <a href="../Variables.htm#Expressions">표현식</a>일 수 있습니다.</p></dd>

</dl>

<h3>ErrorLevel</h3>
<p><a href="../misc/ErrorLevel.htm">ErrorLevel</a>은 지정된 <em>SearchText</em>의 출현을 <em>InputVar</em> 안에서 발견할 수 없었으면 1이 설정되고 그렇지 않으면 0이 설정됩니다.</p>
<h3>논평</h3>
<p><a href="StringMid.htm">StringMid</a> 그리고 <a href="../Functions.htm#InStr">InStr()</a>와 다르게, StringGetPos에 대하여 0은 첫 번째 문자의 위치로 정의됩니다.</p>
<p>열람된 위치는 언제나 <em>InputVar</em>의 첫 문자에 상대적입니다. <em>L#|R#</em> 그리고/또는 <em>Offset</em>이 지정되어 있든 말든 상관이 없습니다. 예를 들어, 문자열 "abc"가 123abc789에서 발견되면, 보고된 그의 위치는 언제나 3입니다. 어떤 방법으로 발견했는지는 상관이 없습니다.</p>
<p><em>SearchText</em>의 지정된 출현이 <em>InputVar</em>안에 존재하지 않으면, <em>OutputVar</em>는 -1이 설정되고 <a href="../misc/ErrorLevel.htm">ErrorLevel</a>는 1이 설정됩니다.</p>
<p><a href="SplitPath.htm">SplitPath</a>를 사용하면 보다 쉽게 파일 경로를 그의 디렉토리와 파일이름 그리고 확장자로 가를 수 있습니다.</p>
<p>내장 변수 <a href="../Variables.htm">%A_Space%</a>와 <a href="../Variables.htm">%A_Tab%</a>에 각각 스페이스 문자 하나와 탭 문자 하나가 들어 있습니다. <em>SearchText</em>의 앞이나 뒤에서 스페이스와 탭을 따로 검색할 경우에 유용합니다.</p>
<h3>관련 항목</h3>
<p><a href="../Functions.htm#InStr">InStr()</a>, <a href="RegExMatch.htm">RegExMatch()</a>, <a href="IfInString.htm">IfInString</a>, <a href="IfIn.htm">if var in/contains MatchList</a>, <a href="StringCaseSense.htm">StringCaseSense</a>, <a href="StringReplace.htm">StringReplace</a>, <a href="SplitPath.htm">SplitPath</a>, <a href="StringLeft.htm">StringLeft</a>, <a href="StringLeft.htm">StringRight</a>, <a href="StringMid.htm">StringMid</a>, <a href="StringTrimLeft.htm">StringTrimLeft</a>, <a href="StringTrimLeft.htm">StringTrimRight</a>, <a href="StringLen.htm">StringLen</a>, <a href="StringLower.htm">StringLower</a>, <a href="StringLower.htm">StringUpper</a>, <a href="IfIs.htm">if var is type</a></p>
<h3>예제</h3>
<pre class="NoIndent">Haystack = abcdefghijklmnopqrs
Needle = def
StringGetPos, pos, Haystack, %Needle%
if pos &gt;= 0
    MsgBox, 문자열이 위치 %pos%에서 발견되었습니다.</pre>
<p>&nbsp;</p>
<pre class="NoIndent"><em>; 예제 #2:
; 파일이 전체 경로를 각 구성요소로 분해 합니다.
; <a href="StringSplit.htm">StringSplit</a> 또는
;  <a href="LoopParse.htm">파싱 회돌이</a>를 사용하면 훨씬 더 쉽게 가를 수 있습니다. 그래서 아래는 그저 보여주기 용입니다.</em>
FileSelectFile, file, , , 깊숙히 내포된 폴더 안에서 파일이름 하나를 고르십시오:
if file &lt;&gt;
{
    StringLen, pos_prev, file
    pos_prev += 1 <em>; 마지막 문자 뒤에 위치에 맞게 조절합니다.</em>
    Loop
    {
        <em>; 오른쪽으로부터 N번째 출현을 검색합니다:</em>
        <strong>StringGetPos</strong>, pos, file, \, R%A_Index%
        if ErrorLevel
            break
        length := pos_prev - pos - 1
        pos_prev := pos
        pos += 2  <em>; StringMid에 사용하기 위해 조정합니다.</em>
        StringMid, path_component, file, %pos%, %length%
        MsgBox Path component #%a_index% (from the right) is:`n%path_component%
    }
}</pre>

</body>
</html>
